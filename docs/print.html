<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Kubernetes CSI Documentation</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="CSI support for Kubernetes">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="Home.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><a href="Setup.html"><strong aria-hidden="true">2.</strong> Using a CSI Driver</a></li><li><ol class="section"><li><a href="Deployment.html"><strong aria-hidden="true">2.1.</strong> Deployment</a></li><li><a href="Drivers.html"><strong aria-hidden="true">2.2.</strong> Drivers</a></li><li><a href="Usage.html"><strong aria-hidden="true">2.3.</strong> Usage</a></li><li><a href="Example.html"><strong aria-hidden="true">2.4.</strong> Example</a></li></ol></li><li><a href="Development.html"><strong aria-hidden="true">3.</strong> Development</a></li><li><ol class="section"><li><a href="CSI-Driver.html"><strong aria-hidden="true">3.1.</strong> Developing a CSI driver</a></li><li><a href="CSI-Kubernetes.html"><strong aria-hidden="true">3.2.</strong> Deploying in Kubernetes</a></li><li><a href="Testing.html"><strong aria-hidden="true">3.3.</strong> Testing</a></li><li><ol class="section"><li><a href="Testing-Clients.html"><strong aria-hidden="true">3.3.1.</strong> Clients</a></li><li><a href="Testing-Drivers.html"><strong aria-hidden="true">3.3.2.</strong> Drivers</a></li></ol></li></ol></li><li><a href="Troubleshooting.html"><strong aria-hidden="true">4.</strong> Troubleshooting</a></li><li><a href="References.html"><strong aria-hidden="true">5.</strong> References</a></li><li><a href="Archive.html"><strong aria-hidden="true">6.</strong> Archive</a></li><li><ol class="section"><li><a href="Kubernetes-1.9.html"><strong aria-hidden="true">6.1.</strong> Kubernetes 1.9</a></li><li><a href="Kubernetes-1.10.html"><strong aria-hidden="true">6.2.</strong> Kubernetes 1.10</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Kubernetes CSI Documentation</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#introduction" id="introduction"><h1>Introduction</h1></a>
<a class="header" href="#kubernetes-csi-documentation" id="kubernetes-csi-documentation"><h2>Kubernetes CSI Documentation</h2></a>
<p>Welcome to the CSI for Kubernetes documentation repository. Here you will find information on how to use, develop, and deploy CSI plugins, or drivers, with Kubernetes.</p>
<a class="header" href="#project-status" id="project-status"><h2>Project status</h2></a>
<table><thead><tr><th> Kubernetes </th><th> CSI spec </th><th> Status </th></tr></thead><tbody>
<tr><td> v1.9       </td><td> v0.1     </td><td> Alpha  </td></tr>
<tr><td> v1.10      </td><td> v0.2     </td><td> Beta   </td></tr>
<tr><td> v1.11      </td><td> v0.3     </td><td> Beta   </td></tr>
</tbody></table>
<a class="header" href="#sidecar-container-status" id="sidecar-container-status"><h2>Sidecar container status</h2></a>
<table><thead><tr><th> Container Name </th><th> CSI spec </th><th> Latest Release Tag </th></tr></thead><tbody>
<tr><td> csi-provisioner </td><td> v0.3 </td><td> v0.3.0 </td></tr>
<tr><td> csi-attacher </td><td> v0.3 </td><td> v0.3.0 </td></tr>
<tr><td> driver-registrar </td><td> v0.3 </td><td> v0.3.0 </td></tr>
</tbody></table>
<a class="header" href="#installation" id="installation"><h2>Installation</h2></a>
<p>Please see the <a href="Setup.html">Setup</a> page for instructions on how to setup Kubernetes support with CSI.</p>
<a class="header" href="#setup" id="setup"><h1>Setup</h1></a>
<p>To use CSI drivers, your Kubernetes cluster must allow privileged pods (i.e. <code>--allow-privileged</code> flag must be set to <code>true</code> for both the API server and the kubelet). This is the default in some environments (e.g. GCE, GKE, <code>kubeadm</code>).</p>
<p>Moreover, as stated in the <a href="https://kubernetes.io/docs/concepts/storage/volumes/#mount-propagation">mount propagation docs</a>, the Docker daemon of the cluster nodes must allow shared mounts. <a href="https://docs.portworx.com/knowledgebase/shared-mount-propogation.html">This page</a> explains how to check if shared mounts are enabled and how to configure Docker for shared mounts.</p>
<p>This document has been updated to the latest version of Kubernetes v1.11.</p>
<a class="header" href="#alpha-features" id="alpha-features"><h2>Alpha Features</h2></a>
<a class="header" href="#csi-raw-block-volume-support" id="csi-raw-block-volume-support"><h4>CSI Raw block volume support</h4></a>
<p><a href="https://kubernetes.io/docs/concepts/storage/volumes/#csi-raw-block-volume-support">CSI Raw block volume support</a>: To enable support for raw block volumes
you mest set the following feature gate on Kubernetes v1.11:</p>
<pre><code>--feature-gates=BlockVolume=true,CSIBlockVolume=true
</code></pre>
<p>Also, see <a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#raw-block-volume-support">Raw Block Volume Support</a></p>
<a class="header" href="#kubelet-plugin-watcher" id="kubelet-plugin-watcher"><h4>Kubelet Plugin Watcher</h4></a>
<p><a href="https://docs.google.com/document/d/1dtHpGY-gPe9sY7zzMGnm8Ywo09zJfNH-E1KEALFV39s/edit#heading=h.7fe6spexljh6">Kubelet Plugin Watcher</a>: To enable support for Kubelet plugin
watcher for CSI plugins:</p>
<pre><code>--feature-gates=KubeletPluginsWatcher=true
</code></pre>
<p>You will also need to use the following flag in your <code>driver-registrar</code> side-car
container with the value set to the location of kubekel plugin watcher socket:</p>
<pre><code>--kubelet-registration-path: Enables Kubelet Plugin Registration service, and returns
  the specified path as &quot;endpoint&quot; in &quot;PluginInfo&quot; response. If this option is set, the
  driver-registrar expose a unix domain socket to handle Kubelet Plugin Registration,
  this socket MUST be surfaced on the host in the kubelet plugin registration director
  (in addition to the CSI driver socket). If plugin registration is enabled on kubelet
  (kubelet flag KubeletPluginsWatcher is set), then this option should be set and the
  value should be the path of the CSI driver socket on the host machine.
</code></pre>
<a class="header" href="#archives" id="archives"><h2>Archives</h2></a>
<p>Please visit the <a href="Archive.html">Archives</a> for setup instructions on previous versions of Kubernetes.</p>
<a class="header" href="#deployment" id="deployment"><h1>Deployment</h1></a>
<p>To benefit from the new CSI support, you will need to deploy a CSI driver. Please visit the <a href="Drivers.html">Drivers</a> page to determine how to deploy your specific driver. A functional example based on the HostPath driver is presented in the <a href="Example.html">Example</a> section.</p>
<a class="header" href="#drivers" id="drivers"><h1>Drivers</h1></a>
<p>The following are a set of CSI driver which can be used with Kubernetes:</p>
<blockquote>
<p>NOTE: If you would like your driver to be added to this table, please create an issue in this repo with the information you would like to add here.</p>
</blockquote>
<a class="header" href="#sample-drivers" id="sample-drivers"><h3>Sample Drivers</h3></a>
<table><thead><tr><th>Name </th><th> Status </th><th> More Information</th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/drivers/tree/master/pkg/flexadapter">Flexvolume</a> </td><td> Sample </td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/drivers/tree/master/pkg/hostpath">HostPath</a> </td><td> v0.2.0 </td><td> Only use for a single node tests. See the <a href="Example.html">Example</a> page for Kubernetes-specific instructions.</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/csi-test/tree/master/mock/service">In-memory Sample Mock Driver</a> </td><td> v0.3.0 </td><td> The sample mock driver used for <a href="https://github.com/kubernetes-csi/csi-test/tree/master/cmd/csi-sanity">csi-sanity</a></td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/drivers/tree/master/pkg/nfs">NFS</a> </td><td> Sample </td></tr>
<tr><td><a href="https://github.com/thecodeteam/csi-vfs">VFS Driver</a> </td><td> Released </td><td> A CSI plugin that provides a virtual file system.</td></tr>
</tbody></table>
<a class="header" href="#production-drivers" id="production-drivers"><h3>Production Drivers</h3></a>
<table><thead><tr><th>Name </th><th> Status </th><th> More Information</th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes/cloud-provider-openstack/tree/master/pkg/csi/cinder">Cinder</a></td><td>v0.2.0</td><td>A Container Storage Interface (CSI) Storage Plug-in for Cinder</td></tr>
<tr><td><a href="https://github.com/digitalocean/csi-digitalocean">DigitalOcean Block Storage</a> </td><td> v0.0.1 (alpha) </td><td> A Container Storage Interface (CSI) Driver for DigitalOcean Block Storage</td></tr>
<tr><td><a href="https://github.com/kubernetes-sigs/gcp-compute-persistent-disk-csi-driver">GCE Persistent Disk</a></td><td>Alpha</td><td>A Container Storage Interface (CSI) Storage Plugin for Google Compute Engine Persistent Disk</td></tr>
<tr><td><a href="https://www.opensds.io/">OpenSDS</a> </td><td> Beta </td><td> For more information, please visit <a href="https://github.com/opensds/nbp/releases">releases</a> and https://github.com/opensds/nbp/tree/master/csi</td></tr>
<tr><td><a href="https://portworx.com/">Portworx</a> </td><td> 0.2.0 </td><td> CSI implementation is available <a href="https://github.com/libopenstorage/openstorage/tree/master/csi">here</a> which can be used as an example also.</td></tr>
<tr><td><a href="https://github.com/ceph/ceph-csi">RBD</a></td><td>v0.2.0</td><td>A Container Storage Interface (CSI) Storage RBD Plug-in for Ceph</td></tr>
<tr><td><a href="https://github.com/ceph/ceph-csi">CephFS</a></td><td>v0.2.0</td><td>A Container Storage Interface (CSI) Storage Plug-in for CephFS</td></tr>
<tr><td><a href="https://github.com/thecodeteam/csi-scaleio">ScaleIO</a></td><td>v0.1.0</td><td>A Container Storage Interface (CSI) Storage Plugin for DellEMC ScaleIO</td></tr>
<tr><td><a href="https://github.com/thecodeteam/csi-vsphere">vSphere</a></td><td>v0.1.0</td><td>A Container Storage Interface (CSI) Storage Plug-in for VMware vSphere</td></tr>
<tr><td><a href="https://github.com/NetApp/trident">NetApp</a> </td><td> v0.2.0 (alpha) </td><td> A Container Storage Interface (CSI) Storage Plug-in for NetApp's <a href="https://netapp-trident.readthedocs.io/">Trident</a> container storage orchestrator</td></tr>
<tr><td><a href="https://ember-csi.io">Ember CSI</a> </td><td> v0.2.0 (alpha) </td><td> Multi-vendor CSI plugin supporting over 80 storage drivers to provide block and mount storage to Container Orchestration systems.</td></tr>
<tr><td><a href="https://portal.nutanix.com/#/page/docs/details?targetId=CSI-Volume-Driver:CSI-Volume-Driver">Nutanix</a> </td><td> beta </td><td> A Container Storage Interface (CSI) Storage Driver for Nutanix</td></tr>
</tbody></table>
<a class="header" href="#testing" id="testing"><h2>Testing</h2></a>
<p>There are multiple ways to test your driver. Please see <a href="Testing-Drivers.html">Testing Drivers</a> for more information.</p>
<a class="header" href="#usage" id="usage"><h1>Usage</h1></a>
<p>There are two main models of how to use storage in Kubernetes with CSI drivers. These models include either the usage of pre-provisioned volumes or dynamic provisioned volumes. Please check the documentation of your specific driver for more information.</p>
<a class="header" href="#pre-provisioned-volumes" id="pre-provisioned-volumes"><h3>Pre-provisioned volumes</h3></a>
<p>Pre-provisioned drivers work just as they did before, where the administrator would create a <a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes"><em>PersistentVolume</em></a> specification which would describe the volume to be used. The PersistentVolume specification would need to be setup according to your driver, the difference here is that there is a new section called <em>csi</em> which needs to be setup accordingly. Please see <a href="https://kubernetes.io/docs/concepts/storage/volumes/#csi">Kubernetes Documentation on CSI Volumes</a>.</p>
<p>Here is an example of a <em>PersistentVolume</em> specification of a pre-provisioned volume managed by a CSI driver:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: PersistentVolume
metadata:
  name: manually-created-pv
spec:
  capacity:
    storage: 5Gi
  accessModes:
    - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  csi:
    driver: com.example.team/csi-driver
    volumeHandle: existingVolumeName
    readOnly: false
</code></pre>
<a class="header" href="#dynamic-provisioning" id="dynamic-provisioning"><h3>Dynamic Provisioning</h3></a>
<p>To setup the system for dynamic provisioning, the administrator needs to setup a <a href="https://kubernetes.io/docs/concepts/storage/storage-classes"><em>StorageClass</em></a> pointing to the CSI driver’s external-provisioner and specifying any parameters required by the driver. Here is an example of a StorageClass:</p>
<pre><code class="language-yaml">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: fast-storage
provisioner: com.example.team/csi-driver
parameters:
  type: pd-ssd
</code></pre>
<p>Where,</p>
<ul>
<li><em>provisioner</em>: Must be set to the name of the CSI driver</li>
<li><em>parameters</em>: Must contain any parameters specific to the CSI driver.</li>
</ul>
<p>The user can then create a <em>PersistentVolumeClaim</em> utilizing this StorageClass as follows:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: request-for-storage
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 5Gi
  storageClassName: fast-storage
</code></pre>
<a class="header" href="#csi-provisioner-parameters" id="csi-provisioner-parameters"><h4>CSI Provisioner Parameters</h4></a>
<p>The CSI dynamic provisioner makes <code>CreateVolumeRequest</code> and <code>DeleteVolumeRequest</code> calls to CSI drivers.
The <code>controllerCreateSecrets</code> and <code>controllerDeleteSecrets</code> fields in those requests can be populated
with data from a Kubernetes <code>Secret</code> object by setting <code>csiProvisionerSecretName</code> and <code>csiProvisionerSecretNamespace</code>
parameters in the <code>StorageClass</code>. For example:</p>
<pre><code class="language-yaml">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: fast-storage
provisioner: com.example.team/csi-driver
parameters:
  type: pd-ssd
  csiProvisionerSecretName: fast-storage-provision-key
  csiProvisionerSecretNamespace: pd-ssd-credentials
</code></pre>
<p>The <code>csiProvisionerSecretName</code> and <code>csiProvisionerSecretNamespace</code> parameters
may specify literal values, or a template containing the following variables:</p>
<ul>
<li><code>${pv.name}</code> - replaced with the name of the PersistentVolume object being provisioned</li>
</ul>
<p>Once the CSI volume is created, a corresponding Kubernetes <code>PersistentVolume</code> object is created.
The <code>controllerPublishSecretRef</code>, <code>nodeStageSecretRef</code>, and <code>nodePublishSecretRef</code> fields in the
<code>PersistentVolume</code> object can be populated via the following storage class parameters:</p>
<ul>
<li><code>controllerPublishSecretRef</code> in the PersistentVolume is populated by setting these StorageClass parameters:
<ul>
<li><code>csiControllerPublishSecretName</code></li>
<li><code>csiControllerPublishSecretNamespace</code></li>
</ul>
</li>
<li><code>nodeStageSecretRef</code> in the PersistentVolume is populated by setting these StorageClass parameters:
<ul>
<li><code>csiNodeStageSecretName</code></li>
<li><code>csiNodeStageSecretNamespace</code></li>
</ul>
</li>
<li><code>nodePublishSecretRef</code> in the PersistentVolume is populated by setting these StorageClass parameters:
<ul>
<li><code>csiNodePublishSecretName</code></li>
<li><code>csiNodePublishSecretNamespace</code></li>
</ul>
</li>
</ul>
<p>The <code>csiControllerPublishSecretName</code>, <code>csiNodeStageSecretName</code>, and <code>csiNodePublishSecretName</code> parameters
may specify a literal secret name, or a template containing the following variables:</p>
<ul>
<li><code>${pv.name}</code> - replaced with the name of the PersistentVolume</li>
<li><code>${pvc.name}</code> - replaced with the name of the PersistentVolumeClaim</li>
<li><code>${pvc.namespace}</code> - replaced with the namespace of the PersistentVolumeClaim</li>
<li><code>${pvc.annotations['&lt;ANNOTATION_KEY&gt;']}</code> (e.g. <code>${pvc.annotations['example.com/key']}</code>) - replaced with the value of the specified annotation in the PersistentVolumeClaim</li>
</ul>
<p>The <code>csiControllerPublishSecretNamespace</code>, <code>csiNodeStageSecretNamespace</code>, and <code>csiNodePublishSecretNamespace</code> parameters
may specify a literal namespace name, or a template containing the following variables:</p>
<ul>
<li><code>${pv.name}</code> - replaced with the name of the PersistentVolume</li>
<li><code>${pvc.namespace}</code> - replaced with the namespace of the PersistentVolumeClaim</li>
</ul>
<p>As an example, consider this StorageClass:</p>
<pre><code class="language-yaml">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: fast-storage
provisioner: com.example.team/csi-driver
parameters:
  type: pd-ssd

  csiProvisionerSecretName: fast-storage-provision-key
  csiProvisionerSecretNamespace: pd-ssd-credentials

  csiControllerPublishSecretName: ${pv.name}-publish
  csiControllerPublishSecretNamespace: pd-ssd-credentials

  csiNodeStageSecretName: ${pv.name}-stage
  csiNodeStageSecretNamespace: pd-ssd-credentials

  csiNodePublishSecretName: ${pvc.annotations['com.example.team/key']}
  csiNodePublishSecretNamespace: ${pvc.namespace}
</code></pre>
<p>This StorageClass instructs the CSI provisioner to do the following:</p>
<ul>
<li>send the data in the <code>fast-storage-provision-key</code> secret in the <code>pd-ssd-credentials</code> namespace as part of the create request to the CSI driver</li>
<li>create a PersistentVolume with:
<ul>
<li>a per-volume controller publish and node stage secret, both in the <code>pd-ssd-credentials</code> (those secrets would need to be created separately in response to the PersistentVolume creation before the PersistentVolume could be attached/mounted)</li>
<li>a node publish secret in the same namespace as the PersistentVolumeClaim that triggered the provisioning, with a name specified as an annotation on the PersistentVolumeClaim. This could be used to give the creator of the PersistentVolumeClaim the ability to specify a secret containing a decryption key they have control over.</li>
</ul>
</li>
</ul>
<a class="header" href="#example" id="example"><h1>Example</h1></a>
<p>The
<a href="https://github.com/kubernetes-csi/drivers/tree/master/pkg/hostpath">HostPath</a>
can be used to provision local storage in a single node test. This
section shows how to deploy and use that driver in Kubernetes.</p>
<a class="header" href="#deployment-1" id="deployment-1"><h2>Deployment</h2></a>
<p>The following .yaml file will deploy a <code>csi-pod</code> with the HostPath CSI driver and the
<a href="CSI-Kubernetes.html#sidecar-containers">sidecar containers</a> which integrate the driver into Kubernetes.
Use it with a cluster that is <a href="Setup.html">set up for CSI</a>, either by copying it into a local file or
by referencing the latest version directly:</p>
<pre><code>$ kubectl create -f https://raw.githubusercontent.com/kubernetes-csi/docs/master/book/src/example/csi-setup.yaml
storageclass.storage.k8s.io &quot;csi-hostpath-sc&quot; created
serviceaccount &quot;csi-service-account&quot; created
clusterrole.rbac.authorization.k8s.io &quot;csi-cluster-role&quot; created
clusterrolebinding.rbac.authorization.k8s.io &quot;csi-role-binding&quot; created
pod &quot;csi-pod&quot; created
$ kubectl get pods
NAME      READY     STATUS    RESTARTS   AGE
csi-pod   4/4       Running   0          24s
</code></pre>
<pre><code class="language-yaml">apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: csi-hostpath-sc
provisioner: csi-hostpath
reclaimPolicy: Delete
volumeBindingMode: Immediate
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: csi-service-account
  namespace: default
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: csi-cluster-role
rules:
- apiGroups:
  - &quot;&quot;
  resources:
  - persistentvolumes
  verbs:
  - create
  - delete
  - get
  - list
  - watch
  - update
- apiGroups:
  - &quot;&quot;
  resources:
  - secrets
  verbs:
  - get
  - list
- apiGroups:
  - &quot;&quot;
  resources:
  - persistentvolumeclaims
  verbs:
  - get
  - list
  - watch
  - update
- apiGroups:
  - &quot;&quot;
  resources:
  - nodes
  verbs:
  - get
  - list
  - watch
  - update
- apiGroups:
  - storage.k8s.io
  resources:
  - volumeattachments
  verbs:
  - get
  - list
  - watch
  - update
- apiGroups:
  - storage.k8s.io
  resources:
  - storageclasses
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - &quot;&quot;
  resources:
  - events
  verbs:
  - list
  - watch
  - create
  - update
  - patch
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: csi-role-binding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: csi-cluster-role
subjects:
- kind: ServiceAccount
  name: csi-service-account
  namespace: default
---
apiVersion: v1
kind: Pod
metadata:
  labels:
    app: hostpath-driver
  name: csi-pod
  namespace: default
spec:
  serviceAccount: csi-service-account
  containers:
  - name: external-provisioner
    args:
    - --v=5
    - --provisioner=csi-hostpath
    - --csi-address=/csi/csi.sock
    image: quay.io/k8scsi/csi-provisioner:v0.2.1
    imagePullPolicy: Always
    volumeMounts:
    - mountPath: /csi
      name: socket-dir
  - name: driver-registrar
    args:
    - --v=5
    - --csi-address=/csi/csi.sock
    env:
    - name: KUBE_NODE_NAME
      valueFrom:
        fieldRef:
          apiVersion: v1
          fieldPath: spec.nodeName
    image: quay.io/k8scsi/driver-registrar:v0.2.0
    imagePullPolicy: Always
    volumeMounts:
    - mountPath: /csi
      name: socket-dir
  - name: external-attacher
    args:
    - --v=5
    - --csi-address=$(ADDRESS)
    env:
    - name: ADDRESS
      value: /csi/csi.sock
    image: quay.io/k8scsi/csi-attacher:v0.2.0
    imagePullPolicy: Always
    volumeMounts:
    - mountPath: /csi
      name: socket-dir
  - name: hostpath-driver
    args:
    - --v=5
    - --endpoint=$(CSI_ENDPOINT)
    - --nodeid=$(KUBE_NODE_NAME)
    env:
    - name: CSI_ENDPOINT
      value: unix:///csi/csi.sock
    - name: KUBE_NODE_NAME
      valueFrom:
        fieldRef:
          apiVersion: v1
          fieldPath: spec.nodeName
    image: quay.io/k8scsi/hostpathplugin:v0.2.0
    imagePullPolicy: Always
    securityContext:
      privileged: true
    volumeMounts:
    - mountPath: /csi
      name: socket-dir
    - mountPath: /var/lib/kubelet/pods
      mountPropagation: Bidirectional
      name: mountpoint-dir
  volumes:
  - hostPath:
      path: /var/lib/kubelet/plugins/csi-hostpath
      type: DirectoryOrCreate
    name: socket-dir
  - hostPath:
      path: /var/lib/kubelet/pods
      type: DirectoryOrCreate
    name: mountpoint-dir
</code></pre>
<a class="header" href="#usage-1" id="usage-1"><h2>Usage</h2></a>
<p>Dynamic provisioning was enabled by the .yaml file above via the
<code>csi-hostpath-sc</code> storage class. We can use this to create and claim a
new volume:</p>
<pre><code>$ kubectl create -f https://raw.githubusercontent.com/kubernetes-csi/docs/master/book/src/example/csi-pvc.yaml
persistentvolumeclaim &quot;csi-pvc&quot; created
$ kubectl get pvc
NAME      STATUS    VOLUME                                   CAPACITY   ACCESS MODES   STORAGECLASS      AGE
csi-pvc   Bound     kubernetes-dynamic-pv-bb3d8e2a23d611e8   1Gi        RWO            csi-hostpath-sc   5s
$ kubectl get pv
NAME                                     CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS    CLAIM             STORAGECLASS      REASON    AGE
kubernetes-dynamic-pv-bb3d8e2a23d611e8   1Gi        RWO            Delete           Bound     default/csi-pvc   csi-hostpath-sc             8s
</code></pre>
<pre><code class="language-yaml">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: csi-pvc
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
  storageClassName: csi-hostpath-sc # defined in csi-setup.yaml
</code></pre>
<p>The HostPath driver is configured to create new volumes under <code>/tmp</code>
inside the <code>csi-pod/hostpath-driver</code> and thus persist as long as the <code>csi-pod</code> itself.
We can use such volumes in another pod like this:</p>
<pre><code>$ kubectl create -f https://raw.githubusercontent.com/kubernetes-csi/docs/master/book/src/example/csi-app.yaml
pod &quot;my-csi-app&quot; created
$ kubectl get pods
NAME         READY     STATUS    RESTARTS   AGE
csi-pod      4/4       Running   0          3m
my-csi-app   1/1       Running   0          8s
$ kubectl describe pods/my-csi-app
Name:         my-csi-app
Namespace:    default
Node:         127.0.0.1/127.0.0.1
Start Time:   Fri, 09 Mar 2018 21:17:21 +0100
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;
Status:       Running
IP:           172.17.0.3
Containers:
  my-frontend:
    Container ID:  docker://52ea6c569abea710166059005416297a654b3216f7ce632516c50498fe130639
    Image:         busybox
    Image ID:      docker-pullable://busybox@sha256:2107a35b58593c58ec5f4e8f2c4a70d195321078aebfadfbfb223a2ff4a4ed21
    Port:          &lt;none&gt;
    Host Port:     &lt;none&gt;
    Command:
      sleep
      1000000
    State:          Running
      Started:      Fri, 09 Mar 2018 21:17:25 +0100
    Ready:          True
    Restart Count:  0
    Environment:    &lt;none&gt;
    Mounts:
      /data from my-csi-volume (rw)
      /var/run/secrets/kubernetes.io/serviceaccount from default-token-hw8rs (ro)
Conditions:
  Type           Status
  Initialized    True 
  Ready          True 
  PodScheduled   True 
Volumes:
  my-csi-volume:
    Type:       PersistentVolumeClaim (a reference to a PersistentVolumeClaim in the same namespace)
    ClaimName:  csi-pvc
    ReadOnly:   false
  default-token-hw8rs:
    Type:        Secret (a volume populated by a Secret)
    SecretName:  default-token-hw8rs
    Optional:    false
QoS Class:       BestEffort
Node-Selectors:  &lt;none&gt;
Tolerations:     node.kubernetes.io/not-ready:NoExecute for 300s
                 node.kubernetes.io/unreachable:NoExecute for 300s
Events:
  Type    Reason                  Age   From                     Message
  ----    ------                  ----  ----                     -------
  Normal  Scheduled               59s   default-scheduler        Successfully assigned my-csi-app to 127.0.0.1
  Normal  SuccessfulAttachVolume  59s   attachdetach-controller  AttachVolume.Attach succeeded for volume &quot;kubernetes-dynamic-pv-bb3d8e2a23d611e8&quot;
  Normal  SuccessfulMountVolume   59s   kubelet, 127.0.0.1       MountVolume.SetUp succeeded for volume &quot;default-token-hw8rs&quot;
  Normal  SuccessfulMountVolume   58s   kubelet, 127.0.0.1       MountVolume.SetUp succeeded for volume &quot;kubernetes-dynamic-pv-bb3d8e2a23d611e8&quot;
  Normal  Pulling                 58s   kubelet, 127.0.0.1       pulling image &quot;busybox&quot;
  Normal  Pulled                  55s   kubelet, 127.0.0.1       Successfully pulled image &quot;busybox&quot;
  Normal  Created                 55s   kubelet, 127.0.0.1       Created container
  Normal  Started                 55s   kubelet, 127.0.0.1       Started container

</code></pre>
<pre><code>kind: Pod
apiVersion: v1
metadata:
  name: my-csi-app
spec:
  containers:
    - name: my-frontend
      image: busybox
      volumeMounts:
      - mountPath: &quot;/data&quot;
        name: my-csi-volume
      command: [ &quot;sleep&quot;, &quot;1000000&quot; ]
  volumes:
    - name: my-csi-volume
      persistentVolumeClaim:
        claimName: csi-pvc # defined in csi-pvs.yaml
</code></pre>
<a class="header" href="#confirming-the-setup" id="confirming-the-setup"><h2>Confirming the setup</h2></a>
<p>Writing inside the app container should be visible in <code>/tmp</code> of the <code>hostpath-driver</code> container:</p>
<pre><code>$ kubectl exec -ti my-csi-app /bin/sh
/ # touch /data/hello-world
/ # exit
$ kubectl exec -ti csi-pod -c hostpath-driver /bin/sh
/ # find / -name hello-world
/tmp/aba238a3-21f9-11e8-9164-0242ac110002/hello-world
</code></pre>
<p>There should be a <code>VolumeAttachment</code> while the app has the volume mounted:</p>
<pre><code>$ kubectl get VolumeAttachment
NAME                                                                   AGE
csi-7bf49991faecc67f5049ed4b72e56b5935d92fb21b69fe782e74ea26e25863a3   7m
$ kubectl describe VolumeAttachment
Name:         csi-7bf49991faecc67f5049ed4b72e56b5935d92fb21b69fe782e74ea26e25863a3
Namespace:    
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;
API Version:  storage.k8s.io/v1beta1
Kind:         VolumeAttachment
Metadata:
  Creation Timestamp:  2018-03-09T20:17:21Z
  Resource Version:    597
  Self Link:           /apis/storage.k8s.io/v1beta1/volumeattachments/csi-7bf49991faecc67f5049ed4b72e56b5935d92fb21b69fe782e74ea26e25863a3
  UID:                 dfaffa08-23d6-11e8-bf78-fcaa1497a416
Spec:
  Attacher:   csi-hostpath
  Node Name:  127.0.0.1
  Source:
    Persistent Volume Name:  kubernetes-dynamic-pv-bb3d8e2a23d611e8
Status:
  Attached:  true
Events:      &lt;none&gt;
</code></pre>
<p>If you encounter any problems, please check the <a href="Troubleshooting.html">Troubleshooting page</a>.</p>
<a class="header" href="#development" id="development"><h1>Development</h1></a>
<p>This section describes to developers how to create and deploy a CSI driver for Kubernetes.</p>
<a class="header" href="#developing-a-csi-driver" id="developing-a-csi-driver"><h1>Developing a CSI driver</h1></a>
<p>To write a CSI Driver, a developer must create an application which implements the three <em>Identity</em>, <em>Controller</em>, and <em>Node</em> services as described in the <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md#rpc-interface">CSI specification</a>.</p>
<p>The <a href="Drivers.html">Drivers</a> page contains a set of drivers which may be used as an example of how to write a CSI driver.</p>
<p>If this is your first driver, you can start with the <a href="https://github.com/kubernetes-csi/csi-test/tree/master/mock/service">in-memory sample Mock Driver</a> used for <a href="https://github.com/kubernetes-csi/csi-test/tree/master/cmd/csi-sanity">csi-sanity</a></p>
<a class="header" href="#other-resources" id="other-resources"><h1>Other Resources</h1></a>
<p>Here are some other resources useful for writing CSI drivers:</p>
<ul>
<li><a href="https://arslan.io/2018/06/21/how-to-write-a-container-storage-interface-csi-plugin/">How to write a Container Storage Interface (CSI) plugin - by Fatih Arslan</a></li>
</ul>
<a class="header" href="#deploying-in-kubernetes" id="deploying-in-kubernetes"><h1>Deploying in Kubernetes</h1></a>
<p>This page describes to CSI driver developers how to deploy their driver onto a Kubernetes cluster.</p>
<a class="header" href="#overview" id="overview"><h2>Overview</h2></a>
<p>There are three components plus the kubelet that enable CSI drivers to provide storage to Kubernetes. These components are sidecar containers which are responsible for communication with both Kubernetes and the CSI driver, making the appropriate CSI calls for their respectful Kubernetes events.</p>
<a class="header" href="#sidecar-containers" id="sidecar-containers"><h2>Sidecar Containers</h2></a>
<p><a href="https://docs.google.com/a/greatdanedata.com/drawings/d/1JExJ_98dt0NAsJ7iI0_9loeTn2rbLeEcpOMEvKrF-9w/edit?usp=sharing"><img src="images/sidecar-container.png" alt="sidecar-container" /></a></p>
<p>Sidecar containers manage Kubernetes events and make the appropriate calls to the CSI driver. These are the <em>external attacher</em>, <em>external provisioner</em>, and the <em>driver registrar</em>.</p>
<a class="header" href="#external-attacher" id="external-attacher"><h3>External Attacher</h3></a>
<p><a href="https://github.com/kubernetes-csi/external-attacher">external-attacher</a> is a sidecar container that watches Kubernetes <em>VolumeAttachment</em> objects and triggers CSI <em>ControllerPublish</em> and <em>ControllerUnpublish</em> operations against a driver endpoint. As of this writing, the external attacher does not support leader election and therefore there can be only one running per CSI driver.  For more information please read <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md#attaching-and-detaching"><em>Attaching and Detaching</em></a>.</p>
<p>Note, even though this is called the <em>external attacher</em>, its function is to call the CSI API calls <em>ControllerPublish</em> and <em>ControllerUnpublish</em>. These calls most likely will occur in a node which is <em>not</em> the one that will mount the volume. For this reason, many CSI drivers do not support these calls, instead doing the attach/detach and mount/unmount both in the CSI <em>NodePublish</em> and <em>NodeUnpublish</em> calls done by the kubelet at the node which is supposed to mount.</p>
<a class="header" href="#external-provisioner" id="external-provisioner"><h3>External Provisioner</h3></a>
<p><a href="https://github.com/kubernetes-csi/external-provisioner">external-provisioner</a> is a Sidecar container that watches Kubernetes <em>PersistentVolumeClaim</em> objects and triggers CSI <em>CreateVolume</em> and <em>DeleteVolume</em> operations against a driver endpoint. For more information please read <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md#provisioning-and-deleting"><em>Provisioning and Deleting</em></a>.</p>
<a class="header" href="#driver-registrar" id="driver-registrar"><h3>Driver Registrar</h3></a>
<p><a href="https://github.com/kubernetes-csi/driver-registrar">driver-registrar</a> is a sidecar container that registers the CSI driver with kubelet, and adds the drivers custom NodeId to a label on the Kubernetes Node API Object. It does this by communicating with the <em>Identity</em> service on the CSI driver and also calling the CSI <em>GetNodeId</em> operation. The driver registrar must have the Kubernetes name for the node set through the environment variable <code>KUBE_NODE_NAME</code> as follows:</p>
<pre><code class="language-yaml">        - name: csi-driver-registrar
          imagePullPolicy: Always
          image: quay.io/k8scsi/driver-registrar:v0.2.0
          args:
            - &quot;--v=5&quot;
            - &quot;--csi-address=$(ADDRESS)&quot;
          env:
            - name: ADDRESS
              value: /csi/csi.sock
            - name: KUBE_NODE_NAME
              valueFrom:
                fieldRef:
                  fieldPath: spec.nodeName
          volumeMounts:
            - name: socket-dir
              mountPath: /csi
</code></pre>
<a class="header" href="#kubelet" id="kubelet"><h3>Kubelet</h3></a>
<p><a href="https://docs.google.com/a/greatdanedata.com/drawings/d/1NXaVNDh3mSDhog7Q3Y9eELyEF24F8Z-Kk0ujR3pyOes/edit?usp=sharing"><img src="images/kubelet.png" alt="kubelet" /></a></p>
<p>The Kubernetes kubelet runs on every node and is responsible for making the CSI calls <em>NodePublish</em> and <em>NodeUnpublish</em>. These calls mount and unmount the storage volume from the storage system, making it available to the Pod to consume. As shown in the <em>external-attacher</em>, most CSI drivers choose to implement both their attach/detach and mount/unmount calls in the <em>NodePublish</em> and <em>NodeUnpublish</em> calls. They do this because the kubelet makes the request on the node which is to consume the volume.</p>
<a class="header" href="#mount-point" id="mount-point"><h3>Mount point</h3></a>
<p>The mount point used by the CSI driver must be set to <em>Bidirectional</em>. See the example below:</p>
<pre><code class="language-yaml">          volumeMounts:
            - name: socket-dir
              mountPath: /csi
            - name: mountpoint-dir
              mountPath: /var/lib/kubelet/pods
              mountPropagation: &quot;Bidirectional&quot;
      volumes:
        - name: socket-dir
          hostPath:
            path: /var/lib/kubelet/plugins/csi-hostpath
            type: DirectoryOrCreate
        - name: mountpoint-dir
          hostPath:
            path: /var/lib/kubelet/pods
            type: Directory
</code></pre>
<a class="header" href="#rbac-rules" id="rbac-rules"><h3>RBAC Rules</h3></a>
<p>Side car containers need the appropriate permissions to be able to access and manipulate Kubernetes objects. Here are the RBAC rules needed:</p>
<pre><code class="language-yaml">kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: csi-hostpath-role
rules:
  - apiGroups: [&quot;&quot;]
    resources: [&quot;persistentvolumes&quot;]
    verbs: [&quot;create&quot;, &quot;delete&quot;, &quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;update&quot;]
  - apiGroups: [&quot;&quot;]
    resources: [&quot;persistentvolumeclaims&quot;]
    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;update&quot;]
  - apiGroups: [&quot;&quot;]
    resources: [&quot;nodes&quot;]
    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;update&quot;]
  - apiGroups: [&quot;storage.k8s.io&quot;]
    resources: [&quot;storageclasses&quot;]
    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]
  - apiGroups: [&quot;storage.k8s.io&quot;]
    resources: [&quot;volumeattachments&quot;]
    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;update&quot;]
</code></pre>
<a class="header" href="#deploying" id="deploying"><h2>Deploying</h2></a>
<p>Deploying a CSI driver onto Kubernetes is highlighted in detail in <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md#recommended-mechanism-for-deploying-csi-drivers-on-kubernetes"><em>Recommended Mechanism for Deploying CSI Drivers on Kubernetes</em></a>.</p>
<a class="header" href="#examples" id="examples"><h3>Examples</h3></a>
<ul>
<li>Simple deployment example using a single pod for all components: see the <a href="Example.html">hostpath example</a>.</li>
<li>Full deployment example using a <em>DaemonSet</em> for the node plugin and <em>StatefulSet</em> for the controller plugin: check the <a href="https://github.com/kubernetes-csi/drivers/tree/master/pkg/nfs/deploy/kubernetes">NFS driver deployment files</a>.</li>
</ul>
<a class="header" href="#more-information" id="more-information"><h2>More information</h2></a>
<p>For more information, please read <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md"><em>CSI Volume Plugins in Kubernetes Design Doc</em></a>.</p>
<a class="header" href="#testing-1" id="testing-1"><h1>Testing</h1></a>
<p>This document describes to developers how they can test their CSI clients or drivers.</p>
<a class="header" href="#testing-csi-clients" id="testing-csi-clients"><h1>Testing CSI Clients</h1></a>
<p>If you are writing a CSI client, like a CO or a side car container, then you can use some of the following methods to test your application.</p>
<ul>
<li><em>csi-test unit test mock driver</em>: The csi-test repo provides an automatically generated Golang mock code to be used for unit tests.</li>
<li><em>mock-driver</em>: This driver can be used as an external service to test your gRPC calls.</li>
<li><em>hostPath driver</em>: This driver can be used on a single node to tests for mounting and unmounting of storage.</li>
</ul>
<a class="header" href="#csi-test-unit-test-mock-driver" id="csi-test-unit-test-mock-driver"><h1>CSI-Test Unit Test Mock Driver</h1></a>
<p>The <a href="https://github.com/kubernetes-csi/csi-test">csi-test</a> unit test mock driver enables Golang clients to test all aspects of their code. This is done by using the mock driver generated using <a href="https://github.com/golang/mock">GoMock</a>, which let's the caller verify parameters and test for returned values. Here is a small example:</p>
<pre><code class="language-go">    // Setup mock
    m := gomock.NewController(&amp;mock_utils.SafeGoroutineTester{})
    defer m.Finish()
    driver := mock_driver.NewMockIdentityServer(m)

    // Setup input
    in := &amp;csi.GetPluginInfoRequest{
        Version: &amp;csi.Version{
            Major: 0,
            Minor: 1,
            Patch: 0,
        },
    }

    // Setup mock outout
    out := &amp;csi.GetPluginInfoResponse{
        Name:          &quot;mock&quot;,
        VendorVersion: &quot;0.1.1&quot;,
        Manifest: map[string]string{
            &quot;hello&quot;: &quot;world&quot;,
        },
    }

    // Setup expectation
    // !IMPORTANT!: Must set context expected value to gomock.Any() to match any value
    driver.EXPECT().GetPluginInfo(gomock.Any(), in).Return(out, nil).Times(1)

    // Create a new RPC
    server := mock_driver.NewMockCSIDriver(&amp;mock_driver.MockCSIDriverServers{
        Identity: driver,
    })
    conn, err := server.Nexus()
    if err != nil {
        t.Errorf(&quot;Error: %s&quot;, err.Error())
    }
    defer server.Close()

    // Make call
    c := csi.NewIdentityClient(conn)
    r, err := c.GetPluginInfo(context.Background(), in)
    if err != nil {
        t.Errorf(&quot;Error: %s&quot;, err.Error())
    }

    name := r.GetName()
    if name != &quot;mock&quot; {
        t.Errorf(&quot;Unknown name: %s\n&quot;, name)
    }
</code></pre>
<a class="header" href="#more-information-1" id="more-information-1"><h2>More Information</h2></a>
<p>For more examples and information see:</p>
<ul>
<li><a href="https://github.com/kubernetes-csi/external-attacher/blob/master/pkg/connection/connection_test.go">external-attacher side car container</a></li>
<li><a href="https://github.com/golang/mock">Golang GoMock</a></li>
</ul>
<a class="header" href="#hostpath-driver" id="hostpath-driver"><h1>HostPath Driver</h1></a>
<p>The <a href="https://github.com/kubernetes-csi/drivers/tree/master/pkg/hostpath">hostPath</a> driver is probably the simplest CSI driver to use for testing on a single node. This is the driver that is for CSI e2e tests in Kubernetes. See the <a href="Example.html">Example</a> page for deployment and usage instructions.</p>
<a class="header" href="#testing-csi-drivers" id="testing-csi-drivers"><h1>Testing CSI Drivers</h1></a>
<p>There are multiple ways to test your driver, some still in development. This page will describe each of the multiple methods to test your driver.</p>
<a class="header" href="#unit-testing" id="unit-testing"><h2>Unit Testing</h2></a>
<p>There are multiple ways to test your driver. One way is to exercise every call by writing your own client for your unit tests as done in the <a href="https://github.com/libopenstorage/openstorage/tree/master/csi">Portworx driver</a>.</p>
<p>Another way to test your driver is to use the <a href="https://github.com/kubernetes-csi/csi-test/tree/master/pkg/sanity"><code>sanity</code></a> package from <a href="https://github.com/kubernetes-csi/csi-test">csi-test</a>. This simple package contains a single call which will test your driver according to the CSI specification. Here is an example of how it can be used:</p>
<pre><code class="language-go">func TestMyDriver(t *testing.T) {
    // Setup the full driver and its environment
    ... setup driver ...

    // Now call the test suite
    sanity.Test(t, driverEndpointAddress)
}
</code></pre>
<a class="header" href="#functional-testing" id="functional-testing"><h2>Functional Testing</h2></a>
<p>For functional testing you can again provide your own model, or some of the following tools:</p>
<a class="header" href="#csi-sanity" id="csi-sanity"><h3>csi-sanity</h3></a>
<p><a href="https://github.com/kubernetes-csi/csi-test/tree/master/cmd/csi-sanity">csi-sanity</a> is a program from <a href="https://github.com/kubernetes-csi/csi-test">csi-test</a> which tests your driver based on the <a href="https://github.com/kubernetes-csi/csi-test/tree/master/pkg/sanity"><code>sanity</code></a> package.</p>
<p>Here is a sample way to use it:</p>
<pre><code>$ csi-sanity --ginkgo.v --csi.endpoint=&lt;your csi driver endpoint&gt;
</code></pre>
<p>For more information please see <a href="https://github.com/kubernetes-csi/csi-test/tree/master/cmd/csi-sanity">csi-sanity</a></p>
<a class="header" href="#troubleshooting" id="troubleshooting"><h1>Troubleshooting</h1></a>
<a class="header" href="#node-plugin-pod-does-not-start-with-runcontainererror-status" id="node-plugin-pod-does-not-start-with-runcontainererror-status"><h3>Node plugin pod does not start with <em>RunContainerError</em> status</h3></a>
<p><code>kubectl describe pod your-nodeplugin-pod</code> shows:</p>
<pre><code>failed to start container &quot;your-driver&quot;: Error response from daemon:
linux mounts: Path /var/lib/kubelet/pods is mounted on / but it is not a shared mount
</code></pre>
<p>Your Docker host is not configured to allow shared mounts. Take a look at <a href="https://docs.portworx.com/knowledgebase/shared-mount-propagation.html">this page</a> for instructions to enable them.</p>
<a class="header" href="#external-attacher-cant-find-volumeattachments" id="external-attacher-cant-find-volumeattachments"><h3>External attacher can't find <em>VolumeAttachments</em></h3></a>
<p>If you have a Kubernetes 1.9 cluster, not being able to list <em>VolumeAttachment</em>
and the following error are due to the lack of the
<code>storage.k8s.io/v1alpha1=true</code> runtime configuration:</p>
<pre><code>$ kubectl logs csi-pod external-attacher
...
I0306 16:34:50.976069       1 reflector.go:240] Listing and watching *v1alpha1.VolumeAttachment from github.com/kubernetes-csi/external-attacher/vendor/k8s.io/client-go/informers/factory.go:86

E0306 16:34:50.992034       1 reflector.go:205] github.com/kubernetes-csi/external-attacher/vendor/k8s.io/client-go/informers/factory.go:86: Failed to list *v1alpha1.VolumeAttachment: the server could not find the requested resource
...
</code></pre>
<p>Please see the <a href="Kubernetes-1.9.html">Kubernetes 1.9</a> page.</p>
<a class="header" href="#problems-with-the-external-components" id="problems-with-the-external-components"><h3>Problems with the external components</h3></a>
<p>The external components images are under active development. It can
happen that they become incompatible with each other. If the
issues above above have been ruled out, <a href="https://github.com/kubernetes/community/tree/master/sig-storage">contact the sig-storage
team</a> and/or
<a href="https://github.com/kubernetes/community/blob/master/contributors/devel/e2e-tests.md#local-clusters">run the e2e test</a>:</p>
<pre><code>go run hack/e2e.go -- --provider=local --test --test_args=&quot;--ginkgo.focus=Feature:CSI&quot;
</code></pre>
<a class="header" href="#references" id="references"><h1>References</h1></a>
<ul>
<li><a href="https://github.com/container-storage-interface/spec/blob/master/spec.md">CSI Specification</a></li>
<li><a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md">CSI Volume Plugins in Kubernetes Design Doc</a></li>
</ul>
<a class="header" href="#archive" id="archive"><h1>Archive</h1></a>
<p>In this section, you will find information about CSI support in older Kubernetes versions.</p>
<a class="header" href="#csi-with-kubernetes-19" id="csi-with-kubernetes-19"><h1>CSI with Kubernetes 1.9</h1></a>
<p>Since CSI support is alpha in Kubernetes 1.9, the following flags must be set explictly:</p>
<ul>
<li>API Server binary:</li>
</ul>
<pre><code>--allow-privileged=true
--feature-gates=CSIPersistentVolume=true,MountPropagation=true
--runtime-config=storage.k8s.io/v1alpha1=true
</code></pre>
<ul>
<li>Controller-manager binary</li>
</ul>
<pre><code>--feature-gates=CSIPersistentVolume=true
</code></pre>
<ul>
<li>Kubelet</li>
</ul>
<pre><code>--allow-privileged=true
--feature-gates=CSIPersistentVolume=true,MountPropagation=true
</code></pre>
<a class="header" href="#developers" id="developers"><h2>Developers</h2></a>
<p>If you are a developer and are using the script <code>cluster/kube-up.sh</code> from the Kubernetes repo, then you can set values using the following environment variables:</p>
<pre><code>export KUBE_RUNTIME_CONFIG=&quot;storage.k8s.io/v1alpha1=true&quot;
export KUBE_FEATURE_GATES=&quot;MountPropagation=true,CSIPersistentVolume=true&quot;
</code></pre>
<p>When using the script <code>hack/local-up-cluster.sh</code>, set the same variables without the <code>KUBE_</code> prefix:</p>
<pre><code>export RUNTIME_CONFIG=&quot;storage.k8s.io/v1alpha1=true&quot;
export FEATURE_GATES=&quot;MountPropagation=true,CSIPersistentVolume=true&quot;
</code></pre>
<a class="header" href="#confirming-the-setup-1" id="confirming-the-setup-1"><h2>Confirming the setup</h2></a>
<p>Once the system is up, to confirm if the runtime config has taken effect, the following command should return that there are no resources and not return an error:</p>
<pre><code class="language-bash">$ kubectl get volumeattachments
</code></pre>
<p>To confirm that the feature gate has taken effect, submit the following fake PersistentVolume specification. If it is accepted, then we can confirm that the feature gate has been set correctly, and you may go ahead and delete it:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: PersistentVolume
metadata:
    name: fakepv
spec:
    capacity:
        storage: 1Gi
    accessModes:
        - ReadWriteMany
    csi:
        driver: fake
        volumeHandle: &quot;1&quot;
        readOnly: false
</code></pre>
<a class="header" href="#csi-with-kubernetes-110" id="csi-with-kubernetes-110"><h1>CSI with Kubernetes 1.10</h1></a>
<p>TBD</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
