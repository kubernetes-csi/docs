<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Kubernetes CSI Developer Documentation</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="This site documents how to develop and deploy a Container Storage Interface (CSI) driver on Kubernetes.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><a href="developing.html"><strong aria-hidden="true">2.</strong> Developing a CSI Driver for Kubernetes</a></li><li><ol class="section"><li><a href="kubernetes-changelog.html"><strong aria-hidden="true">2.1.</strong> Kubernetes Changelog</a></li><li><a href="kubernetes-cluster-controllers.html"><strong aria-hidden="true">2.2.</strong> Kubernetes Cluster Controllers</a></li><li><ol class="section"><li><a href="snapshot-controller.html"><strong aria-hidden="true">2.2.1.</strong> Snapshot Controller</a></li></ol></li><li><a href="sidecar-containers.html"><strong aria-hidden="true">2.3.</strong> Sidecar Containers</a></li><li><ol class="section"><li><a href="kubernetes-compatibility.html"><strong aria-hidden="true">2.3.1.</strong> Kubernetes Compatibility</a></li><li><a href="external-attacher.html"><strong aria-hidden="true">2.3.2.</strong> external-attacher</a></li><li><a href="external-provisioner.html"><strong aria-hidden="true">2.3.3.</strong> external-provisioner</a></li><li><a href="external-resizer.html"><strong aria-hidden="true">2.3.4.</strong> external-resizer</a></li><li><a href="external-snapshotter.html"><strong aria-hidden="true">2.3.5.</strong> external-snapshotter</a></li><li><a href="livenessprobe.html"><strong aria-hidden="true">2.3.6.</strong> livenessprobe</a></li><li><a href="node-driver-registrar.html"><strong aria-hidden="true">2.3.7.</strong> node-driver-registrar</a></li><li><a href="cluster-driver-registrar.html"><strong aria-hidden="true">2.3.8.</strong> cluster-driver-registrar</a></li></ol></li><li><a href="csi-objects.html"><strong aria-hidden="true">2.4.</strong> CSI objects</a></li><li><ol class="section"><li><a href="csi-driver-object.html"><strong aria-hidden="true">2.4.1.</strong> CSIDriver Object</a></li><li><a href="csi-node-object.html"><strong aria-hidden="true">2.4.2.</strong> CSINode Object</a></li></ol></li><li><a href="features.html"><strong aria-hidden="true">2.5.</strong> Features</a></li><li><ol class="section"><li><a href="secrets-and-credentials.html"><strong aria-hidden="true">2.5.1.</strong> Secrets &amp; Credentials</a></li><li><ol class="section"><li><a href="secrets-and-credentials-storage-class.html"><strong aria-hidden="true">2.5.1.1.</strong> StorageClass Secrets</a></li><li><a href="secrets-and-credentials-volume-snapshot-class.html"><strong aria-hidden="true">2.5.1.2.</strong> VolumeSnapshotClass Secrets</a></li></ol></li><li><a href="topology.html"><strong aria-hidden="true">2.5.2.</strong> Topology</a></li><li><a href="raw-block.html"><strong aria-hidden="true">2.5.3.</strong> Raw Block Volume</a></li><li><a href="skip-attach.html"><strong aria-hidden="true">2.5.4.</strong> Skip Attach</a></li><li><a href="pod-info.html"><strong aria-hidden="true">2.5.5.</strong> Pod Info on Mount</a></li><li><a href="volume-expansion.html"><strong aria-hidden="true">2.5.6.</strong> Volume expansion</a></li><li><a href="volume-datasources.html"><strong aria-hidden="true">2.5.7.</strong> Data Sources</a></li><li><ol class="section"><li><a href="volume-cloning.html"><strong aria-hidden="true">2.5.7.1.</strong> Cloning</a></li><li><a href="snapshot-restore-feature.html"><strong aria-hidden="true">2.5.7.2.</strong> Volume Snapshot &amp; Restore</a></li></ol></li><li><a href="ephemeral-local-volumes.html"><strong aria-hidden="true">2.5.8.</strong> Ephemeral Local Volumes</a></li><li><a href="volume-limits.html"><strong aria-hidden="true">2.5.9.</strong> Volume Limits</a></li></ol></li></ol></li><li><a href="deploying.html"><strong aria-hidden="true">3.</strong> Deploying a CSI Driver on Kubernetes</a></li><li><ol class="section"><li><a href="example.html"><strong aria-hidden="true">3.1.</strong> Example</a></li></ol></li><li><a href="testing-drivers.html"><strong aria-hidden="true">4.</strong> Driver Testing</a></li><li><ol class="section"><li><a href="unit-testing.html"><strong aria-hidden="true">4.1.</strong> Unit Testing</a></li><li><a href="functional-testing.html"><strong aria-hidden="true">4.2.</strong> Functional Testing</a></li></ol></li><li><a href="drivers.html"><strong aria-hidden="true">5.</strong> Drivers</a></li><li><a href="troubleshooting.html"><strong aria-hidden="true">6.</strong> Troubleshooting</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Kubernetes CSI Developer Documentation</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<h2><a class="header" href="#kubernetes-container-storage-interface-csi-documentation" id="kubernetes-container-storage-interface-csi-documentation">Kubernetes Container Storage Interface (CSI) Documentation</a></h2>
<p>This site documents how to develop, deploy, and test a <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md">Container Storage Interface</a> (CSI) driver on Kubernetes.</p>
<p>The <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md">Container Storage Interface</a> (CSI) is a standard for exposing arbitrary block and file storage systems to containerized workloads on Container Orchestration Systems (COs) like Kubernetes. Using CSI third-party storage providers can write and deploy plugins exposing new storage systems in Kubernetes without ever having to touch the core Kubernetes code.</p>
<p>The target audience for this site is third-party developers interested in developing CSI drivers for Kubernetes.</p>
<p>Kubernetes users interested in how to deploy or manage an existing CSI driver on Kubernetes should look at the documentation provided by the author of the CSI driver.</p>
<p>Kubernetes users interested in how to use a CSI driver should look at <a href="https://kubernetes.io/docs/concepts/storage/volumes/#csi">kubernetes.io documentation</a>.</p>
<h2><a class="header" href="#kubernetes-releases" id="kubernetes-releases">Kubernetes Releases</a></h2>
<table><thead><tr><th>Kubernetes</th><th>CSI Spec Compatibility</th><th>Status</th></tr></thead><tbody>
<tr><td>v1.9</td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v0.1.0">v0.1.0</a></td><td>Alpha</td></tr>
<tr><td>v1.10</td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v0.2.0">v0.2.0</a></td><td>Beta</td></tr>
<tr><td>v1.11</td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a></td><td>Beta</td></tr>
<tr><td>v1.13</td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a>, <a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>GA</td></tr>
</tbody></table>
<h1><a class="header" href="#development-and-deployment" id="development-and-deployment">Development and Deployment</a></h1>
<h2><a class="header" href="#minimum-requirements-for-developing-and-deploying-a-csi-driver-for-kubernetes" id="minimum-requirements-for-developing-and-deploying-a-csi-driver-for-kubernetes">Minimum Requirements (for Developing and Deploying a CSI driver for Kubernetes)</a></h2>
<p>Kubernetes is as minimally prescriptive about packaging and deployment of a CSI Volume Driver as possible.</p>
<p>The only requirements are around how Kubernetes (master and node) components find and communicate with a CSI driver.</p>
<p>Specifically, the following is dictated by Kubernetes regarding CSI:</p>
<ul>
<li>Kubelet to CSI Driver Communication
<ul>
<li>Kubelet directly issues CSI calls (like <code>NodeStageVolume</code>, <code>NodePublishVolume</code>, etc.) to CSI drivers via a Unix Domain Socket to mount and unmount volumes.</li>
<li>Kubelet discovers CSI drivers (and the Unix Domain Socket to use to interact with a CSI driver) via the <a href="https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/#device-plugin-registration">kubelet plugin registration mechanism</a>.</li>
<li>Therefore, all CSI drivers deployed on Kubernetes MUST register themselves using the kubelet plugin registration mechanism on each supported node.</li>
</ul>
</li>
<li>Master to CSI Driver Communication
<ul>
<li>Kubernetes master components do not communicate directly (via a Unix Domain Socket or otherwise) with CSI drivers.</li>
<li>Kubernetes master components interact only with the Kubernetes API.</li>
<li>Therefore, CSI drivers that require operations that depend on the Kubernetes API (like volume create, volume attach, volume snapshot, etc.) MUST watch the Kubernetes API and trigger the appropriate CSI operations against it.</li>
</ul>
</li>
</ul>
<p>Because these requirements are minimally prescriptive, CSI driver developers are free to implement and deploy their drivers as they see fit.</p>
<p><em>That said, to ease development and deployment, the mechanism described below is recommended.</em></p>
<h2><a class="header" href="#recommended-mechanism-for-developing-and-deploying-a-csi-driver-for-kubernetes" id="recommended-mechanism-for-developing-and-deploying-a-csi-driver-for-kubernetes">Recommended Mechanism (for Developing and Deploying a CSI driver for Kubernetes)</a></h2>
<p>The Kubernetes development team has established a &quot;Recommended Mechanism&quot; for developing, deploying, and testing CSI Drivers on Kubernetes.
It aims to reduce boilerplate code and  simplify the overall process for CSI Driver developers.</p>
<p>This &quot;Recommended Mechanism&quot; makes use of the following components:</p>
<ul>
<li>Kubernetes CSI <a href="sidecar-containers.html">Sidecar Containers</a></li>
<li>Kubernetes CSI <a href="csi-objects.html">objects</a></li>
<li>CSI <a href="testing-drivers.html">Driver Testing</a> tools</li>
</ul>
<p>To implement a CSI driver using this mechanism, a CSI driver developer should:</p>
<ol>
<li>Create a containerized application implementing the <em>Identity</em>, <em>Node</em>, and optionally the <em>Controller</em> services described in the <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md#rpc-interface">CSI specification</a>  (the CSI driver container).
<ul>
<li>See <a href="developing.html">Developing CSI Driver</a> for more information.</li>
</ul>
</li>
<li>Unit test it using csi-sanity.
<ul>
<li>See <a href="unit-testing.html">Driver - Unit Testing</a> for more information.</li>
</ul>
</li>
<li>Define Kubernetes API YAML files that deploy the CSI driver container along with appropriate sidecar containers.
<ul>
<li>See <a href="deploying.html">Deploying in Kubernetes</a> for more information.</li>
</ul>
</li>
<li>Deploy the driver on a Kubernetes cluster and run end-to-end functional tests on it.
<ul>
<li>See <a href="functional-testing.html">Driver - Functional Testing</a></li>
</ul>
</li>
</ol>
<h2><a class="header" href="#reference-links" id="reference-links">Reference Links</a></h2>
<ul>
<li><a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md">Design Doc</a></li>
</ul>
<h1><a class="header" href="#developing-csi-driver-for-kubernetes" id="developing-csi-driver-for-kubernetes">Developing CSI Driver for Kubernetes</a></h1>
<p>The first step to creating a CSI driver is writing an application implementing the <a href="https://grpc.io/docs/">gRPC</a> services described in the <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md#rpc-interface">CSI specification</a></p>
<p>At a minimum, CSI drivers must implement the following CSI services:</p>
<ul>
<li>CSI <code>Identity</code> service
<ul>
<li>Enables callers (Kubernetes components and CSI sidecar containers) to identify the driver and what optional functionality it supports.</li>
</ul>
</li>
<li>CSI <code>Node</code> service
<ul>
<li>Only <code>NodePublishVolume</code>, <code>NodeUnpublishVolume</code>, and <code>NodeGetCapabilities</code> are required.</li>
<li>Required methods enable callers to make a volume available at a specified path and discover what optional  functionality the driver supports.</li>
</ul>
</li>
</ul>
<p>All CSI services may be implemented in the same CSI driver application. The CSI driver application should be containerized to make it easy to deploy on Kubernetes. Once containerized, the CSI driver can be paired with CSI <a href="sidecar-containers.html">Sidecar Containers</a> and deployed in node and/or controller mode as appropriate.</p>
<h2><a class="header" href="#capabilities" id="capabilities">Capabilities</a></h2>
<p>If your driver supports additional features, CSI &quot;capabilities&quot; can be used to advertise the optional methods/services it supports, for example:</p>
<ul>
<li><code>CONTROLLER_SERVICE</code> (<code>PluginCapability</code>)
<ul>
<li>The entire CSI <code>Controller</code> service is optional. This capability indicates the driver implement one or more of the methods in the CSI <code>Controller</code> service.</li>
</ul>
</li>
<li><code>VOLUME_ACCESSIBILITY_CONSTRAINTS</code> (<code>PluginCapability</code>)
<ul>
<li>This capability indicates the volumes for this driver may not be equally accessible from all nodes in the cluster, and that the driver will return additional topology related information that Kubernetes can use to schedule workloads more intelligently or influence where a volume will be provisioned.</li>
</ul>
</li>
<li><code>VolumeExpansion</code> (<code>PluginCapability</code>)
<ul>
<li>This capability indicates the driver supports resizing (expanding) volumes after creation.</li>
</ul>
</li>
<li><code>CREATE_DELETE_VOLUME</code> (<code>ControllerServiceCapability</code>)
<ul>
<li>This capability indicates the driver supports dynamic volume provisioning and deleting.</li>
</ul>
</li>
<li><code>PUBLISH_UNPUBLISH_VOLUME</code> (<code>ControllerServiceCapability</code>)
<ul>
<li>This capability indicates the driver implements <code>ControllerPublishVolume</code> and <code>ControllerUnpublishVolume</code> -- operations that correspond to the Kubernetes volume attach/detach operations. This may, for example, result in a &quot;volume attach&quot; operation against the Google Cloud control plane to attach the specified volume to the specified node for the Google Cloud PD CSI Driver.</li>
</ul>
</li>
<li><code>CREATE_DELETE_SNAPSHOT</code> (<code>ControllerServiceCapability</code>)
<ul>
<li>This capability indicates the driver supports provisioning volume snapshots and the ability to provision new volumes using those snapshots.</li>
</ul>
</li>
<li><code>CLONE_VOLUME</code> (<code>ControllerServiceCapability</code>)
<ul>
<li>This capability indicates the driver supports cloning of volumes.</li>
</ul>
</li>
<li><code>STAGE_UNSTAGE_VOLUME</code> (<code>NodeServiceCapability</code>)
<ul>
<li>This capability indicates the driver implements <code>NodeStageVolume</code> and <code>NodeUnstageVolume</code> -- operations that correspond to the Kubernetes volume device mount/unmount operations. This may, for example, be used to create a global (per node) volume mount of a block storage device.</li>
</ul>
</li>
</ul>
<p>This is an partial list, please see the <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md">CSI spec</a> for a complete list of capabilities.
Also see the <a href="features.html">Features</a> section to understand how a feature integrates with Kubernetes.</p>
<h1><a class="header" href="#kubernetes-changelog" id="kubernetes-changelog">Kubernetes Changelog</a></h1>
<p>This page summarizes major CSI changes made in each Kubernetes release. For
details on individual features, visit the <a href="features.html">Features section</a>.</p>
<h2><a class="header" href="#kubernetes-118" id="kubernetes-118">Kubernetes 1.18</a></h2>
<h3><a class="header" href="#deprecations" id="deprecations">Deprecations</a></h3>
<ul>
<li><code>storage.k8s.io/v1beta1</code> <code>CSIDriver</code> object has been deprecated and will be
removed in a future release.</li>
<li>In a future release, kubelet will no longer create the CSI NodePublishVolume
target directory, in accordance with the CSI specification. CSI drivers may
need to be updated accordingly to properly create and process the target path.</li>
</ul>
<h3><a class="header" href="#features" id="features">Features</a></h3>
<ul>
<li>GA
<ul>
<li>Raw block volumes</li>
<li>Volume cloning</li>
<li>Skip attach</li>
<li>Pod info on mount</li>
</ul>
</li>
<li>Beta
<ul>
<li>CSI migration for Openstack cinder driver.</li>
</ul>
</li>
<li>Alpha
<ul>
<li>CSI on Windows</li>
</ul>
</li>
<li><code>storage.k8s.io/v1</code> <code>CSIDriver</code> object introduced.</li>
</ul>
<h2><a class="header" href="#kubernetes-117" id="kubernetes-117">Kubernetes 1.17</a></h2>
<h3><a class="header" href="#breaking-changes" id="breaking-changes">Breaking Changes</a></h3>
<ul>
<li>CSI 0.3 support has been removed. CSI 0.3 drivers will no longer function.</li>
</ul>
<h3><a class="header" href="#deprecations-1" id="deprecations-1">Deprecations</a></h3>
<ul>
<li><code>storage.k8s.io/v1beta1</code> <code>CSINode</code> object has been deprecated and will be
removed in a future release.</li>
</ul>
<h3><a class="header" href="#features-1" id="features-1">Features</a></h3>
<ul>
<li>GA
<ul>
<li>Volume topology</li>
<li>Volume limits</li>
</ul>
</li>
<li>Beta
<ul>
<li>Volume snapshots and restore</li>
<li>CSI migration for AWS EBS and GCE PD drivers</li>
</ul>
</li>
<li><code>storage.k8s.io/v1</code> <code>CSINode</code> object introduced.</li>
</ul>
<h2><a class="header" href="#kubernetes-116" id="kubernetes-116">Kubernetes 1.16</a></h2>
<h3><a class="header" href="#features-2" id="features-2">Features</a></h3>
<ul>
<li>Beta
<ul>
<li>Volume cloning</li>
<li>Volume expansion</li>
<li>Ephemeral local volumes</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#kubernetes-115" id="kubernetes-115">Kubernetes 1.15</a></h2>
<h3><a class="header" href="#features-3" id="features-3">Features</a></h3>
<ul>
<li>Volume capacity usage metrics</li>
<li>Alpha
<ul>
<li>Volume cloning</li>
<li>Ephemeral local volumes</li>
<li>Resizing secrets</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#kubernetes-114" id="kubernetes-114">Kubernetes 1.14</a></h2>
<h3><a class="header" href="#breaking-changes-1" id="breaking-changes-1">Breaking Changes</a></h3>
<ul>
<li><code>csi.storage.k8s.io/v1alpha1</code> <code>CSINodeInfo</code> and <code>CSIDriver</code> CRDs are no longer supported.</li>
</ul>
<h3><a class="header" href="#features-4" id="features-4">Features</a></h3>
<ul>
<li>Beta
<ul>
<li>Topology</li>
<li>Raw block</li>
<li>Skip attach</li>
<li>Pod info on mount</li>
</ul>
</li>
<li>Alpha
<ul>
<li>Volume expansion</li>
</ul>
</li>
<li><code>storage.k8s.io/v1beta1</code> <code>CSINode</code> and <code>CSIDriver</code> objects introduced.</li>
</ul>
<h2><a class="header" href="#kubernetes-113" id="kubernetes-113">Kubernetes 1.13</a></h2>
<h3><a class="header" href="#deprecations-2" id="deprecations-2">Deprecations</a></h3>
<ul>
<li>CSI spec 0.2 and 0.3 are deprecated and support will be removed in Kubernetes 1.17.</li>
</ul>
<h3><a class="header" href="#features-5" id="features-5">Features</a></h3>
<ul>
<li>GA support added for <a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">CSI spec
1.0</a>.</li>
</ul>
<h2><a class="header" href="#kubernetes-112" id="kubernetes-112">Kubernetes 1.12</a></h2>
<h3><a class="header" href="#breaking-changes-2" id="breaking-changes-2">Breaking Changes</a></h3>
<p>Kubelet device plugin registration is enabled by default, which requires CSI
plugins to use <code>driver-registrar:v0.3.0</code> to register with kubelet.</p>
<h3><a class="header" href="#features-6" id="features-6">Features</a></h3>
<ul>
<li>Alpha
<ul>
<li>Snapshots</li>
<li>Topology</li>
<li>Skip attach</li>
<li>Pod info on mount</li>
</ul>
</li>
<li><code>csi.storage.k8s.io/v1alpha1</code> <code>CSINodeInfo</code> and <code>CSIDriver</code> CRDs were
introduced and have to be installed before deploying a CSI driver.</li>
</ul>
<h2><a class="header" href="#kubernetes-111" id="kubernetes-111">Kubernetes 1.11</a></h2>
<h3><a class="header" href="#features-7" id="features-7">Features</a></h3>
<ul>
<li>Beta support added for <a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">CSI spec
0.3</a>.</li>
<li>Alpha
<ul>
<li>Raw block</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#kubernetes-110" id="kubernetes-110">Kubernetes 1.10</a></h2>
<h3><a class="header" href="#breaking-changes-3" id="breaking-changes-3">Breaking Changes</a></h3>
<ul>
<li>CSI spec 0.1 is no longer supported.</li>
</ul>
<h3><a class="header" href="#features-8" id="features-8">Features</a></h3>
<ul>
<li>Beta support added for <a href="https://github.com/container-storage-interface/spec/releases/tag/v0.2.0">CSI spec 0.2</a>.
This added optional <code>NodeStageVolume</code> and <code>NodeUnstageVolume</code> calls which
map to Kubernetes <code>MountDevice</code> and <code>UnmountDevice</code> operations.</li>
</ul>
<h2><a class="header" href="#kubernetes-19" id="kubernetes-19">Kubernetes 1.9</a></h2>
<h3><a class="header" href="#features-9" id="features-9">Features</a></h3>
<ul>
<li>Alpha support added for <a href="https://github.com/container-storage-interface/spec/releases/tag/v0.1.0">CSI spec
0.1</a>.</li>
</ul>
<h1><a class="header" href="#kubernetes-cluster-controllers" id="kubernetes-cluster-controllers">Kubernetes Cluster Controllers</a></h1>
<p>The Kubernetes cluster controllers are responsible for managing snapshot objects and operations across multiple CSI drivers, so they should be bundled and deployed by the Kubernetes distributors as part of their Kubernetes cluster management process (independent of any CSI Driver).</p>
<p>The Kubernetes development team maintains the following Kubernetes cluster controllers:</p>
<ul>
<li><a href="snapshot-controller.html">snapshot-controller</a></li>
</ul>
<h1><a class="header" href="#snapshot-controller" id="snapshot-controller">Snapshot Controller</a></h1>
<h2><a class="header" href="#status-and-releases" id="status-and-releases">Status and Releases</a></h2>
<p><strong>Git Repository:</strong> <a href="https://github.com/kubernetes-csi/external-snapshotter">https://github.com/kubernetes-csi/external-snapshotter</a></p>
<p><strong>Status:</strong> v2.0.0 and higher is Beta</p>
<h3><a class="header" href="#snapshot-controller-1" id="snapshot-controller-1">Snapshot Controller</a></h3>
<p>When Volume Snapshot is promoted to Beta in Kubernetes 1.17, the CSI external-snapshotter sidecar controller is split into two controllers: a snapshot-controller and a CSI external-snapshotter sidecar. See the following table for snapshot-controller release information.</p>
<table><thead><tr><th>Latest stable release</th><th>Branch</th><th>Min CSI Version</th><th>Max CSI Version</th><th>Container Image</th><th>Min K8s Version</th><th>Max K8s Version</th><th>Recommended K8s Version</th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/external-snapshotter/releases/tag/v2.0.1">external-snapshotter v2.0.1</a></td><td><a href="https://github.com/kubernetes-csi/external-snapshotter/tree/release-2.0">release-2.0</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>quay.io/k8scsi/snapshot-controller:v2.0.1</td><td>v1.17</td><td>-</td><td>v1.17</td></tr>
</tbody></table>
<p>For more information on the beta version of the CSI external-snapshotter sidecar, see <a href="external-snapshotter.html">this external-snapshotter page</a>.</p>
<h2><a class="header" href="#description" id="description">Description</a></h2>
<p>In the Beta version, the snapshot controller will be watching the Kubernetes API server for <code>VolumeSnapshot</code> and <code>VolumeSnapshotContent</code> CRD objects. The CSI <code>external-snapshotter</code> sidecar only watches the Kubernetes API server for <code>VolumeSnapshotContent</code> CRD objects. The snapshot controller will be creating the <code>VolumeSnapshotContent</code> CRD object which triggers the CSI <code>external-snapshotter</code> sidecar to create a snapshot on the storage system.</p>
<p>For detailed snapshot beta design changes, see the design doc <a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-storage/20190709-csi-snapshot.md">here</a>.</p>
<p>For detailed information about volume snapshot and restore functionality, see <a href="snapshot-restore-feature.html">Volume Snapshot &amp; Restore</a>.</p>
<p>For detailed information (binary parameters, RBAC rules, etc.), see <a href="https://github.com/kubernetes-csi/external-snapshotter/blob/release-2.0/README.md">https://github.com/kubernetes-csi/external-snapshotter/blob/release-2.0/README.md</a>.</p>
<h2><a class="header" href="#deployment" id="deployment">Deployment</a></h2>
<p>Kubernetes distributors should bundle and deploy the controller and CRDs as part of their Kubernetes cluster management process (independent of any CSI Driver).</p>
<p>If your cluster does not come pre-installed with the correct components, you may manually install these components by executing the following steps.</p>
<p>Install Snapshot Beta CRDs per cluster:</p>
<pre><code>kubectl create -f  https://raw.githubusercontent.com/kubernetes-csi/external-snapshotter/release-2.0/config/crd/snapshot.storage.k8s.io_volumesnapshotclasses.yaml

kubectl create -f  https://raw.githubusercontent.com/kubernetes-csi/external-snapshotter/release-2.0/config/crd/snapshot.storage.k8s.io_volumesnapshotcontents.yaml

kubectl create -f  https://raw.githubusercontent.com/kubernetes-csi/external-snapshotter/release-2.0/config/crd/snapshot.storage.k8s.io_volumesnapshots.yaml
</code></pre>
<p>Install Snapshot Controller per cluster:</p>
<pre><code>kubectl apply -f https://raw.githubusercontent.com/kubernetes-csi/external-snapshotter/release-2.0/deploy/kubernetes/snapshot-controller/rbac-snapshot-controller.yaml

kubectl apply -f https://raw.githubusercontent.com/kubernetes-csi/external-snapshotter/release-2.0/deploy/kubernetes/snapshot-controller/setup-snapshot-controller.yaml
</code></pre>
<h1><a class="header" href="#kubernetes-csi-sidecar-containers" id="kubernetes-csi-sidecar-containers">Kubernetes CSI Sidecar Containers</a></h1>
<p>Kubernetes CSI Sidecar Containers are a set of standard containers that aim to simplify the development and deployment of CSI Drivers on Kubernetes.</p>
<p>These containers contain common logic to watch the Kubernetes API, trigger appropriate operations against the “CSI volume driver” container, and update the Kubernetes API as appropriate.</p>
<p>The containers are intended to be bundled with third-party CSI driver containers and deployed together as pods.</p>
<p>The containers are developed and maintained by the Kubernetes Storage community.</p>
<p>Use of the containers is strictly optional, but highly recommended.</p>
<p>Benefits of these sidecar containers include:</p>
<ul>
<li>Reduction of &quot;boilerplate&quot; code.
<ul>
<li>CSI Driver developers do not have to worry about complicated, &quot;Kubernetes specific&quot; code.</li>
</ul>
</li>
<li>Separation of concerns.
<ul>
<li>Code that interacts with the Kubernetes API is isolated from (and in a different container then) the code that implements the CSI interface.</li>
</ul>
</li>
</ul>
<p>The Kubernetes development team maintains the following Kubernetes CSI Sidecar Containers:</p>
<ul>
<li><a href="external-provisioner.html">external-provisioner</a></li>
<li><a href="external-attacher.html">external-attacher</a></li>
<li><a href="external-snapshotter.html">external-snapshotter</a></li>
<li><a href="external-resizer.html">external-resizer</a></li>
<li><a href="node-driver-registrar.html">node-driver-registrar</a></li>
<li><a href="cluster-driver-registrar.html">cluster-driver-registrar</a> (deprecated)</li>
<li><a href="livenessprobe.html">livenessprobe</a></li>
</ul>
<h1><a class="header" href="#kubernetes-and-csi-sidecar-compatibility" id="kubernetes-and-csi-sidecar-compatibility">Kubernetes and CSI Sidecar Compatibility</a></h1>
<p>Every version of a sidecar has a minimum, maximum and recommended Kubernetes version
that it is compatible with.</p>
<h3><a class="header" href="#minimum-version" id="minimum-version">Minimum Version</a></h3>
<p>Minimum version specifies the lowest Kubernetes version where the sidecar will
function with the most basic functionality, and no additional features added later.
Generally, this aligns with the Kubernetes version where that CSI spec version was added.</p>
<h3><a class="header" href="#maximum-version" id="maximum-version">Maximum Version</a></h3>
<p>Similarly, the max Kubernetes version generally aligns with when support for
that CSI spec version was removed or if a particular Kubernetes API or feature
was deprecated and removed.</p>
<h3><a class="header" href="#recommended-version" id="recommended-version">Recommended Version</a></h3>
<p>It is important to note that any new features added to the sidecars may have
dependencies on Kubernetes versions greater than the minimum Kubernetes version.
The recommended Kubernetes version specifies the lowest Kubernetes version
needed where all features of a sidecar will function correctly. Trying to use a
new sidecar feature on a Kubernetes cluster below the recommended Kubernetes
version may fail to function correctly. For that reason, it is encouraged to
stay as close to the recommended Kubernetes version as possible.</p>
<p>For more details on which features are supported with which Kubernetes versions
and their corresponding sidecars, please see each feature's individual page.</p>
<h3><a class="header" href="#alpha-features" id="alpha-features">Alpha Features</a></h3>
<p>It is also important to note that alpha features are subject to break or be
removed across Kubernetes and sidecar releases. There is no guarantee alpha
features will continue to function if upgrading the Kubernetes cluster or
upgrading a sidecar.</p>
<h1><a class="header" href="#csi-external-attacher" id="csi-external-attacher">CSI external-attacher</a></h1>
<h2><a class="header" href="#status-and-releases-1" id="status-and-releases-1">Status and Releases</a></h2>
<p><strong>Git Repository:</strong> <a href="https://github.com/kubernetes-csi/external-attacher">https://github.com/kubernetes-csi/external-attacher</a></p>
<p><strong>Status:</strong> GA/Stable</p>
<table><thead><tr><th>Latest stable release</th><th>Branch</th><th>Min CSI Version</th><th>Max CSI Version</th><th>Container Image</th><th><a href="kubernetes-compatibility.html#minimum-version">Min K8s Version</a></th><th><a href="kubernetes-compatibility.html#maximum-version">Max K8s Version</a></th><th><a href="kubernetes-compatibility.html#recommended-version">Recommended K8s Version</a></th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/external-attacher/releases/tag/v2.2.0">external-attacher v2.2.0</a></td><td><a href="https://github.com/kubernetes-csi/external-attacher/tree/release-2.2">release-2.2</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>quay.io/k8scsi/csi-attacher:v2.2.0</td><td>v1.14</td><td>-</td><td>v1.17</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-attacher/releases/tag/v2.0.0">external-attacher v2.0.0</a></td><td><a href="https://github.com/kubernetes-csi/external-attacher/tree/release-2.0">release-2.0</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>quay.io/k8scsi/csi-attacher:v2.0.0</td><td>v1.14</td><td>-</td><td>v1.15</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-attacher/releases/tag/v1.2.1">external-attacher v1.2.1</a></td><td><a href="https://github.com/kubernetes-csi/external-attacher/tree/release-1.2">release-1.2</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>quay.io/k8scsi/csi-attacher:v1.2.1</td><td>v1.13</td><td>-</td><td>v1.15</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-attacher/releases/tag/v1.1.1">external-attacher v1.1.1</a></td><td><a href="https://github.com/kubernetes-csi/external-attacher/tree/release-1.1">release-1.1</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>quay.io/k8scsi/csi-attacher:v1.1.1</td><td>v1.13</td><td>-</td><td>v1.14</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-attacher/releases/tag/v0.4.2">external-attacher v0.4.2</a></td><td><a href="https://github.com/kubernetes-csi/external-attacher/tree/release-0.4">release-0.4</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a></td><td>quay.io/k8scsi/csi-attacher:v0.4.2</td><td>v1.10</td><td>v1.16</td><td>v1.10</td></tr>
</tbody></table>
<h2><a class="header" href="#description-1" id="description-1">Description</a></h2>
<p>The CSI <code>external-attacher</code> is a sidecar container that watches the Kubernetes API server for <code>VolumeAttachment</code> objects and triggers <code>Controller[Publish|Unpublish]Volume</code> operations against a CSI endpoint.</p>
<h2><a class="header" href="#usage" id="usage">Usage</a></h2>
<p>CSI drivers that require integrating with the Kubernetes volume attach/detach hooks should use this sidecar container, and advertise the CSI <code>PUBLISH_UNPUBLISH_VOLUME</code> controller capability.</p>
<p>For detailed information (binary parameters, RBAC rules, etc.), see <a href="https://github.com/kubernetes-csi/external-attacher/blob/master/README.md">https://github.com/kubernetes-csi/external-attacher/blob/master/README.md</a>.</p>
<h2><a class="header" href="#deployment-1" id="deployment-1">Deployment</a></h2>
<p>The CSI <code>external-attacher</code> is deployed as a controller. See <a href="deploying.html">deployment section</a> for more details.</p>
<h1><a class="header" href="#csi-external-provisioner" id="csi-external-provisioner">CSI external-provisioner</a></h1>
<h2><a class="header" href="#status-and-releases-2" id="status-and-releases-2">Status and Releases</a></h2>
<p><strong>Git Repository:</strong> <a href="https://github.com/kubernetes-csi/external-provisioner">https://github.com/kubernetes-csi/external-provisioner</a></p>
<p><strong>Status:</strong> GA/Stable</p>
<table><thead><tr><th>Latest stable release</th><th>Branch</th><th>Min CSI Version</th><th>Max CSI Version</th><th>Container Image</th><th><a href="kubernetes-compatibility.html#minimum-version">Min K8s Version</a></th><th><a href="kubernetes-compatibility.html#maximum-version">Max K8s Version</a></th><th><a href="kubernetes-compatibility.html#recommended-version">Recommended K8s Version</a></th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/external-provisioner/releases/tag/v1.6.0">external-provisioner v1.6.0</a></td><td><a href="https://github.com/kubernetes-csi/external-provisioner/tree/release-1.6">release-1.6</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>quay.io/k8scsi/csi-provisioner:v1.6.0</td><td>v1.13</td><td>-</td><td>v1.18</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-provisioner/releases/tag/v1.5.0">external-provisioner v1.5.0</a></td><td><a href="https://github.com/kubernetes-csi/external-provisioner/tree/release-1.5">release-1.5</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>quay.io/k8scsi/csi-provisioner:v1.5.0</td><td>v1.13</td><td>-</td><td>v1.17</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-provisioner/releases/tag/v1.4.0">external-provisioner v1.4.0</a></td><td><a href="https://github.com/kubernetes-csi/external-provisioner/tree/release-1.4">release-1.4</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>quay.io/k8scsi/csi-provisioner:v1.4.0</td><td>v1.13</td><td>-</td><td>v1.16</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-provisioner/releases/tag/v1.3.1">external-provisioner v1.3.1</a></td><td><a href="https://github.com/kubernetes-csi/external-provisioner/tree/release-1.3">release-1.3</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>quay.io/k8scsi/csi-provisioner:v1.3.1</td><td>v1.13</td><td>v1.19</td><td>v1.15</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-provisioner/releases/tag/v1.2.2">external-provisioner v1.2.0</a></td><td><a href="https://github.com/kubernetes-csi/external-provisioner/tree/release-1.2">release-1.2</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>quay.io/k8scsi/csi-provisioner:v1.2.0</td><td>v1.13</td><td>v1.19</td><td>v1.14</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-provisioner/releases/tag/v0.4.2">external-provisioner v0.4.2</a></td><td><a href="https://github.com/kubernetes-csi/external-provisioner/tree/release-0.4">release-0.4</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a></td><td>quay.io/k8scsi/csi-provisioner:v0.4.2</td><td>v1.10</td><td>v1.16</td><td>v1.10</td></tr>
</tbody></table>
<h2><a class="header" href="#description-2" id="description-2">Description</a></h2>
<p>The CSI <code>external-provisioner</code> is a sidecar container that watches the Kubernetes API server for <code>PersistentVolumeClaim</code> objects.</p>
<p>It calls <code>CreateVolume</code> against the specified CSI endpoint to provision a new volume.</p>
<p>Volume provisioning is triggered by the creation of a new Kubernetes <code>PersistentVolumeClaim</code> object, if the PVC references a Kubernetes <code>StorageClass</code>, and the name in the <code>provisioner</code> field of the storage class matches the name returned by the specified CSI endpoint in the <code>GetPluginInfo</code> call.</p>
<p>Once a new volume is successfully provisioned, the sidecar container creates a Kubernetes <code>PersistentVolume</code> object to represent the volume.</p>
<p>The deletion of a <code>PersistentVolumeClaim</code> object bound to a <code>PersistentVolume</code> corresponding to this driver with a <code>delete</code> reclaim policy causes the sidecar container to trigger a <code>DeleteVolume</code> operation against the specified CSI endpoint to delete the volume. Once the volume is successfully deleted, the sidecar container also deletes the <code>PersistentVolume</code> object representing the volume.</p>
<h3><a class="header" href="#datasources" id="datasources">DataSources</a></h3>
<p>The external-provisioner provides the ability to request a volume be pre-populated from a data source during provisioning.
For more information on how data sources are handled see <a href="volume-datasources.html">DataSources</a>.</p>
<h4><a class="header" href="#snapshot" id="snapshot">Snapshot</a></h4>
<p>The CSI <code>external-provisioner</code> supports the <code>Snapshot</code> DataSource. If a <code>Snapshot</code> CRD is specified as a data source on a PVC object, the sidecar container fetches the information about the snapshot by fetching the <code>SnapshotContent</code> object and populates the data source field in the resulting <code>CreateVolume</code> call to indicate to the storage system that the new volume should be populated using the specified snapshot.</p>
<h4><a class="header" href="#persistentvolumeclaim-clone" id="persistentvolumeclaim-clone">PersistentVolumeClaim (clone)</a></h4>
<p>Cloning is also implemented by specifying a <code>kind:</code> of type <code>PersistentVolumeClaim</code> in the DataSource field of a Provision request.  It's the responsbility of the external-provisioner to verify that the claim specified in the DataSource object exists, is in the same storage class as the volume being provisioned and that the claim is currently <code>Bound</code>.</p>
<h3><a class="header" href="#storageclass-parameters" id="storageclass-parameters">StorageClass Parameters</a></h3>
<p>When provisioning a new volume, the CSI <code>external-provisioner</code> sets the <code>map&lt;string, string&gt; parameters</code> field in the CSI <code>CreateVolumeRequest</code> call to the key/values specified in the <code>StorageClass</code> it is handling.</p>
<p>The CSI <code>external-provisioner</code> (v1.0.1+) also reserves the parameter keys prefixed with <code>csi.storage.k8s.io/</code>. Any keys prefixed with <code>csi.storage.k8s.io/</code> are not passed to the CSI driver as an opaque <code>parameter</code>.</p>
<p>The following reserved <code>StorageClass</code> parameter keys trigger behavior in the CSI <code>external-provisioner</code>:</p>
<ul>
<li><code>csi.storage.k8s.io/provisioner-secret-name</code></li>
<li><code>csi.storage.k8s.io/provisioner-secret-namespace</code></li>
<li><code>csi.storage.k8s.io/controller-publish-secret-name</code></li>
<li><code>csi.storage.k8s.io/controller-publish-secret-namespace</code></li>
<li><code>csi.storage.k8s.io/node-stage-secret-name</code></li>
<li><code>csi.storage.k8s.io/node-stage-secret-namespace</code></li>
<li><code>csi.storage.k8s.io/node-publish-secret-name</code></li>
<li><code>csi.storage.k8s.io/node-publish-secret-namespace</code></li>
<li><code>csi.storage.k8s.io/fstype</code></li>
</ul>
<p>If the PVC <code>VolumeMode</code> is set to <code>Filesystem</code>, and the value of <code>csi.storage.k8s.io/fstype</code> is specified, it is used to populate the <code>FsType</code> in <code>CreateVolumeRequest.VolumeCapabilities[x].AccessType</code> and the <code>AccessType</code> is set to <code>Mount</code>.</p>
<p>For more information on how secrets are handled see <a href="secrets-and-credentials.html">Secrets &amp; Credentials</a>.</p>
<p>Example <code>StorageClass</code>:</p>
<pre><code>apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: gold-example-storage
provisioner: exampledriver.example.com
parameters:
  disk-type: ssd
  csi.storage.k8s.io/fstype: ext4
  csi.storage.k8s.io/provisioner-secret-name: mysecret
  csi.storage.k8s.io/provisioner-secret-namespace: mynamespace
</code></pre>
<h2><a class="header" href="#usage-1" id="usage-1">Usage</a></h2>
<p>CSI drivers that support dynamic volume provisioning should use this sidecar container, and advertise the CSI <code>CREATE_DELETE_VOLUME</code> controller capability.</p>
<p>For detailed information (binary parameters, RBAC rules, etc.), see <a href="https://github.com/kubernetes-csi/external-provisioner/blob/master/README.md">https://github.com/kubernetes-csi/external-provisioner/blob/master/README.md</a>.</p>
<h2><a class="header" href="#deployment-2" id="deployment-2">Deployment</a></h2>
<p>The CSI <code>external-provisioner</code> is deployed as a controller. See <a href="deploying.html">deployment section</a> for more details.</p>
<h1><a class="header" href="#csi-external-resizer" id="csi-external-resizer">CSI external-resizer</a></h1>
<h2><a class="header" href="#status-and-releases-3" id="status-and-releases-3">Status and Releases</a></h2>
<p><strong>Git Repository:</strong> <a href="https://github.com/kubernetes-csi/external-resizer">https://github.com/kubernetes-csi/external-resizer</a></p>
<p><strong>Status:</strong> Beta starting with v0.3.0</p>
<table><thead><tr><th>Latest stable release</th><th>Branch</th><th>Min CSI Version</th><th>Max CSI Version</th><th>Container Image</th><th><a href="kubernetes-compatibility.html#minimum-version">Min K8s Version</a></th><th><a href="kubernetes-compatibility.html#maximum-version">Max K8s Version</a></th><th><a href="kubernetes-compatibility.html#recommended-version">Recommended K8s Version</a></th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/external-resizer/tree/v0.5.0">external-resizer v0.5.0</a></td><td><a href="https://github.com/kubernetes-csi/external-resizer/tree/release-0.5">release-0.5</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.2.0">v1.1.0</a></td><td>-</td><td>quay.io/k8scsi/csi-resizer:v0.5.0</td><td>v1.15</td><td>-</td><td>v1.16</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-resizer/tree/v0.2.0">external-resizer v0.2.0</a></td><td><a href="https://github.com/kubernetes-csi/external-resizer/tree/release-0.2">release-0.2</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.1.0">v1.1.0</a></td><td>-</td><td>quay.io/k8scsi/csi-resizer:v0.2.0</td><td>v1.15</td><td>-</td><td>v1.15</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-resizer/tree/v0.1.0">external-resizer v0.1.0</a></td><td><a href="https://github.com/kubernetes-csi/external-resizer/tree/release-0.1">release-0.1</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.1.0">v1.1.0</a></td><td>-</td><td>quay.io/k8scsi/csi-resizer:v0.1.0</td><td>v1.14</td><td>v1.14</td><td>v1.14</td></tr>
</tbody></table>
<h2><a class="header" href="#description-3" id="description-3">Description</a></h2>
<p>The CSI <code>external-resizer</code> is a sidecar container that watches the Kubernetes API server for <code>PersistentVolumeClaim</code> object edits and
triggers <code>ControllerExpandVolume</code> operations against a CSI endpoint if user requested more storage on <code>PersistentVolumeClaim</code> object.</p>
<h2><a class="header" href="#usage-2" id="usage-2">Usage</a></h2>
<p>CSI drivers that support Kubernetes volume expansion should use this sidecar container, and advertise the CSI <code>VolumeExpansion</code> plugin capability.</p>
<h2><a class="header" href="#deployment-3" id="deployment-3">Deployment</a></h2>
<p>The CSI <code>external-resizer</code> is deployed as a controller. See <a href="deploying.html">deployment section</a> for more details.</p>
<h1><a class="header" href="#csi-external-snapshotter" id="csi-external-snapshotter">CSI external-snapshotter</a></h1>
<h2><a class="header" href="#status-and-releases-4" id="status-and-releases-4">Status and Releases</a></h2>
<p><strong>Git Repository:</strong> <a href="https://github.com/kubernetes-csi/external-snapshotter">https://github.com/kubernetes-csi/external-snapshotter</a></p>
<p><strong>Status:</strong> v2.0.0 and higher is Beta; version below v2.0.0 is Alpha</p>
<h3><a class="header" href="#csi-external-snapshotter-sidecar" id="csi-external-snapshotter-sidecar">CSI External-Snapshotter Sidecar</a></h3>
<table><thead><tr><th>Latest stable release</th><th>Branch</th><th>Min CSI Version</th><th>Max CSI Version</th><th>Container Image</th><th><a href="kubernetes-compatibility.html#minimum-version">Min K8s Version</a></th><th><a href="kubernetes-compatibility.html#maximum-version">Max K8s Version</a></th><th><a href="kubernetes-compatibility.html#recommended-version">Recommended K8s Version</a></th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/external-snapshotter/releases/tag/v2.1.0">external-snapshotter v2.1.0</a></td><td><a href="https://github.com/kubernetes-csi/external-snapshotter/tree/release-2.1">release-2.1</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>quay.io/k8scsi/csi-snapshotter:v2.1.0</td><td>v1.17</td><td>-</td><td>v1.17</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-snapshotter/releases/tag/v1.2.2">external-snapshotter v1.2.2</a></td><td><a href="https://github.com/kubernetes-csi/external-snapshotter/tree/release-1.2">release-1.2</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>quay.io/k8scsi/csi-snapshotter:v1.2.2</td><td>v1.13</td><td>v1.16</td><td>v1.14</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-snapshotter/releases/tag/v0.4.2">external-snapshotter v0.4.2</a></td><td><a href="https://github.com/kubernetes-csi/external-snapshotter/tree/release-0.4">release-0.4</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a></td><td>quay.io/k8scsi/csi-snapshotter:v0.4.2</td><td>v1.12</td><td>v1.16</td><td>v1.12</td></tr>
</tbody></table>
<p>To use the snapshot beta feature, a snapshot controller is also required. For more information, see <a href="snapshot-controller.html">this snapshot-controller page</a>.</p>
<h2><a class="header" href="#snapshot-beta" id="snapshot-beta">Snapshot Beta</a></h2>
<h3><a class="header" href="#description-4" id="description-4">Description</a></h3>
<p>In the Beta version, the snapshot controller will be watching the Kubernetes API server for <code>VolumeSnapshot</code> and <code>VolumeSnapshotContent</code> CRD objects. The CSI <code>external-snapshotter</code> sidecar only watches the Kubernetes API server for <code>VolumeSnapshotContent</code> CRD objects. The CSI <code>external-snapshotter</code> sidecar is also responsible for calling the CSI RPCs CreateSnapshot, DeleteSnapshot, and ListSnapshots.</p>
<p>For detailed snapshot beta design changes, see the design doc <a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-storage/20190709-csi-snapshot.md">here</a>.</p>
<p>For detailed information about volume snapshot and restore functionality, see <a href="snapshot-restore-feature.html">Volume Snapshot &amp; Restore</a>.</p>
<h3><a class="header" href="#usage-3" id="usage-3">Usage</a></h3>
<p>CSI drivers that support provisioning volume snapshots and the ability to provision new volumes using those snapshots should use this sidecar container, and advertise the CSI <code>CREATE_DELETE_SNAPSHOT</code> controller capability.</p>
<p>For detailed information (binary parameters, RBAC rules, etc.), see <a href="https://github.com/kubernetes-csi/external-snapshotter/blob/release-2.0/README.md">https://github.com/kubernetes-csi/external-snapshotter/blob/release-2.0/README.md</a>.</p>
<h3><a class="header" href="#deployment-4" id="deployment-4">Deployment</a></h3>
<p>The CSI <code>external-snapshotter</code> is deployed as a sidecar controller. See <a href="deploying.html">deployment section</a> for more details.</p>
<p>For an example deployment, see <a href="https://github.com/kubernetes-csi/external-snapshotter/blob/release-2.0/deploy/kubernetes/csi-snapshotter/setup-csi-snapshotter.yaml">this example</a> which deploys <code>external-snapshotter</code> and <code>external-provisioner</code> with the Hostpath CSI driver.</p>
<h2><a class="header" href="#snapshot-alpha" id="snapshot-alpha">Snapshot Alpha</a></h2>
<h3><a class="header" href="#description-5" id="description-5">Description</a></h3>
<p>The CSI <code>external-snapshotter</code> is a sidecar container that watches the Kubernetes API server for <code>VolumeSnapshot</code> and <code>VolumeSnapshotContent</code> CRD objects.</p>
<p>The creation of a new <code>VolumeSnapshot</code> object referencing a <code>SnapshotClass</code> CRD object corresponding to this driver causes the sidecar container to trigger a <code>CreateSnapshot</code> operation against the specified CSI endpoint to provision a new snapshot. When a new snapshot is successfully provisioned, the sidecar container creates a Kubernetes <code>VolumeSnapshotContent</code> object to represent the new snapshot.</p>
<p>The deletion of a <code>VolumeSnapshot</code> object bound to a <code>VolumeSnapshotContent</code> corresponding to this driver with a <code>delete</code> deletion policy causes the sidecar container to trigger a <code>DeleteSnapshot</code> operation against the specified CSI endpoint to delete the snapshot. Once the snapshot is successfully deleted, the sidecar container also deletes the <code>VolumeSnapshotContent</code> object representing the snapshot.</p>
<h3><a class="header" href="#usage-4" id="usage-4">Usage</a></h3>
<p>CSI drivers that support provisioning volume snapshots and the ability to provision new volumes using those snapshots should use this sidecar container, and advertise the CSI <code>CREATE_DELETE_SNAPSHOT</code> controller capability.</p>
<p>For detailed information (binary parameters, RBAC rules, etc.), see <a href="https://github.com/kubernetes-csi/external-snapshotter/blob/release-1.2/README.md">https://github.com/kubernetes-csi/external-snapshotter/blob/release-1.2/README.md</a>.</p>
<h3><a class="header" href="#deployment-5" id="deployment-5">Deployment</a></h3>
<p>The CSI <code>external-snapshotter</code> is deployed as a controller. See <a href="deploying.html">deployment section</a> for more details.</p>
<p>For an example deployment, see <a href="https://github.com/kubernetes-csi/external-snapshotter/tree/release-1.2/deploy/kubernetes/setup-csi-snapshotter.yaml">this example</a> which deploys <code>external-snapshotter</code> and <code>external-provisioner</code> with the Hostpath CSI driver.</p>
<h1><a class="header" href="#csi-livenessprobe" id="csi-livenessprobe">CSI livenessprobe</a></h1>
<h2><a class="header" href="#status-and-releases-5" id="status-and-releases-5">Status and Releases</a></h2>
<p><strong>Git Repository:</strong> <a href="https://github.com/kubernetes-csi/livenessprobe">https://github.com/kubernetes-csi/livenessprobe</a></p>
<p><strong>Status:</strong> GA/Stable</p>
<p>Latest stable release | Branch | Min CSI Version | Max CSI Version | Container Image | <a href="kubernetes-compatibility.html#minimum-version">Min K8s Version</a> | <a href="kubernetes-compatibility.html#maximum-version">Max K8s Version</a> |
--|--|--|--|--|--
<a href="https://github.com/kubernetes-csi/livenessprobe/releases/tag/v2.0.0">livenessprobe v2.0.0</a> | <a href="https://github.com/kubernetes-csi/livenessprobe/tree/release-2.0">release-2.0</a> | <a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a> | quay.io/k8scsi/livenessprobe:v2.0.0 | v1.13 | -
<a href="https://github.com/kubernetes-csi/livenessprobe/releases/tag/v1.1.0">livenessprobe v1.1.0</a> | <a href="https://github.com/kubernetes-csi/livenessprobe/tree/release-1.1">release-1.1</a> | <a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a> | quay.io/k8scsi/livenessprobe:v1.1.0 | v1.13 | -
Unsupported. | No 0.x branch. | <a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a> | quay.io/k8scsi/livenessprobe:v0.4.1 | v1.10 | v1.16</p>
<h2><a class="header" href="#description-6" id="description-6">Description</a></h2>
<p>The CSI <code>livenessprobe</code> is a sidecar container that monitors the health of the CSI driver and reports it to Kubernetes via the <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/">Liveness Probe mechanism</a>. This enables Kubernetes to automatically detect issues with the driver and restart the pod to try and fix the issue.</p>
<h2><a class="header" href="#usage-5" id="usage-5">Usage</a></h2>
<p>All CSI drivers should use the liveness probe to improve the availability of the driver while deployed on Kubernetes.</p>
<p>For detailed information (binary parameters, RBAC rules, etc.), see <a href="https://github.com/kubernetes-csi/livenessprobe/blob/master/README.md">https://github.com/kubernetes-csi/livenessprobe/blob/master/README.md</a>.</p>
<h2><a class="header" href="#deployment-6" id="deployment-6">Deployment</a></h2>
<p>The CSI <code>livenessprobe</code> is deployed as part of controller and node deployments. See <a href="deploying.html">deployment section</a> for more details.</p>
<h1><a class="header" href="#csi-node-driver-registrar" id="csi-node-driver-registrar">CSI node-driver-registrar</a></h1>
<h2><a class="header" href="#status-and-releases-6" id="status-and-releases-6">Status and Releases</a></h2>
<p><strong>Git Repository:</strong> <a href="https://github.com/kubernetes-csi/node-driver-registrar">https://github.com/kubernetes-csi/node-driver-registrar</a></p>
<p><strong>Status:</strong> GA/Stable</p>
<p>Latest stable release | Branch | Min CSI Version | Max CSI Version | Container Image | <a href="kubernetes-compatibility.html#minimum-version">Min K8s Version</a> | <a href="kubernetes-compatibility.html#maximum-version">Max K8s Version</a> | <a href="kubernetes-compatibility.html#recommended-version">Recommended K8s Version</a> |
--|--|--|--|--|--|--
<a href="https://github.com/kubernetes-csi/node-driver-registrar/releases/tag/v1.2.0">node-driver-registrar v1.2.0</a> | <a href="https://github.com/kubernetes-csi/node-driver-registrar/tree/release-1.2">release-1.2</a> | <a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a> | - | quay.io/k8scsi/csi-node-driver-registrar:v1.2.0 | v1.13 | -
<a href="https://github.com/kubernetes-csi/driver-registrar/releases/tag/v0.4.2">driver-registrar v0.4.2</a> | <a href="https://github.com/kubernetes-csi/driver-registrar/tree/release-0.4">release-0.4</a> | <a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a> | <a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a> | quay.io/k8scsi/driver-registrar:v0.4.2 | v1.10 | v1.16</p>
<h2><a class="header" href="#description-7" id="description-7">Description</a></h2>
<p>The CSI <code>node-driver-registrar</code> is a sidecar container that fetches driver information (using <code>NodeGetInfo</code>) from a CSI endpoint and registers it with the kubelet on that node using the <a href="https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/#device-plugin-registration">kubelet plugin registration mechanism</a>.</p>
<h2><a class="header" href="#usage-6" id="usage-6">Usage</a></h2>
<p>Kubelet directly issues CSI <code>NodeGetInfo</code>, <code>NodeStageVolume</code>, and <code>NodePublishVolume</code> calls against CSI drivers. It uses the <a href="https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/#device-plugin-registration">kubelet plugin registration mechanism</a> to discover the unix domain socket to talk to the CSI driver. Therefore, all CSI drivers should use this sidecar container to register themselves with kubelet.</p>
<p>For detailed information (binary parameters, etc.), see the README of the relevant branch.</p>
<h2><a class="header" href="#deployment-7" id="deployment-7">Deployment</a></h2>
<p>The CSI <code>node-driver-registrar</code> is deployed per node. See <a href="deploying.html">deployment section</a> for more details.</p>
<h1><a class="header" href="#csi-cluster-driver-registrar" id="csi-cluster-driver-registrar">CSI cluster-driver-registrar</a></h1>
<h2><a class="header" href="#deprecated" id="deprecated">Deprecated</a></h2>
<p>This sidecar container was not updated since Kubernetes 1.13. As of Kubernetes
1.16, this side car container is officially deprecated.</p>
<p>The purpose of this side car container was to automatically register
a <em>CSIDriver</em> object containing information about the driver with Kubernetes.
Without this side car, developers and CSI driver vendors will now have to add
a CSIDriver object in their installation manifest or any tool that installs
their CSI driver.</p>
<p>Please see <a href="csi-driver-object.html">CSIDriver</a> for more information.</p>
<h2><a class="header" href="#status-and-releases-7" id="status-and-releases-7">Status and Releases</a></h2>
<p><strong>Git Repository:</strong> <a href="https://github.com/kubernetes-csi/cluster-driver-registrar">https://github.com/kubernetes-csi/cluster-driver-registrar</a></p>
<p><strong>Status:</strong> Alpha</p>
<table><thead><tr><th>Latests stable release</th><th>Branch</th><th>Compatible with CSI Version</th><th>Container Image</th><th>Min k8s Version</th><th>Max k8s version</th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/cluster-driver-registrar/releases/tag/v1.0.1">cluster-driver-registrar v1.0.1</a></td><td><a href="https://github.com/kubernetes-csi/cluster-driver-registrar/tree/release-1.0">release-1.0</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>quay.io/k8scsi/csi-cluster-driver-registrar:v1.0.1</td><td>v1.13</td><td>-</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/driver-registrar/releases/tag/v0.4.2">driver-registrar v0.4.2</a></td><td><a href="https://github.com/kubernetes-csi/driver-registrar/tree/release-0.4">release-0.4</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a></td><td>quay.io/k8scsi/driver-registrar:v0.4.2</td><td>v1.10</td><td>-</td></tr>
</tbody></table>
<h2><a class="header" href="#description-8" id="description-8">Description</a></h2>
<p>The CSI <code>cluster-driver-registrar</code> is a sidecar container that registers a CSI Driver with a Kubernetes cluster by creating a <a href="csi-driver-object.html">CSIDriver Object</a> which enables the driver to customize how Kubernetes interacts with it.</p>
<h2><a class="header" href="#usage-7" id="usage-7">Usage</a></h2>
<p>CSI drivers that use one of the following Kubernetes features should use this sidecar container:</p>
<ul>
<li><a href="skip-attach.html">Skip Attach</a>
<ul>
<li>For drivers that don't support <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md#controllerpublishvolume"><code>ControllerPublishVolume</code></a>, this indicates to Kubernetes to skip the attach operation and eliminates the need to deploy the <code>external-attacher</code> sidecar.</li>
</ul>
</li>
<li><a href="pod-info.html">Pod Info on Mount</a>
<ul>
<li>This causes Kubernetes to pass metadata such as Pod name and namespace to the <code>NodePublishVolume</code> call.</li>
</ul>
</li>
</ul>
<p>If you are not using one of these features, this sidecar container (and the creation of the <a href="csi-driver-object.html">CSIDriver Object</a>) is not required. However, it is still recommended, because the <a href="csi-driver-object.html">CSIDriver Object</a> makes it easier for users to easily discover the CSI drivers installed on their clusters.</p>
<p>For detailed information (binary parameters, etc.), see the README of the relevant branch.</p>
<h2><a class="header" href="#deployment-8" id="deployment-8">Deployment</a></h2>
<p>The CSI <code>cluster-driver-registrar</code> is deployed as a controller. See <a href="deploying.html">deployment section</a> for more details.</p>
<h1><a class="header" href="#csi-objects" id="csi-objects">CSI objects</a></h1>
<p>The Kubernetes API contains the following CSI specific objects:</p>
<ul>
<li><a href="csi-driver-object.html">CSIDriver Object</a></li>
<li><a href="csi-node-object.html">CSINode Object</a></li>
</ul>
<p>The schema definition for the objects can be found in the <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#-strong-config-and-storage-apis-strong-">Kubernetes API reference</a></p>
<h1><a class="header" href="#csidriver-object" id="csidriver-object">CSIDriver Object</a></h1>
<h2><a class="header" href="#status" id="status">Status</a></h2>
<ul>
<li>Kubernetes 1.12 - 1.13: Alpha</li>
<li>Kubernetes 1.14: Beta</li>
<li>Kubernetes 1.18: GA</li>
</ul>
<h2><a class="header" href="#what-is-the-csidriver-object" id="what-is-the-csidriver-object">What is the CSIDriver object?</a></h2>
<p>The <code>CSIDriver</code> Kubernetes API object serves two purposes:</p>
<ol>
<li>Simplify driver discovery</li>
</ol>
<ul>
<li>If a CSI driver creates a <code>CSIDriver</code> object, Kubernetes users can easily discover the CSI Drivers installed on their cluster (simply by issuing <code>kubectl get CSIDriver</code>)</li>
</ul>
<ol start="2">
<li>Customizing Kubernetes behavior</li>
</ol>
<ul>
<li>Kubernetes has a default set of behaviors when dealing with CSI Drivers (for example, it calls the <code>Attach</code>/<code>Detach</code> operations by default). This object allows CSI drivers to specify how Kubernetes should interact with it.</li>
</ul>
<h2><a class="header" href="#what-fields-does-the-csidriver-object-have" id="what-fields-does-the-csidriver-object-have">What fields does the <code>CSIDriver</code> object have?</a></h2>
<p>Here is an example of a v1 <code>CSIDriver</code> object:</p>
<pre><code class="language-YAML">apiVersion: storage.k8s.io/v1
kind: CSIDriver
metadata:
  name: mycsidriver.example.com
spec:
  attachRequired: true
  podInfoOnMount: true
  volumeLifecycleModes: # added in Kubernetes 1.16, this field is beta
  - Persistent
  - Ephemeral
</code></pre>
<p>There are four important fields:</p>
<ul>
<li><code>name</code>
<ul>
<li>This should correspond to the full name of the CSI driver.</li>
</ul>
</li>
<li><code>attachRequired</code>
<ul>
<li>Indicates this CSI volume driver requires an attach operation (because it implements the CSI <code>ControllerPublishVolume</code> method), and that Kubernetes should call attach and wait for any attach operation to complete before proceeding to mounting.</li>
<li>If a <code>CSIDriver</code> object does not exist for a given CSI Driver, the default is <code>true</code> -- meaning attach will be called.</li>
<li>If a <code>CSIDriver</code> object exists for a given CSI Driver, but this field is not specified, it also defaults to <code>true</code> -- meaning attach will be called.</li>
<li>For more information see <a href="skip-attach.html">Skip Attach</a>.</li>
</ul>
</li>
<li><code>podInfoOnMount</code>
<ul>
<li>Indicates this CSI volume driver requires additional pod information (like pod name, pod UID, etc.) during mount operations.</li>
<li>If value is not specified or <code>false</code>, pod information will not be passed on mount.</li>
<li>If value is set to <code>true</code>, Kubelet will pass pod information as <code>volume_context</code> in CSI <code>NodePublishVolume</code> calls:
<ul>
<li><code>&quot;csi.storage.k8s.io/pod.name&quot;: pod.Name</code></li>
<li><code>&quot;csi.storage.k8s.io/pod.namespace&quot;: pod.Namespace</code></li>
<li><code>&quot;csi.storage.k8s.io/pod.uid&quot;: string(pod.UID)</code></li>
<li><code>&quot;csi.storage.k8s.io/serviceAccount.name&quot;: pod.Spec.ServiceAccountName</code></li>
</ul>
</li>
<li>For more information see <a href="pod-info.html">Pod Info on Mount</a>.</li>
</ul>
</li>
<li><code>volumeLifecycleModes</code>
<ul>
<li>This field was added in Kubernetes 1.16 and cannot be set when using an older Kubernetes release.</li>
<li>This field is beta.</li>
<li>It informs Kubernetes about the volume modes that are supported by the driver.
This ensures that the driver <a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-storage/20190122-csi-inline-volumes.md#support-for-inline-csi-volumes">is not used incorrectly</a> by users.
The default is <code>Persistent</code>, which is the normal PVC/PV mechanism. <code>Ephemeral</code> enables
<a href="ephemeral-local-volumes.html">inline ephemeral volumes</a> in addition (when both
are listed) or instead of normal volumes (when it is the only entry in the list).</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#what-creates-the-csidriver-object" id="what-creates-the-csidriver-object">What creates the CSIDriver object?</a></h2>
<p>To install, a CSI driver's deployment manifest must contain a <code>CSIDriver</code>
object as shown in the example above.</p>
<blockquote>
<p>NOTE: The cluster-driver-registrar side-car which was used to create CSIDriver
objects in Kubernetes 1.13 has been deprecated for Kubernetes 1.16. No
cluster-driver-registrar has been released for Kubernetes 1.14 and later.</p>
</blockquote>
<p><code>CSIDriver</code> instance should exist for whole lifetime of all pods that use
volumes provided by corresponding CSI driver, so <a href="skip-attach.html">Skip Attach</a>
and <a href="pod-info.html">Pod Info on Mount</a> features work correctly.</p>
<h3><a class="header" href="#listing-registered-csi-drivers" id="listing-registered-csi-drivers">Listing registered CSI drivers</a></h3>
<p>Using the <code>CSIDriver</code> object, it is now possible to query Kubernetes to get a list of registered drivers running in the cluster as shown below:</p>
<pre><code>$&gt; kubectl get csidrivers.storage.k8s.io
NAME                  CREATED AT
hostpath.csi.k8s.io   2019-09-13T09:58:43Z
</code></pre>
<p>Or get a more detailed view of your registered driver with:</p>
<pre><code>$&gt; kubectl describe csidrivers.storage.k8s.io
Name:         hostpath.csi.k8s.io
Namespace:    
Labels:       &lt;none&gt;
Annotations:  kubectl.kubernetes.io/last-applied-configuration:
                {&quot;apiVersion&quot;:&quot;storage.k8s.io/v1&quot;,&quot;kind&quot;:&quot;CSIDriver&quot;,&quot;metadata&quot;:{&quot;annotations&quot;:{},&quot;name&quot;:&quot;hostpath.csi.k8s.io&quot;},&quot;spec&quot;:{&quot;podInfoOnMou...
API Version:  storage.k8s.io/v1
Kind:         CSIDriver
Metadata:
  Creation Timestamp:  2019-09-13T09:58:43Z
  Resource Version:    341
  Self Link:           /apis/storage.k8s.io/v1/csidrivers/hostpath.csi.k8s.io
  UID:                 1860f2a1-85f8-4357-a933-c45e54f0c8e0
Spec:
  Attach Required:    true
  Pod Info On Mount:  true
  Volume Lifecycle Modes:
    Persistent
    Ephemeral
Events:  &lt;none&gt;
</code></pre>
<h2><a class="header" href="#changes-from-alpha-to-beta" id="changes-from-alpha-to-beta">Changes from Alpha to Beta</a></h2>
<h3><a class="header" href="#crd-to-built-in-type" id="crd-to-built-in-type">CRD to Built in Type</a></h3>
<p>During alpha development, the <code>CSIDriver</code> object was also defined as a <a href="https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/#create-a-customresourcedefinition">Custom Resource Definition</a> (CRD). As part of the promotion to beta the object has been moved to the built-in Kubernetes API.</p>
<p>In the move from alpha to beta, the API Group for this object changed from <code>csi.storage.k8s.io/v1alpha1</code> to <code>storage.k8s.io/v1beta1</code>.</p>
<p>There is no automatic update of existing CRDs and their CRs during Kubernetes update to the new build-in type.</p>
<h3><a class="header" href="#enabling-csidriver-on-kubernetes" id="enabling-csidriver-on-kubernetes">Enabling CSIDriver on Kubernetes</a></h3>
<p>In Kubernetes v1.12 and v1.13, because the feature was alpha, it was disabled by default. To enable the use of <code>CSIDriver</code> on these versions, do the following:</p>
<ol>
<li>Ensure the feature gate is enabled via the following Kubernetes feature flag: <code>--feature-gates=CSIDriverRegistry=true</code></li>
<li>Either ensure the <code>CSIDriver</code> CRD is automatically installed via the <a href="https://github.com/kubernetes/kubernetes/tree/release-1.13/cluster/addons/storage-crds">Kubernetes Storage CRD addon</a> OR manually install the <code>CSIDriver</code> CRD on the Kubernetes cluster with the following command:</li>
</ol>
<pre><code>$&gt; kubectl create -f https://raw.githubusercontent.com/kubernetes/csi-api/master/pkg/crd/manifests/csidriver.yaml
</code></pre>
<p>Kubernetes v1.14+, uses the same Kubernetes feature flag, but because the feature is beta, it is enabled by default. And since the API type (as of beta) is built in to the Kubernetes API, installation of the CRD is no longer required.</p>
<h1><a class="header" href="#csinode-object" id="csinode-object">CSINode Object</a></h1>
<h2><a class="header" href="#status-1" id="status-1">Status</a></h2>
<table><thead><tr><th>Status</th><th>Min K8s Version</th><th>Max K8s Version</th></tr></thead><tbody>
<tr><td>Alpha</td><td>1.12</td><td>1.13</td></tr>
<tr><td>Beta</td><td>1.14</td><td>1.16</td></tr>
<tr><td>GA</td><td>1.17</td><td>-</td></tr>
</tbody></table>
<h2><a class="header" href="#what-is-the-csinode-object" id="what-is-the-csinode-object">What is the CSINode object?</a></h2>
<p>CSI drivers generate node specific information. Instead of storing this in the Kubernetes <code>Node</code> API Object, a new CSI specific Kubernetes <code>CSINode</code> object was created.</p>
<p>It serves the following purposes:</p>
<ol>
<li>Mapping Kubernetes node name to CSI Node name,</li>
</ol>
<ul>
<li>The CSI <code>GetNodeInfo</code> call returns the name by which the storage system refers to a node. Kubernetes must use this name in future <code>ControllerPublishVolume</code> calls. Therefore, when a new CSI driver is registered, Kubernetes stores the storage system node ID in the <code>CSINode</code> object for future reference.</li>
</ul>
<ol start="2">
<li>Driver availability</li>
</ol>
<ul>
<li>A way for kubelet to communicate to the kube-controller-manager and kubernetes scheduler whether the driver is available (registered) on the node or not.</li>
</ul>
<ol start="3">
<li>Volume topology</li>
</ol>
<ul>
<li>The CSI <code>GetNodeInfo</code> call returns a set of keys/values labels identifying the topology of that node. Kubernetes uses this information to do topology-aware provisioning (see <a href="https://kubernetes.io/docs/concepts/storage/storage-classes/#volume-binding-mode">PVC Volume Binding Modes</a> for more details). It stores the key/values as labels on the Kubernetes node object. In order to recall which <code>Node</code> label keys belong to a specific CSI driver, the kubelet stores the keys in the <code>CSINode</code> object for future reference.</li>
</ul>
<h2><a class="header" href="#what-fields-does-the-csinode-object-have" id="what-fields-does-the-csinode-object-have">What fields does the CSINode object have?</a></h2>
<p>Here is an example of a v1 <code>CSINode</code> object:</p>
<pre><code class="language-YAML">apiVersion: storage.k8s.io/v1
kind: CSINode
metadata:
  name: node1
spec:
  drivers:
  - name: mycsidriver.example.com
    nodeID: storageNodeID1
    topologyKeys: ['mycsidriver.example.com/regions', &quot;mycsidriver.example.com/zones&quot;]
</code></pre>
<p>What the fields mean:</p>
<ul>
<li><code>drivers</code> - list of CSI drivers running on the node and their properties.</li>
<li><code>name</code> - the CSI driver that this object refers to.</li>
<li><code>nodeID</code> - the assigned identifier for the node as determined by the driver.</li>
<li><code>topologyKeys</code> - A list of topology keys assigned to the node as supported by the driver.</li>
</ul>
<h2><a class="header" href="#what-creates-the-csinode-object" id="what-creates-the-csinode-object">What creates the CSINode object?</a></h2>
<p>CSI drivers do not need to create the <code>CSINode</code> object directly. Kubelet manages the object when a CSI driver registers through the kubelet plugin registration mechanism. The <a href="node-driver-registrar.html">node-driver-registrar</a> sidecar container helps with this registration.</p>
<h2><a class="header" href="#changes-from-alpha-to-beta-1" id="changes-from-alpha-to-beta-1">Changes from Alpha to Beta</a></h2>
<h3><a class="header" href="#crd-to-built-in-type-1" id="crd-to-built-in-type-1">CRD to Built in Type</a></h3>
<p>The alpha object was called <code>CSINodeInfo</code>, whereas the beta object is called
<code>CSINode</code>. The alpha <code>CSINodeInfo</code> object was also defined as a <a href="https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/#create-a-customresourcedefinition">Custom Resource Definition</a> (CRD). As part of the promotion to beta the object has been moved to the built-in Kubernetes API.</p>
<p>In the move from alpha to beta, the API Group for this object changed from <code>csi.storage.k8s.io/v1alpha1</code> to <code>storage.k8s.io/v1beta1</code>.</p>
<p>There is no automatic update of existing CRDs and their CRs during Kubernetes update to the new build-in type.</p>
<h3><a class="header" href="#enabling-csinodeinfo-on-kubernetes" id="enabling-csinodeinfo-on-kubernetes">Enabling CSINodeInfo on Kubernetes</a></h3>
<p>In Kubernetes v1.12 and v1.13, because the feature was alpha, it was disabled by default. To enable the use of <code>CSINodeInfo</code> on these versions, do the following:</p>
<ol>
<li>Ensure the feature gate is enabled with <code>--feature-gates=CSINodeInfo=true</code></li>
<li>Either ensure the <code>CSIDriver</code> CRD is automatically installed via the <a href="https://github.com/kubernetes/kubernetes/tree/release-1.13/cluster/addons/storage-crds">Kubernetes Storage CRD addon</a> OR manually install the <code>CSINodeInfo</code> CRD on the Kubernetes cluster with the following command:</li>
</ol>
<pre><code>$&gt; kubectl create -f https://raw.githubusercontent.com/kubernetes/csi-api/master/pkg/crd/manifests/csinodeinfo.yaml
</code></pre>
<p>Kubernetes v1.14+, uses the same Kubernetes feature flag, but because the feature is beta, it is enabled by default. And since the API type (as of beta) is built in to the Kubernetes API, installation of the CRD is no longer required.</p>
<h1><a class="header" href="#features-10" id="features-10">Features</a></h1>
<p>The Kubernetes implementation of CSI has multiple sub-features. This section describes these sub-features, their status (although support for CSI in Kubernetes is GA/stable, support of sub-features moves independently so sub-features maybe alpha or beta), and how to integrate them in to your CSI Driver.</p>
<h1><a class="header" href="#secrets-and-credentials" id="secrets-and-credentials">Secrets and Credentials</a></h1>
<p>Some drivers may require a secret in order to complete operations.</p>
<h2><a class="header" href="#csi-driver-secrets" id="csi-driver-secrets">CSI Driver Secrets</a></h2>
<p>If a CSI Driver requires secrets for a backend (a service account, for example), and this secret is required at the &quot;per driver&quot; granularity (not different &quot;per CSI operation&quot; or &quot;per volume&quot;), then the secret SHOULD be injected directly in to CSI driver pods via <a href="https://kubernetes.io/docs/tasks/inject-data-application/distribute-credentials-secure/">standard Kubernetes secret distribution mechanisms</a> during deployment.</p>
<h2><a class="header" href="#csi-operation-secrets" id="csi-operation-secrets">CSI Operation Secrets</a></h2>
<p>If a CSI Driver requires secrets &quot;per CSI operation&quot; or &quot;per volume&quot; or &quot;per storage pool&quot;, the CSI spec allows secrets to be passed in for various CSI operations (including <code>CreateVolumeRequest</code>, <code>ControllerPublishVolumeRequest</code>, and more).</p>
<p>Cluster admins can populate such secrets by creating Kubernetes <code>Secret</code> objects and specifying the keys in the <code>StorageClass</code> or <code>SnapshotClass</code> objects.</p>
<p>The CSI sidecar containers facilitate the handling of secrets between Kubernetes and the CSI Driver. For more details see:</p>
<ul>
<li><a href="secrets-and-credentials-storage-class.html">StorageClass Secrets</a></li>
<li><a href="secrets-and-credentials-volume-snapshot-class.html">VolumeSnapshotClass Secrets</a></li>
</ul>
<h3><a class="header" href="#secret-rbac-rules" id="secret-rbac-rules">Secret RBAC Rules</a></h3>
<p>For reducing RBAC permissions as much as possible, secret rules are disabled in each sidecar repository by default.</p>
<p>Please add or update RBAC rules if secret is expected to use.</p>
<p>To set proper secret permission, uncomment related lines defined in <code>rbac.yaml</code> (e.g. <a href="https://github.com/kubernetes-csi/external-provisioner/blob/22bb6401d2484ee3ca18a23d75c3864c774e5f32/deploy/kubernetes/rbac.yaml#L24">external-provisioner/deploy/kubernetes/rbac.yaml</a>)</p>
<h2><a class="header" href="#handling-sensitive-information" id="handling-sensitive-information">Handling Sensitive Information</a></h2>
<p>CSI Drivers that accept secrets SHOULD handle this data carefully. It may contain sensitive information and MUST be treated as such (e.g. not logged).</p>
<p>To make it easier to handle secret fields (e.g. strip them from CSI protos when logging), the CSI spec defines a decorator (<code>csi_secret</code>) on all fields containing sensitive information. Any fields decorated with <code>csi_secret</code> MUST be treated as if they contain sensitive information (e.g. not logged, etc.).</p>
<p>The Kubernetes CSI development team also provides a GO lang package called <code>protosanitizer</code> that CSI driver developers may be used to remove values for all fields in a gRPC messages decorated with <code>csi_secret</code>. The library can be found in <a href="https://github.com/kubernetes-csi/csi-lib-utils/tree/master/protosanitizer">kubernetes-csi/csi-lib-utils/protosanitizer</a>. The Kubernetes CSI <a href="sidecar-containers.html">Sidecar Containers</a> and sample drivers use this library to ensure no sensitive information is logged.</p>
<h1><a class="header" href="#storageclass-secrets" id="storageclass-secrets">StorageClass Secrets</a></h1>
<p>The CSI <a href="external-provisioner.html">external-provisioner</a> sidecar container facilitates the handling of secrets for the following operations:</p>
<ul>
<li><code>CreateVolumeRequest</code></li>
<li><code>DeleteVolumeRequest</code></li>
<li><code>ControllerPublishVolumeRequest</code></li>
<li><code>ControllerUnpublishVolumeRequest</code></li>
<li><code>ControllerExpandVolumeRequest</code></li>
<li><code>NodeStageVolumeRequest</code></li>
<li><code>NodePublishVolumeRequest</code></li>
</ul>
<p>CSI <code>external-provisioner</code> v1.0.1+ supports the following keys in <code>StorageClass.parameters</code>:</p>
<ul>
<li><code>csi.storage.k8s.io/provisioner-secret-name</code></li>
<li><code>csi.storage.k8s.io/provisioner-secret-namespace</code></li>
<li><code>csi.storage.k8s.io/controller-publish-secret-name</code></li>
<li><code>csi.storage.k8s.io/controller-publish-secret-namespace</code></li>
<li><code>csi.storage.k8s.io/node-stage-secret-name</code></li>
<li><code>csi.storage.k8s.io/node-stage-secret-namespace</code></li>
<li><code>csi.storage.k8s.io/node-publish-secret-name</code></li>
<li><code>csi.storage.k8s.io/node-publish-secret-namespace</code></li>
</ul>
<p>CSI <code>external-provisioner</code> v1.2.0+ adds support for the following keys in <code>StorageClass.parameters</code>:</p>
<ul>
<li><code>csi.storage.k8s.io/controller-expand-secret-name</code></li>
<li><code>csi.storage.k8s.io/controller-expand-secret-namespace</code></li>
</ul>
<p>Cluster admins can populate the secret fields for the operations listed above with data from Kubernetes <code>Secret</code> objects by specifying these keys in the <code>StorageClass</code> object.</p>
<h2><a class="header" href="#examples" id="examples">Examples</a></h2>
<h3><a class="header" href="#basic-provisioning-secret" id="basic-provisioning-secret">Basic Provisioning Secret</a></h3>
<p>In this example, the external-provisioner will fetch Kubernetes <code>Secret</code> object <code>fast-storage-provision-key</code> in the namespace <code>pd-ssd-credentials</code> and pass the credentials to the CSI driver named <code>csi-driver.team.example.com</code> in the <code>CreateVolume</code> CSI call.</p>
<pre><code class="language-yaml">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: fast-storage
provisioner: csi-driver.team.example.com
parameters:
  type: pd-ssd
  csi.storage.k8s.io/provisioner-secret-name: fast-storage-provision-key
  csi.storage.k8s.io/provisioner-secret-namespace: pd-ssd-credentials
</code></pre>
<p>All volumes provisioned using this <code>StorageClass</code> use the same secret.</p>
<h3><a class="header" href="#per-volume-secrets" id="per-volume-secrets">Per Volume Secrets</a></h3>
<p>In this example, the external-provisioner will generate the name of the Kubernetes <code>Secret</code> object and namespace for the <code>NodePublishVolume</code> CSI call, based on the PVC namespace and annotations, at volume provision time.</p>
<pre><code class="language-yaml">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: fast-storage
provisioner: csi-driver.team.example.com
parameters:
  type: pd-ssd
  csi.storage.k8s.io/node-publish-secret-name: ${pvc.annotations['team.example.com/key']}
  csi.storage.k8s.io/node-publish-secret-namespace: ${pvc.namespace}
</code></pre>
<p>This StorageClass will result in the creation of a <code>PersistentVolume</code> API object referencing a &quot;node publish secret&quot; in the same namespace as the <code>PersistentVolumeClaim</code> that triggered the provisioning and with a name specified as an annotation on the <code>PersistentVolumeClaim</code>. This could be used to give the creator of the <code>PersistentVolumeClaim</code> the ability to specify a secret containing a decryption key they have control over.</p>
<h3><a class="header" href="#multiple-operation-secrets" id="multiple-operation-secrets">Multiple Operation Secrets</a></h3>
<p>A drivers may support secret keys for multiple operations. In this case, you can provide secrets references for each operation:</p>
<pre><code class="language-yaml">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: fast-storage-all
provisioner: csi-driver.team.example.com
parameters:
  type: pd-ssd
  csi.storage.k8s.io/provisioner-secret-name: ${pvc.name}
  csi.storage.k8s.io/provisioner-secret-namespace: ${pvc.namespace}-fast-storage
  csi.storage.k8s.io/node-publish-secret-name: ${pvc.name}-${pvc.annotations['team.example.com/key']}
  csi.storage.k8s.io/node-publish-secret-namespace: ${pvc.namespace}-fast-storage
  
</code></pre>
<h2><a class="header" href="#operations" id="operations">Operations</a></h2>
<p>Details for each secret supported by the external-provisioner can be found below.</p>
<h3><a class="header" href="#createdelete-volume-secret" id="createdelete-volume-secret">Create/Delete Volume Secret</a></h3>
<p>The CSI <code>external-provisioner</code> (v1.0.1+) looks for the following keys in <code>StorageClass.parameters</code>.</p>
<ul>
<li><code>csi.storage.k8s.io/provisioner-secret-name</code></li>
<li><code>csi.storage.k8s.io/provisioner-secret-namespace</code></li>
</ul>
<p>The values of both of these parameters, together, refer to the name and namespace of a <code>Secret</code> object in the Kubernetes API.</p>
<p>If specified, the CSI <code>external-provisioner</code> will attempt to fetch the secret before provisioning and deletion.</p>
<p>If the secret is retrieved successfully, the provisioner passes it to the CSI driver in the <code>CreateVolumeRequest.secrets</code> or <code>DeleteVolumeRequest.secrets</code> field.</p>
<p>If no such secret exists in the Kubernetes API, or the provisioner is unable to fetch it, the provision operation will fail.</p>
<p>Note, however, that the delete operation will continue even if the secret is not found (because, for example, the entire namespace containing the secret was deleted). In this case, if the driver requires a secret for deletion, then the volume and PV may need to be manually cleaned up.</p>
<p>The values of these parameters may be &quot;templates&quot;. The <code>external-provisioner</code> will automatically resolve templates at volume provision time, as detailed below:</p>
<ul>
<li><code>csi.storage.k8s.io/provisioner-secret-name</code>
<ul>
<li><code>${pv.name}</code>
<ul>
<li>Replaced with name of the <code>PersistentVolume</code> object being provisioned.</li>
</ul>
</li>
<li><code>${pvc.namespace}</code>
<ul>
<li>Replaced with namespace of the <code>PersistentVolumeClaim</code> object that triggered provisioning.</li>
<li>Support added in CSI <code>external-provisioner</code> v1.2.0+</li>
</ul>
</li>
<li><code>${pvc.name}</code>
<ul>
<li>Replaced with the name of the <code>PersistentVolumeClaim</code> object that triggered provisioning.</li>
<li>Support added in CSI <code>external-provisioner</code> v1.2.0+</li>
</ul>
</li>
</ul>
</li>
<li><code>csi.storage.k8s.io/provisioner-secret-namespace</code>
<ul>
<li><code>${pv.name}</code>
<ul>
<li>Replaced with name of the <code>PersistentVolume</code> object being provisioned.</li>
</ul>
</li>
<li><code>${pvc.namespace}</code>
<ul>
<li>Replaced with namespace of the <code>PersistentVolumeClaim</code> object that triggered provisioning.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#controller-publishunpublish-secret" id="controller-publishunpublish-secret">Controller Publish/Unpublish Secret</a></h3>
<p>The CSI <code>external-provisioner</code> (v1.0.1+) looks for the following keys in <code>StorageClass.parameters</code>:</p>
<ul>
<li><code>csi.storage.k8s.io/controller-publish-secret-name</code></li>
<li><code>csi.storage.k8s.io/controller-publish-secret-namespace</code></li>
</ul>
<p>The values of both of these parameters, together, refer to the name and namespace of a <code>Secret</code> object in the Kubernetes API.</p>
<p>If specified, the CSI <code>external-provisioner</code> sets the <code>CSIPersistentVolumeSource.ControllerPublishSecretRef</code> field in the new <code>PersistentVolume</code> object to refer to this secret once provisioning is successful.</p>
<p>The CSI <code>external-attacher</code> then attempts to fetch the secret referenced by the <code>CSIPersistentVolumeSource.ControllerPublishSecretRef</code>, if specified, before an attach or detach operation.</p>
<p>If no such secret exists in the Kubernetes API, or the <code>external-attacher</code> is unable to fetch it, the attach or detach operation fails.</p>
<p>If the secret is retrieved successfully, the <code>external-attacher</code> passes it to the CSI driver in the <code>ControllerPublishVolumeRequest.secrets</code> or <code>ControllerUnpublishVolumeRequest.secrets</code> field.</p>
<p>The values of these parameters may be &quot;templates&quot;. The <code>external-provisioner</code> will automatically resolve templates at volume provision time, as detailed below:</p>
<ul>
<li><code>csi.storage.k8s.io/controller-publish-secret-name</code>
<ul>
<li><code>${pv.name}</code>
<ul>
<li>Replaced with name of the <code>PersistentVolume</code> object being provisioned.</li>
</ul>
</li>
<li><code>${pvc.namespace}</code>
<ul>
<li>Replaced with namespace of the <code>PersistentVolumeClaim</code> object that triggered provisioning.</li>
</ul>
</li>
<li><code>${pvc.name}</code>
<ul>
<li>Replaced with the name of the <code>PersistentVolumeClaim</code> object that triggered provisioning.</li>
</ul>
</li>
<li><code>${pvc.annotations['&lt;ANNOTATION_KEY&gt;']}</code> (e.g. <code>${pvc.annotations['example.com/key']}</code>)
<ul>
<li>Replaced with the value of the specified annotation from the <code>PersistentVolumeClaim</code> object that triggered provisioning</li>
</ul>
</li>
</ul>
</li>
<li><code>csi.storage.k8s.io/controller-publish-secret-namespace</code>
<ul>
<li><code>${pv.name}</code>
<ul>
<li>Replaced with name of the <code>PersistentVolume</code> object being provisioned.</li>
</ul>
</li>
<li><code>${pvc.namespace}</code>
<ul>
<li>Replaced with namespace of the <code>PersistentVolumeClaim</code> object that triggered provisioning.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#node-stage-secret" id="node-stage-secret">Node Stage Secret</a></h3>
<p>The CSI <code>external-provisioner</code> (v1.0.1+) looks for the following keys in <code>StorageClass.parameters</code>:</p>
<ul>
<li><code>csi.storage.k8s.io/node-stage-secret-name</code></li>
<li><code>csi.storage.k8s.io/node-stage-secret-namespace</code></li>
</ul>
<p>The value of both parameters, together, refer to the name and namespace of the <code>Secret</code> object in the Kubernetes API.</p>
<p>If specified, the CSI <code>external-provisioner</code> sets the <code>CSIPersistentVolumeSource.NodeStageSecretRef</code> field in the new <code>PersistentVolume</code> object to refer to this secret once provisioning is successful.</p>
<p>The Kubernetes kubelet then attempts to fetch the secret referenced by the <code>CSIPersistentVolumeSource.NodeStageSecretRef</code> field, if specified, before a mount device operation.</p>
<p>If no such secret exists in the Kubernetes API, or the kubelet is unable to fetch it, the mount device operation fails.</p>
<p>If the secret is retrieved successfully, the kubelet passes it to the CSI driver in the <code>NodeStageVolumeRequest.secrets</code> field.</p>
<p>The values of these parameters may be &quot;templates&quot;. The <code>external-provisioner</code> will automatically resolve templates at volume provision time, as detailed below:</p>
<ul>
<li><code>csi.storage.k8s.io/node-stage-secret-name</code>
<ul>
<li><code>${pv.name}</code>
<ul>
<li>Replaced with name of the <code>PersistentVolume</code> object being provisioned.</li>
</ul>
</li>
<li><code>${pvc.namespace}</code>
<ul>
<li>Replaced with namespace of the <code>PersistentVolumeClaim</code> object that triggered provisioning.</li>
</ul>
</li>
<li><code>${pvc.name}</code>
<ul>
<li>Replaced with the name of the <code>PersistentVolumeClaim</code> object that triggered provisioning.</li>
</ul>
</li>
<li><code>${pvc.annotations['&lt;ANNOTATION_KEY&gt;']}</code> (e.g. <code>${pvc.annotations['example.com/key']}</code>)
<ul>
<li>Replaced with the value of the specified annotation from the <code>PersistentVolumeClaim</code> object that triggered provisioning</li>
</ul>
</li>
</ul>
</li>
<li><code>csi.storage.k8s.io/node-stage-secret-namespace</code>
<ul>
<li><code>${pv.name}</code>
<ul>
<li>Replaced with name of the <code>PersistentVolume</code> object being provisioned.</li>
</ul>
</li>
<li><code>${pvc.namespace}</code>
<ul>
<li>Replaced with namespace of the <code>PersistentVolumeClaim</code> object that triggered provisioning.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#node-publish-secret" id="node-publish-secret">Node Publish Secret</a></h3>
<p>The CSI <code>external-provisioner</code> (v1.0.1+) looks for the following keys in <code>StorageClass.parameters</code>:</p>
<ul>
<li><code>csi.storage.k8s.io/node-publish-secret-name</code></li>
<li><code>csi.storage.k8s.io/node-publish-secret-namespace</code></li>
</ul>
<p>The value of both parameters, together, refer to the name and namespace of the <code>Secret</code> object in the Kubernetes API.</p>
<p>If specified, the CSI <code>external-provisioner</code> sets the <code>CSIPersistentVolumeSource.NodePublishSecretRef</code> field in the new <code>PersistentVolume</code> object to refer to this secret once provisioning is successful.</p>
<p>The Kubernetes kubelet, attempts to fetch the secret referenced by the <code>CSIPersistentVolumeSource.NodePublishSecretRef</code> field, if specified, before a mount operation.</p>
<p>If no such secret exists in the Kubernetes API, or the kubelet is unable to fetch it, the mount operation fails.</p>
<p>If the secret is retrieved successfully, the kubelet passes it to the CSI driver in the <code>NodePublishVolumeRequest.secrets</code> field.</p>
<p>The values of these parameters may be &quot;templates&quot;. The <code>external-provisioner</code> will automatically resolve templates at volume provision time, as detailed below:</p>
<ul>
<li><code>csi.storage.k8s.io/node-publish-secret-name</code>
<ul>
<li><code>${pv.name}</code>
<ul>
<li>Replaced with name of the <code>PersistentVolume</code> object being provisioned.</li>
</ul>
</li>
<li><code>${pvc.namespace}</code>
<ul>
<li>Replaced with namespace of the <code>PersistentVolumeClaim</code> object that triggered provisioning.</li>
</ul>
</li>
<li><code>${pvc.name}</code>
<ul>
<li>Replaced with the name of the <code>PersistentVolumeClaim</code> object that triggered provisioning.</li>
</ul>
</li>
<li><code>${pvc.annotations['&lt;ANNOTATION_KEY&gt;']}</code> (e.g. <code>${pvc.annotations['example.com/key']}</code>)
<ul>
<li>Replaced with the value of the specified annotation from the <code>PersistentVolumeClaim</code> object that triggered provisioning</li>
</ul>
</li>
</ul>
</li>
<li><code>csi.storage.k8s.io/node-publish-secret-namespace</code>
<ul>
<li><code>${pv.name}</code>
<ul>
<li>Replaced with name of the <code>PersistentVolume</code> object being provisioned.</li>
</ul>
</li>
<li><code>${pvc.namespace}</code>
<ul>
<li>Replaced with namespace of the <code>PersistentVolumeClaim</code> object that triggered provisioning.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#controller-expand-volume-resize-secret" id="controller-expand-volume-resize-secret">Controller Expand (Volume Resize) Secret</a></h3>
<p>The CSI <code>external-provisioner</code> (v1.2.0+) looks for the following keys in <code>StorageClass.parameters</code>:</p>
<ul>
<li><code>csi.storage.k8s.io/controller-expand-secret-name</code></li>
<li><code>csi.storage.k8s.io/controller-expand-secret-namespace</code></li>
</ul>
<p>The value of both parameters, together, refer to the name and namespace of the <code>Secret</code> object in the Kubernetes API.</p>
<p>If specified, the CSI <code>external-provisioner</code> sets the <code>CSIPersistentVolumeSource.ControllerExpandSecretRef</code> field in the new <code>PersistentVolume</code> object to refer to this secret once provisioning is successful.</p>
<p>The <code>external-resizer</code> (v0.2.0+), attempts to fetch the secret referenced by the <code>CSIPersistentVolumeSource.ControllerExpandSecretRef</code> field, if specified, before starting a volume resize (expand) operation.</p>
<p>If no such secret exists in the Kubernetes API, or the <code>external-resizer</code> is unable to fetch it, the resize (expand) operation fails.</p>
<p>If the secret is retrieved successfully, the <code>external-resizer</code> passes it to the CSI driver in the <code>ControllerExpandVolumeRequest.secrets</code> field.</p>
<p>The values of these parameters may be &quot;templates&quot;. The <code>external-provisioner</code> will automatically resolve templates at volume provision time, as detailed below:</p>
<ul>
<li><code>csi.storage.k8s.io/controller-expand-secret-name</code>
<ul>
<li><code>${pv.name}</code>
<ul>
<li>Replaced with name of the <code>PersistentVolume</code> object being provisioned.</li>
</ul>
</li>
<li><code>${pvc.namespace}</code>
<ul>
<li>Replaced with namespace of the <code>PersistentVolumeClaim</code> object that triggered provisioning.</li>
</ul>
</li>
<li><code>${pvc.name}</code>
<ul>
<li>Replaced with the name of the <code>PersistentVolumeClaim</code> object that triggered provisioning.</li>
</ul>
</li>
<li><code>${pvc.annotations['&lt;ANNOTATION_KEY&gt;']}</code> (e.g. <code>${pvc.annotations['example.com/key']}</code>)
<ul>
<li>Replaced with the value of the specified annotation from the <code>PersistentVolumeClaim</code> object that triggered provisioning</li>
</ul>
</li>
</ul>
</li>
<li><code>csi.storage.k8s.io/controller-expand-secret-namespace</code>
<ul>
<li><code>${pv.name}</code>
<ul>
<li>Replaced with name of the <code>PersistentVolume</code> object being provisioned.</li>
</ul>
</li>
<li><code>${pvc.namespace}</code>
<ul>
<li>Replaced with namespace of the <code>PersistentVolumeClaim</code> object that triggered provisioning.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#volumesnapshotclass-secrets" id="volumesnapshotclass-secrets">VolumeSnapshotClass Secrets</a></h1>
<p>The CSI <a href="external-snapshotter.html">external-snapshotter</a> sidecar container facilitates the handling of secrets for the following operations:</p>
<ul>
<li><code>CreateSnapshotRequest</code></li>
<li><code>DeleteSnapshotRequest</code></li>
</ul>
<p>CSI <code>external-snapshotter</code> v1.0.1+ supports the following keys in <code>VolumeSnapshotClass.parameters</code>:</p>
<ul>
<li><code>csi.storage.k8s.io/snapshotter-secret-name</code></li>
<li><code>csi.storage.k8s.io/snapshotter-secret-namespace</code></li>
</ul>
<p>Cluster admins can populate the secret fields for the operations listed above with data from Kubernetes <code>Secret</code> objects by specifying these keys in the <code>VolumeSnapshotClass</code> object.</p>
<h2><a class="header" href="#operations-1" id="operations-1">Operations</a></h2>
<p>Details for each secret supported by the external-snapshotter can be found below.</p>
<h3><a class="header" href="#createdelete-volumesnapshot-secret" id="createdelete-volumesnapshot-secret">Create/Delete VolumeSnapshot Secret</a></h3>
<p>CSI <code>external-snapshotter</code> v1.0.1+ looks for the following keys in <code>VolumeSnapshotClass.parameters</code>:</p>
<ul>
<li><code>csi.storage.k8s.io/snapshotter-secret-name</code></li>
<li><code>csi.storage.k8s.io/snapshotter-secret-namespace</code></li>
</ul>
<p>The values of both of these parameters, together, refer to the name and namespace of a <code>Secret</code> object in the Kubernetes API.</p>
<p>If specified, the CSI <code>external-snapshotter</code> will attempt to fetch the secret before creation and deletion.</p>
<p>If the secret is retrieved successfully, the snapshotter passes it to the CSI driver in the <code>CreateSnapshotRequest.secrets</code> or <code>DeleteSnapshotRequest.secrets</code> field.</p>
<p>If no such secret exists in the Kubernetes API, or the snapshotter is unable to fetch it, the create operation will fail.</p>
<p>Note, however, that the delete operation will continue even if the secret is not found (because, for example, the entire namespace containing the secret was deleted). In this case, if the driver requires a secret for deletion, then the volume and PV may need to be manually cleaned up.</p>
<p>The values of these parameters may be &quot;templates&quot;. The <code>external-snapshotter</code> will automatically resolve templates at snapshot create time, as detailed below:</p>
<ul>
<li><code>csi.storage.k8s.io/snapshotter-secret-name</code>
<ul>
<li><code>${volumesnapshotcontent.name}</code>
<ul>
<li>Replaced with name of the <code>VolumeSnapshotContent</code> object being created.</li>
</ul>
</li>
<li><code>${volumesnapshot.namespace}</code>
<ul>
<li>Replaced with namespace of the <code>VolumeSnapshot</code> object that triggered creation.</li>
</ul>
</li>
<li><code>${volumesnapshot.name}</code>
<ul>
<li>Replaced with the name of the <code>VolumeSnapshot</code> object that triggered creation.</li>
</ul>
</li>
</ul>
</li>
<li><code>csi.storage.k8s.io/snapshotter-secret-namespace</code>
<ul>
<li><code>${volumesnapshotcontent.name}</code>
<ul>
<li>Replaced with name of the <code>VolumeSnapshotContent</code> object being created.</li>
</ul>
</li>
<li><code>${volumesnapshot.namespace}</code>
<ul>
<li>Replaced with namespace of the <code>VolumeSnapshot</code> object that triggered creation.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#csi-topology-feature" id="csi-topology-feature">CSI Topology Feature</a></h1>
<h2><a class="header" href="#status-2" id="status-2">Status</a></h2>
<table><thead><tr><th>Status</th><th>Min K8s Version</th><th>Max K8s Version</th><th>external-provisioner Version</th></tr></thead><tbody>
<tr><td>Alpha</td><td>1.12</td><td>1.12</td><td>0.4</td></tr>
<tr><td>Alpha</td><td>1.13</td><td>1.13</td><td>1.0</td></tr>
<tr><td>Beta</td><td>1.14</td><td>1.16</td><td>1.1-1.4</td></tr>
<tr><td>GA</td><td>1.17</td><td>-</td><td>1.5+</td></tr>
</tbody></table>
<h2><a class="header" href="#overview" id="overview">Overview</a></h2>
<p>Some storage systems expose volumes that are not equally accessible by all nodes in a Kubernetes cluster. Instead volumes may be constrained to some subset of node(s) in the cluster. The cluster may be segmented into, for example, “racks” or “regions” and “zones” or some other grouping, and a given volume may be accessible only from one of those groups.</p>
<p>To enable orchestration systems, like Kubernetes, to work well with storage systems which expose volumes that are not equally accessible by all nodes, the <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md">CSI spec</a> enables:</p>
<ol>
<li>Ability for a CSI Driver to opaquely specify where a particular node exists (e.g. &quot;node A&quot; is in &quot;zone 1&quot;).</li>
<li>Ability for Kubernetes (users or components) to influence where a volume is provisioned (e.g. provision new volume in either &quot;zone 1&quot; or &quot;zone 2&quot;).</li>
<li>Ability for a CSI Driver to opaquely specify where a particular volume exists (e.g. &quot;volume X&quot; is accessible by all nodes in &quot;zone 1&quot; and &quot;zone 2&quot;).</li>
</ol>
<p>Kubernetes and the <a href="external-provisioner.html">external-provisioner</a> use these abilities to make intelligent scheduling and provisioning decisions (that Kubernetes can both influence and act on topology information for each volume),</p>
<h2><a class="header" href="#implementing-topology-in-your-csi-driver" id="implementing-topology-in-your-csi-driver">Implementing Topology in your CSI Driver</a></h2>
<p>To support topology in a CSI driver, the following must be implemented:</p>
<ul>
<li>The <code>PluginCapability</code> must support <code>VOLUME_ACCESSIBILITY_CONTRAINTS</code>.</li>
<li>The plugin must fill in <code>accessible_topology</code> in <code>NodeGetInfoResponse</code>.
This information will be used to populate the Kubernetes <a href="csi-node-object.html">CSINode object</a> and add the topology labels to the Node object.</li>
<li>During <code>CreateVolume</code>, the topology information will get passed in through <code>CreateVolumeRequest.accessibility_requirements</code>.</li>
</ul>
<p>In the StorageClass object, both <code>volumeBindingMode</code> values of <code>Immediate</code> and
<code>WaitForFirstConsumer</code> are supported.</p>
<ul>
<li>If <code>Immediate</code> is set, then the
external-provisioner will pass in all available topologies in the cluster for
the driver.</li>
<li>If <code>WaitForFirstConsumer</code> is set, then the external-provisioner will wait for
the scheduler to pick a node. The topology of that selected node will then be
set as the first entry in <code>CreateVolumeRequest.accessibility_requirements.preferred</code>.
All remaining topologies are still included in the <code>requisite</code> and <code>preferred</code>
fields to support storage systems that span across multiple topologies.</li>
</ul>
<h2><a class="header" href="#sidecar-deployment" id="sidecar-deployment">Sidecar Deployment</a></h2>
<p>The topology feature requires the
<a href="external-provisioner.html">external-provisioner</a> sidecar with the
Topology feature gate enabled:</p>
<pre><code>--feature-gates=Topology=true
</code></pre>
<h2><a class="header" href="#kubernetes-cluster-setup" id="kubernetes-cluster-setup">Kubernetes Cluster Setup</a></h2>
<h3><a class="header" href="#beta" id="beta">Beta</a></h3>
<p>In the <em>Kubernetes cluster</em> the <code>CSINodeInfo</code> feature must be enabled on both Kubernetes master and nodes (refer to the <a href="csi-node-object.html">CSINode Object</a> section for more info):</p>
<pre><code>--feature-gates=CSINodeInfo=true
</code></pre>
<p>In order to fully function properly, all Kubernetes master and nodes must be on at least
Kubernetes 1.14. If a selected node is on a lower version, topology is ignored and not
passed to the driver during <code>CreateVolume</code>.</p>
<h3><a class="header" href="#alpha" id="alpha">Alpha</a></h3>
<p>The alpha feature in the external-provisioner is not compatible across
Kubernetes versions. In addition, Kubernetes master and node version skew and
upgrades are not supported.</p>
<p>The <code>CSINodeInfo</code>, <code>VolumeScheduling</code>, and <code>KubeletPluginsWatcher</code> feature gates
must be enabled on both Kubernetes master and nodes.</p>
<p>The <a href="csi-node-object.html">CSINodeInfo</a> CRDs also have to be manually installed in the
cluster.</p>
<h2><a class="header" href="#storage-internal-topology" id="storage-internal-topology">Storage Internal Topology</a></h2>
<p>Note that a storage system may also have an &quot;internal topology&quot; different from (independent of) the topology of the cluster where workloads are scheduled. Meaning volumes exposed by the storage system are equally accessible by all nodes in the Kubernetes cluster, but the storage system has some internal topology that may influence, for example, the performance of a volume from a given node.</p>
<p>CSI does not currently expose a first class mechanism to influence such storage system internal topology on provisioning. Therefore, Kubernetes can not programmatically influence such topology. However, a CSI Driver may expose the ability to specify internal storage topology during volume provisioning using an opaque parameter in the <code>CreateVolume</code> CSI call (CSI enables CSI Drivers to expose an arbitrary set of configuration options during dynamic provisioning by allowing opaque parameters to be passed from cluster admins to the storage plugins) -- this would enable cluster admins to be able to control the storage system internal topology during provisioning.</p>
<p>﻿# Raw Block Volume Feature</p>
<h2><a class="header" href="#status-3" id="status-3">Status</a></h2>
<table><thead><tr><th>Status</th><th>Min K8s Version</th><th>Max K8s Version</th><th>external-provisioner Version</th><th>external-attacher Version</th></tr></thead><tbody>
<tr><td>Alpha</td><td>1.11</td><td>1.13</td><td>0.4</td><td>0.4</td></tr>
<tr><td>Alpha</td><td>1.13</td><td>1.13</td><td>1.0</td><td>1.0</td></tr>
<tr><td>Beta</td><td>1.14</td><td>-</td><td>1.1+</td><td>1.1+</td></tr>
</tbody></table>
<h2><a class="header" href="#overview-1" id="overview-1">Overview</a></h2>
<p>This page documents how to implement raw block volume support to a CSI Driver.</p>
<p>A <em>block volume</em> is a volume that will appear as a block device inside the container.
A <em>mounted (file) volume</em> is volume that will be mounted using a specified file system and appear as a directory inside the container.</p>
<p>The <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md">CSI spec</a> supports both block and mounted (file) volumes.</p>
<h2><a class="header" href="#implementing-raw-block-volume-support-in-your-csi-driver" id="implementing-raw-block-volume-support-in-your-csi-driver">Implementing Raw Block Volume Support in Your CSI Driver</a></h2>
<p>CSI doesn't provide a capability query for block volumes, so COs will simply pass through requests for
block volume creation to CSI plugins, and plugins are allowed to fail with the <code>InvalidArgument</code> GRPC
error code if they don't support block volumes. Kubernetes doesn't make any assumptions about which CSI
plugins support blocks and which don't, so users have to know if any given storage class is capable of
creating block volumes.</p>
<p>The difference between a request for a mounted (file) volume and a block volume is the <code>VolumeCapabilities</code>
field of the request. Note that this field is an array and the created volume must support ALL of the
capabilities requested, or else return an error. If the <code>AccessType</code> method of a <code>VolumeCapability</code>
<code>VolumeCapability_Block</code>, then the capability is requesting a raw block volume. Unlike mount volumes, block
volumes don't have any specific capabilities that need to be validated, although access modes still
apply.</p>
<p>Block volumes are much more likely to support multi-node flavors of <code>VolumeCapability_AccessMode_Mode</code>
than mount volumes, because there's no file system state stored on the node side that creates any technical
impediments to multi-attaching block volumes. While there may still be good reasons to prevent
multi-attaching block volumes, and there may be implementations that are not capable of supporting
multi-attach, you should think carefully about what makes sense for your driver.</p>
<p>CSI plugins that support both mount and block volumes must be sure to check the capabilities of all CSI RPC
requests and ensure that the capability of the request matches the capability of the volume, to avoid trying
to do file-system-related things to block volumes and block-related things to file system volumes. The
following RPCs specify capabilities that must be validated:</p>
<ul>
<li><code>CreateVolume()</code> (multiple capabilities)</li>
<li><code>ControllerPublishVolume()</code></li>
<li><code>ValidateVolumeCapabilities()</code> (multiple capabilities)</li>
<li><code>GetCapacity()</code> (see below)</li>
<li><code>NodeStageVolume()</code></li>
<li><code>NodePublishVolume()</code></li>
</ul>
<p>Also, CSI plugins that implement the optional <code>GetCapacity()</code> RPC should note that that RPC includes
capabilities too, and if the capacity for mount volumes is not the same as the capacity for block
volumes, that needs to be handled in the implementation of that RPC.</p>
<p>Q: Can CSI plugins support only block volumes and not mount volumes?
A: Yes! This is just the reverse case of supporting mount volumes only. Plugins may return <code>InvalidArgument</code>
for any creation request with an <code>AccessType</code> of <code>VolumeCapability_Mount</code>.</p>
<h2><a class="header" href="#differences-between-block-and-mount-volumes" id="differences-between-block-and-mount-volumes">Differences Between Block and Mount Volumes</a></h2>
<p>The main difference between block volumes and mount volumes is the expected result of the <code>NodePublish()</code>.
For mount volumes, the CO expects the result to be a mounted directory, at <code>TargetPath</code>. For block volumes,
the CO expects there to be a device file at <code>TargetPath</code>. The device file can by a bind-mounted device from
the hosts <code>/dev</code> file system, or it can be a device node created at that location using <code>mknod()</code>.</p>
<p>It's desirable but not required to expose an unfiltered device node. For example, CSI plugins based on
technologies that implement SCSI protocols should expect that pods consuming the block volumes they create
may want to send SCSI commands to the device. This is something that should &quot;just work&quot; by default (subject
to container capabilities) so CSI plugins should avoid anything that would break this kind of use case. The
only hard requirement is that the device implements block reading/writing however.</p>
<p>For plugins with the <code>RPC_STAGE_UNSTAGE_VOLUME</code> capability, the CO doesn't care exactly what is placed at
the <code>StagingTargetPath</code>, but it's worth noting that some CSI RPCs are allowed to pass the plugin either
a staging path or a publish path, so it's important to think carefully about how <code>NodeStageVolume()</code> is
implemented, knowing that either path could get used by the CO to refer to the volume later on. This is
made more challenging because the CSI spec says that <code>StagingTargetPath</code> is always a directory even for
block volumes.</p>
<h2><a class="header" href="#sidecar-deployment-1" id="sidecar-deployment-1">Sidecar Deployment</a></h2>
<p>The raw block feature requires the
<a href="external-provisioner.html">external-provisioner</a> and
<a href="external-attacher.html">external-attacher</a> sidecars to be deployed.</p>
<h2><a class="header" href="#kubernetes-cluster-setup-1" id="kubernetes-cluster-setup-1">Kubernetes Cluster Setup</a></h2>
<p>The <code>BlockVolume</code> and <code>CSIBlockVolume</code> feature gates need to be enabled on
all Kubernetes masters and nodes.</p>
<pre><code>--feature-gates=BlockVolume=true,CSIBlockVolume=true...
</code></pre>
<ul>
<li>TODO: detail how Kubernetes API raw block fields get mapped to CSI methods/fields.</li>
</ul>
<h1><a class="header" href="#skip-kubernetes-attach-and-detach" id="skip-kubernetes-attach-and-detach">Skip Kubernetes Attach and Detach</a></h1>
<h2><a class="header" href="#status-4" id="status-4">Status</a></h2>
<table><thead><tr><th>Status</th><th>Min K8s Version</th><th>Max K8s Version</th><th>cluster-driver-registrar Version</th></tr></thead><tbody>
<tr><td>Alpha</td><td>1.12</td><td>1.12</td><td>0.4</td></tr>
<tr><td>Alpha</td><td>1.13</td><td>1.13</td><td>1.0</td></tr>
<tr><td>Beta</td><td>1.14</td><td>1.17</td><td>n/a</td></tr>
<tr><td>GA</td><td>1.18</td><td>-</td><td>n/a</td></tr>
</tbody></table>
<h1><a class="header" href="#overview-2" id="overview-2">Overview</a></h1>
<p>Volume drivers, like NFS, for example, have no concept of an attach (<code>ControllerPublishVolume</code>). However, Kubernetes always executes <code>Attach</code> and <code>Detach</code> operations even if the CSI driver does not implement an attach operation (i.e. even if the CSI Driver does not implement a <code>ControllerPublishVolume</code> call).</p>
<p>This was problematic because it meant <em>all</em> CSI drivers had to handle Kubernetes attachment. CSI Drivers that did not implement the <code>PUBLISH_UNPUBLISH_VOLUME</code> controller capability could work around this by deploying an <a href="external-attacher.html">external-attacher</a> and the <code>external-attacher</code> would responds to Kubernetes attach operations and simply do a noop (because the CSI driver did not advertise the <code>PUBLISH_UNPUBLISH_VOLUME</code> controller capability).</p>
<p>Although the workaround works, it adds an unnecessary operation (round-trip) in the preparation of a volume for a container, and requires CSI Drivers to deploy an unnecessary sidecar container (<code>external-attacher</code>).</p>
<h1><a class="header" href="#skip-attach-with-csi-driver-object" id="skip-attach-with-csi-driver-object">Skip Attach with CSI Driver Object</a></h1>
<p>The <a href="csi-driver-object.html">CSIDriver Object</a> enables CSI Drivers to specify how Kubernetes should interact with it.</p>
<p>Specifically the <code>attachRequired</code> field instructs Kubernetes to skip any attach operation altogether.</p>
<p>For example, the existence of the following object would cause Kubernetes to skip attach operations for all CSI Driver <code>testcsidriver.example.com</code> volumes.</p>
<pre><code>apiVersion: storage.k8s.io/v1
kind: CSIDriver
metadata:
  name: testcsidriver.example.com
spec:
  attachRequired: false
</code></pre>
<p>CSIDriver object should be manually included in the driver deployment manifests.</p>
<p>Previously, the <a href="cluster-driver-registrar.html">cluster-driver-registrar</a> sidecar container could be deployed to automatically create the object. Once the flags to this container are configured correctly, it will automatically create a <a href="csi-driver-object.html">CSIDriver Object</a> when it starts with the correct fields set.</p>
<h2><a class="header" href="#alpha-functionality" id="alpha-functionality">Alpha Functionality</a></h2>
<p>In alpha, this feature was enabled via the <a href="csi-driver-object.html">CSIDriver Object</a> CRD.</p>
<pre><code>apiVersion: csi.storage.k8s.io/v1alpha1
kind: CSIDriver
metadata:
....
</code></pre>
<h1><a class="header" href="#pod-info-on-mount" id="pod-info-on-mount">Pod Info on Mount</a></h1>
<h1><a class="header" href="#status-5" id="status-5">Status</a></h1>
<table><thead><tr><th>Status</th><th>Min K8s Version</th><th>Max K8s Version</th><th>cluster-driver-registrar Version</th></tr></thead><tbody>
<tr><td>Alpha</td><td>1.12</td><td>1.12</td><td>0.4</td></tr>
<tr><td>Alpha</td><td>1.13</td><td>1.13</td><td>1.0</td></tr>
<tr><td>Beta</td><td>1.14</td><td>1.17</td><td>n/a</td></tr>
<tr><td>GA</td><td>1.18</td><td>-</td><td>n/a</td></tr>
</tbody></table>
<h1><a class="header" href="#overview-3" id="overview-3">Overview</a></h1>
<p>CSI avoids encoding Kubernetes specific information in to the specification, since it aims to support multiple orchestration systems (beyond just Kubernetes).</p>
<p>This can be problematic because some CSI drivers require information about the workload (e.g. which pod is referencing this volume), and CSI does not provide this information natively to drivers.</p>
<h1><a class="header" href="#pod-info-on-mount-with-csi-driver-object" id="pod-info-on-mount-with-csi-driver-object">Pod Info on Mount with CSI Driver Object</a></h1>
<p>The <a href="csi-driver-object.html">CSIDriver Object</a> enables CSI Drivers to specify how Kubernetes should interact with it.</p>
<p>Specifically the <code>podInfoOnMount</code> field instructs Kubernetes that the CSI driver requires additional pod information (like podName, podUID, etc.) during mount operations.</p>
<p>For example, the existence of the following object would cause Kubernetes to add pod information at mount time to the <code>NodePublishVolumeRequest.volume_context</code> map.</p>
<pre><code>apiVersion: storage.k8s.io/v1
kind: CSIDriver
metadata:
  name: testcsidriver.example.com
spec:
  podInfoOnMount: true
</code></pre>
<p>If the <code>podInfoOnMount</code> field is set to <code>true</code>, during mount, Kubelet will add the following key/values to the <code>volume_context</code> field in the CSI <code>NodePublishVolumeRequest</code>:</p>
<ul>
<li><code>csi.storage.k8s.io/pod.name: {pod.Name}</code></li>
<li><code>csi.storage.k8s.io/pod.namespace: {pod.Namespace}</code></li>
<li><code>csi.storage.k8s.io/pod.uid: {pod.UID}</code></li>
<li><code>csi.storage.k8s.io/serviceAccount.name: {pod.Spec.ServiceAccountName}</code></li>
</ul>
<p>The CSIDriver object should be manually included in the driver manifests.</p>
<p>Previously, the <a href="cluster-driver-registrar.html">cluster-driver-registrar</a> sidecar container could be used to create the object. Once the flags to this container are configured correctly, it will automatically create a <a href="csi-driver-object.html">CSIDriver Object</a> when it starts with the correct fields set.</p>
<h2><a class="header" href="#alpha-functionality-1" id="alpha-functionality-1">Alpha Functionality</a></h2>
<p>In alpha, this feature was enabled by setting the <code>podInfoOnMountVersion</code> field in the <code>CSIDriver</code> Object CRD to to <code>v1</code>.</p>
<pre><code>apiVersion: csi.storage.k8s.io/v1alpha1
kind: CSIDriver
metadata:
  name: testcsidriver.example.com
spec:
  podInfoOnMountVersion: v1
</code></pre>
<h1><a class="header" href="#volume-expansion" id="volume-expansion">Volume Expansion</a></h1>
<h2><a class="header" href="#status-6" id="status-6">Status</a></h2>
<table><thead><tr><th>Status</th><th>Min K8s Version</th><th>Max K8s Version</th><th>external-resizer Version</th></tr></thead><tbody>
<tr><td>Alpha</td><td>1.14</td><td>1.15</td><td>0.2</td></tr>
<tr><td>Beta</td><td>1.16</td><td>-</td><td>0.3</td></tr>
</tbody></table>
<h2><a class="header" href="#overview-4" id="overview-4">Overview</a></h2>
<p>A storage provider that allows volume expansion after creation, may choose to implement volume expansion either via a
control-plane CSI RPC call or via node CSI RPC call or both as a two step process.</p>
<h2><a class="header" href="#implementing-volume-expansion-functionality" id="implementing-volume-expansion-functionality">Implementing Volume expansion functionality</a></h2>
<p>To implement volume expansion the CSI driver MUST:</p>
<ol>
<li>Implement <code>VolumeExpansion</code> plugin capability.</li>
<li>Implement <code>EXPAND_VOLUME</code> controller capability or implement <code>EXPAND_VOLUME</code> node capability or both.</li>
</ol>
<p><code>ControllerExpandVolume</code> RPC call can be made when volume is <code>ONLINE</code> or <code>OFFLINE</code> depending on <code>VolumeExpansion</code> plugin
capability. Where <code>ONLINE</code> and <code>OFFLINE</code> means:</p>
<ol>
<li><em>ONLINE</em> : Volume is currently published or available on a node.</li>
<li><em>OFFLINE</em> : Volume is currently not published or available on a node.</li>
</ol>
<p><code>NodeExpandVolume</code> RPC call on the other hand - <em>always</em> requires volume to be published or staged on a node (and hence <code>ONLINE</code>).
For block storage file systems - <code>NodeExpandVolume</code> is typically used for expanding the file system on the node, but it can be also
used to perform other volume expansion related housekeeping operations on the node.</p>
<p>For details, see the <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md">CSI spec</a>.</p>
<h2><a class="header" href="#deploying-volume-expansion-functionality" id="deploying-volume-expansion-functionality">Deploying volume expansion functionality</a></h2>
<p>The Kubernetes CSI development team maintains <a href="external-resizer.html">external-resizer</a> Kubernetes CSI <a href="sidecar-containers.html">Sidecar Containers</a>.
This sidecar container implements the logic for watching the Kubernetes API for Persistent Volume claim edits and issuing <code>ControllerExpandVolume</code> RPC call against a CSI endpoint and updating <code>PersistentVolume</code> object to reflect new size.</p>
<p>This sidecar is needed even if CSI driver does not have <code>EXPAND_VOLUME</code> controller capability, in this case it performs a NO-OP expansion and updates <code>PersistentVolume</code> object. <code>NodeExpandVolume</code> is always called by Kubelet on the node.</p>
<p>For more details, see <a href="external-resizer.html">external-resizer</a>.</p>
<h2><a class="header" href="#enabling-volume-expansion-for-csi-volumes-in-kubernetes" id="enabling-volume-expansion-for-csi-volumes-in-kubernetes">Enabling Volume expansion for CSI volumes in Kubernetes</a></h2>
<p>To expand a volume if permitted by the <a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#expanding-persistent-volumes-claims">storage class</a>, users just need to edit the persistent volume claim object and request more storage.</p>
<p>In Kubernetes 1.14 and 1.15, this feature was in alpha status and required enabling the following feature gate:</p>
<pre><code>--feature-gates=ExpandCSIVolumes=true
</code></pre>
<p>Also in Kubernetes 1.14 and 1.15, online expansion had to be enabled explicitly:</p>
<pre><code>--feature-gates=ExpandInUsePersistentVolumes=true
</code></pre>
<p>external-resizer and kubelet add appropriate events and conditions to persistent volume claim objects indicating progress of volume expansion operations.</p>
<h2><a class="header" href="#kubernetes-pvc-datasource-csi-volumecontentsource" id="kubernetes-pvc-datasource-csi-volumecontentsource">Kubernetes PVC DataSource (CSI VolumeContentSource)</a></h2>
<p>When creating a new PersistentVolumeClaim, the Kubernetes API provides a <code>PersistentVolumeClaim.DataSource</code> parameter.  This parameter is used to specify the CSI <code>CreateVolumeRequest.VolumeContentSource</code> option for CSI Provisioners. The <code>VolumeContentSource</code> parameter instructs the CSI plugin to pre-populate the volume being provisioned with data from the specified source. </p>
<h3><a class="header" href="#external-provisioner-responsibilities" id="external-provisioner-responsibilities">External Provisioner Responsibilities</a></h3>
<p>If a <code>DataSource</code> is specified in the <code>CreateVolume</code> call to the CSI external provisioner, the external provisioner will fetch the specified resource and pass the appropriate object id to the plugin.</p>
<h2><a class="header" href="#supported-datasources" id="supported-datasources">Supported DataSources</a></h2>
<p>Currently there are two types of <code>PersistentVolumeClaim.DataSource</code> objects that are supported:</p>
<ol>
<li><a href="snapshot-restore-feature.html">VolumeSnapshot</a></li>
<li><a href="volume-cloning.html">PersistentVolumeClaim (Cloning)</a></li>
</ol>
<h1><a class="header" href="#volume-cloning" id="volume-cloning">Volume Cloning</a></h1>
<h2><a class="header" href="#status-and-releases-8" id="status-and-releases-8">Status and Releases</a></h2>
<table><thead><tr><th>Status</th><th>Min k8s Version</th><th>Max k8s version</th><th>external-provisioner Version</th></tr></thead><tbody>
<tr><td>Alpha</td><td>1.15</td><td>1.15</td><td>1.3</td></tr>
<tr><td>Beta</td><td>1.16</td><td>-</td><td>1.4</td></tr>
</tbody></table>
<h2><a class="header" href="#overview-5" id="overview-5">Overview</a></h2>
<p>A Clone is defined as a duplicate of an existing Kubernetes Volume.  For more information on cloning in Kubernetes see the concepts doc for <a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#volume-cloning">Volume Cloning</a>.  A storage provider that allows volume cloning as a create feature, may choose to implement volume cloning via a control-plan CSI RPC call.</p>
<p>For details regarding the kuberentes API for volume cloning, please see <a href="https://kubernetes.io/docs/concepts/storage/volume-pvc-datasource/">kubernetes concepts</a>.</p>
<h2><a class="header" href="#implementing-volume-cloning-functionality" id="implementing-volume-cloning-functionality">Implementing Volume cloning functionality</a></h2>
<p>To implement volume cloning the CSI driver MUST:</p>
<ol>
<li>Implement checks for <code>csi.CreateVolumeRequest.VolumeContentSource</code> in the plugin's <code>CreateVolume</code> function implementation.</li>
<li>Implement <code>CLONE_VOLUME</code> controller capability.</li>
</ol>
<p>It is the responsibility of the storage plugin to either implement an expansion after clone if a provision request size is greater than the source, or allow the external-resizer to handle it.  In the case that the plugin does not support resize capability and it does not have the capability to create a clone that is greater in size than the specified source volume, then the provision request should result in a failure.</p>
<h2><a class="header" href="#deploying-volume-clone-functionality" id="deploying-volume-clone-functionality">Deploying volume clone functionality</a></h2>
<p>The Kubernetes CSI development team maintains the <a href="external-provisioner.html">external-provisioner</a> which is responsible for detecting requests for a PVC DataSource and providing that information to the plugin via the <code>csi.CreateVolumeRequest</code>.  It's up to the plugin to check the <code>csi.CreateVolumeRequest</code> for a <code>VolumeContentSource</code> entry in the CreateVolumeRequest object.</p>
<p>There are no additional side-cars or add on components required.</p>
<h2><a class="header" href="#enabling-cloning-for-csi-volumes-in-kubernetes" id="enabling-cloning-for-csi-volumes-in-kubernetes">Enabling Cloning for CSI volumes in Kubernetes</a></h2>
<p>In Kubernetes 1.15 this feature was alpha status and required enabling the appropriate feature gate:</p>
<pre><code>--feature-gates=VolumePVCDataSource=true
</code></pre>
<h2><a class="header" href="#example-implementation" id="example-implementation">Example implementation</a></h2>
<p>A trivial example implementation can be found in the <a href="https://github.com/kubernetes-csi/csi-driver-host-path">csi-hostpath plugin</a> in its implementation of <code>CreateVolume</code>.</p>
<h1><a class="header" href="#snapshot--restore-feature" id="snapshot--restore-feature">Snapshot &amp; Restore Feature</a></h1>
<h2><a class="header" href="#status-7" id="status-7">Status</a></h2>
<table><thead><tr><th>Status</th><th>Min K8s Version</th><th>Max K8s Version</th><th>snapshot-controller Version</th><th>CSI external-snapshotter sidecar Version</th><th>external-provisioner Version</th></tr></thead><tbody>
<tr><td>Alpha</td><td>1.12</td><td>1.12</td><td></td><td>0.4.0 &lt;= version &lt; 1.0</td><td>0.4.1 &lt;= version &lt; 1.0</td></tr>
<tr><td>Alpha</td><td>1.13</td><td>1.16</td><td></td><td>1.0.1 &lt;= version &lt; 2.0</td><td>1.0.1 &lt;= version &lt; 1.5</td></tr>
<tr><td>Beta</td><td>1.17</td><td>-</td><td>2.0+</td><td>2.0+</td><td>1.5+</td></tr>
</tbody></table>
<h2><a class="header" href="#overview-6" id="overview-6">Overview</a></h2>
<p>Many storage systems provide the ability to create a &quot;snapshot&quot; of a persistent volume. A snapshot represents a point-in-time copy of a volume. A snapshot can be used either to provision a new volume (pre-populated with the snapshot data) or to restore the existing volume to a previous state (represented by the snapshot).</p>
<p>Kubernetes CSI currently enables CSI Drivers to expose the following functionality via the Kubernetes API:</p>
<ol>
<li>Creation and deletion of volume snapshots via <a href="https://kubernetes.io/docs/concepts/storage/volume-snapshots/">Kubernetes native API</a>. </li>
<li>Creation of new volumes pre-populated with the data from a snapshot via Kubernetes <a href="https://kubernetes.io/docs/concepts/storage/dynamic-provisioning/">dynamic volume provisioning</a>.</li>
</ol>
<p>Note: Documentation under https://kubernetes.io/docs is for the latest Kubernetes release. Documentation for earlier releases are stored in different location. For example, this is the documentation location for <a href="https://v1-16.docs.kubernetes.io/docs/concepts/storage/volume-snapshots/">v1.16</a>.</p>
<h2><a class="header" href="#implementing-snapshot--restore-functionality-in-your-csi-driver" id="implementing-snapshot--restore-functionality-in-your-csi-driver">Implementing Snapshot &amp; Restore Functionality in Your CSI Driver</a></h2>
<p>To implement the snapshot feature, a CSI driver MUST:</p>
<ul>
<li>Implement the <code>CREATE_DELETE_SNAPSHOT</code> and, optionally, the <code>LIST_SNAPSHOTS</code> controller capabilities</li>
<li>Implement <code>CreateSnapshot</code>, <code>DeleteSnapshot</code>, and, optionally, the <code>ListSnapshots</code>, controller RPCs.</li>
</ul>
<p>For details,  see the <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md">CSI spec</a>.</p>
<h2><a class="header" href="#sidecar-deployment-2" id="sidecar-deployment-2">Sidecar Deployment</a></h2>
<p>The Kubernetes CSI development team maintains the <a href="external-snapshotter.html">external-snapshotter</a> Kubernetes CSI <a href="sidecar-containers.html">Sidecar Containers</a>. This sidecar container implements the logic for watching the Kubernetes API objects and issuing the appropriate CSI snapshot calls against a CSI endpoint. For more details, see <a href="external-snapshotter.html">external-snapshotter documentation</a>.</p>
<h2><a class="header" href="#snapshot-beta-1" id="snapshot-beta-1">Snapshot Beta</a></h2>
<h3><a class="header" href="#snapshot-apis" id="snapshot-apis">Snapshot APIs</a></h3>
<p>With the promotion of Volume Snapshot to beta, the feature is now enabled by default on standard Kubernetes deployments instead of being opt-in. This involves a revamp of volume snapshot APIs.</p>
<p>The schema definition for the custom resources (CRs) can be found <a href="https://github.com/kubernetes-csi/external-snapshotter/blob/release-2.0/pkg/apis/volumesnapshot/v1beta1/types.go">here</a>. The CRDs are no longer automatically deployed by the sidecar. They should be installed by the Kubernetes distributions.</p>
<h4><a class="header" href="#hightlights-in-the-snapshot-v1beta1-apis" id="hightlights-in-the-snapshot-v1beta1-apis">Hightlights in the snapshot v1beta1 APIs</a></h4>
<ul>
<li>DeletionPolicy is a required field in both VolumeSnapshotClass and VolumeSnapshotContent. This way the user has to explicitly specify it, leaving no room for confusion.</li>
<li>VolumeSnapshotSpec has a required Source field. Source may be either a PersistentVolumeClaimName (if dynamically provisioning a snapshot) or VolumeSnapshotContentName (if pre-provisioning a snapshot).</li>
<li>VolumeSnapshotContentSpec has a required Source field. This Source may be either a VolumeHandle (if dynamically provisioning a snapshot) or a SnapshotHandle (if pre-provisioning volume snapshots).</li>
<li>VolumeSnapshot contains a Status to indicate the current state of the volume snapshot. It has a field BoundVolumeSnapshotContentName to indicate the VolumeSnapshot object is bound to a VolumeSnapshotContent.</li>
<li>VolumeSnapshotContent contains a Status to indicate the current state of the volume snapshot content. It has a field SnapshotHandle to indicate that the VolumeSnapshotContent represents a snapshot on the storage system.</li>
</ul>
<h3><a class="header" href="#controller-split" id="controller-split">Controller Split</a></h3>
<ul>
<li>The CSI external-snapshotter sidecar is split into two controllers, a snapshot controller and a CSI external-snapshotter sidecar.</li>
</ul>
<p>The snapshot controller is deployed by the Kubernetes distributions and is responsible for watching the VolumeSnapshot CRD objects and manges the creation and deletion lifecycle of snapshots.</p>
<p>The CSI external-snapshotter sidecar watches Kubernetes VolumeSnapshotContent CRD objects and triggers CreateSnapshot/DeleteSnapshot against a CSI endpoint.</p>
<h3><a class="header" href="#kubernetes-cluster-setup-2" id="kubernetes-cluster-setup-2">Kubernetes Cluster Setup</a></h3>
<p>Volume snapshot is promoted to beta in Kubernetes 1.17 so the <code>VolumeSnapshotDataSource</code> feature gate is enabled by default.</p>
<p>See the Deployment section of <a href="snapshot-controller.html">Snapshot Controller</a> on how to set up the snapshot controller and CRDs.</p>
<h3><a class="header" href="#test-snapshot-feature" id="test-snapshot-feature">Test Snapshot Feature</a></h3>
<p>To test snapshot Beta version, use the following <a href="https://github.com/kubernetes-csi/external-snapshotter/tree/release-2.0/examples/kubernetes">example yaml files</a>.</p>
<p>Create a <em>StorageClass</em>:</p>
<pre><code>kubectl create -f storageclass.yaml
</code></pre>
<p>Create a <em>PVC</em>:</p>
<pre><code>kubectl create -f pvc.yaml
</code></pre>
<p>Create a <em>VolumeSnapshotClass</em>:</p>
<pre><code>kubectl create -f snapshotclass.yaml
</code></pre>
<p>Create a <em>VolumeSnapshot</em>:</p>
<pre><code>kubectl create -f snapshot.yaml
</code></pre>
<p>Create a <em>PVC</em> from a <em>VolumeSnapshot</em>:</p>
<pre><code>kuberctl create -f restore.yaml
</code></pre>
<h4><a class="header" href="#persistentvolumeclaim-not-bound" id="persistentvolumeclaim-not-bound">PersistentVolumeClaim not Bound</a></h4>
<p>If a <code>PersistentVolumeClaim</code> is not bound, the attempt to create a volume snapshot from that <code>PersistentVolumeClaim</code> will fail. No retries will be attempted. An event will be logged to indicate that the <code>PersistentVolumeClaim</code> is not bound.</p>
<p>Note that this could happen if the <code>PersistentVolumeClaim</code> spec and the <code>VolumeSnapshot</code> spec are in the same YAML file. In this case, when the <code>VolumeSnapshot</code> object is created, the <code>PersistentVolumeClaim</code> object is created but volume creation is not complete and therefore the <code>PersistentVolumeClaim</code> is not yet bound. You must wait until the <code>PersistentVolumeClaim</code> is bound and then create the snapshot.</p>
<p>Note: This behavior is planned to be changed as we are going to fix the timeout issue reported <a href="https://github.com/kubernetes-csi/external-snapshotter/issues/134">here</a>.</p>
<h2><a class="header" href="#snapshot-alpha-1" id="snapshot-alpha-1">Snapshot Alpha</a></h2>
<h3><a class="header" href="#snapshot-apis-1" id="snapshot-apis-1">Snapshot APIs</a></h3>
<p>Similar to the API for managing <a href="https://v1-16.docs.kubernetes.io/docs/concepts/storage/persistent-volumes/">Kubernetes Persistent Volumes</a>, the Kubernetes Volume Snapshots introduce three new API objects for managing snapshots: <code>VolumeSnapshot</code>, <code>VolumeSnapshotContent</code>, and <code>VolumeSnapshotClass</code>. See <a href="https://v1-16.docs.kubernetes.io/docs/concepts/storage/volume-snapshots/">Kubernetes Snapshot documentation</a> for more details.</p>
<p>Unlike the core Kubernetes Persistent Volume objects, these Snapshot objects are defined as <a href="https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/#create-a-customresourcedefinition">Custom Resource Definitions</a> (CRDs). This is because the Kubernetes project is moving away from having resource types pre-defined in the API server. This allows the API server to be reused for projects other than Kubernetes, and consumers (like Kubernetes) simply install the resource types they require as CRDs. Because the Snapshot API types are not built in to Kubernetes, they must be installed prior to use.</p>
<p>The CRDs are <a href="https://github.com/kubernetes-csi/external-snapshotter/blob/release-1.2/cmd/csi-snapshotter/create_crd.go#L29">automatically deployed</a> by the CSI external-snapshotter sidecar. See Alpha section of the sidecar doc <a href="external-snapshotter.html">here</a>.</p>
<p>The schema definition for the custom resources (CRs) can be found <a href="https://github.com/kubernetes-csi/external-snapshotter/blob/release-1.2/pkg/apis/volumesnapshot/v1alpha1/types.go">here</a>.</p>
<p>In addition to these new CRD objects, a new, alpha <code>DataSource</code> field has been added to the <code>PersistentVolumeClaim</code> object. This new field enables dynamic provisioning of new volumes that are automatically pre-populated with data from an existing snapshot.</p>
<h3><a class="header" href="#kubernetes-cluster-setup-3" id="kubernetes-cluster-setup-3">Kubernetes Cluster Setup</a></h3>
<p>Since volume snapshot is an alpha feature in Kubernetes v1.12 to v1.16, you need to enable a new alpha feature gate called <code>VolumeSnapshotDataSource</code> in the Kubernetes master.</p>
<pre><code>--feature-gates=VolumeSnapshotDataSource=true
</code></pre>
<h3><a class="header" href="#test-snapshot-feature-1" id="test-snapshot-feature-1">Test Snapshot Feature</a></h3>
<p>To test snapshot Alpha version, use the following <a href="https://github.com/kubernetes-csi/external-snapshotter/tree/release-1.2/examples/kubernetes">example yaml files</a>.</p>
<p>Create a <em>StorageClass</em>:</p>
<pre><code>kubectl create -f storageclass.yaml
</code></pre>
<p>Create a <em>PVC</em>:</p>
<pre><code>kubectl create -f pvc.yaml
</code></pre>
<p>Create a <em>VolumeSnapshotClass</em>:</p>
<pre><code>kubectl create -f snapshotclass.yaml
</code></pre>
<p>Create a <em>VolumeSnapshot</em>:</p>
<pre><code>kubectl create -f snapshot.yaml
</code></pre>
<p>Create a <em>PVC</em> from a <em>VolumeSnapshot</em>:</p>
<pre><code>kuberctl create -f restore.yaml
</code></pre>
<h4><a class="header" href="#persistentvolumeclaim-not-bound-1" id="persistentvolumeclaim-not-bound-1">PersistentVolumeClaim not Bound</a></h4>
<p>If a <code>PersistentVolumeClaim</code> is not bound, the attempt to create a volume snapshot from that <code>PersistentVolumeClaim</code> will fail. No retries will be attempted. An event will be logged to indicate that the <code>PersistentVolumeClaim</code> is not bound.</p>
<p>Note that this could happen if the <code>PersistentVolumeClaim</code> spec and the <code>VolumeSnapshot</code> spec are in the same YAML file. In this case, when the <code>VolumeSnapshot</code> object is created, the <code>PersistentVolumeClaim</code> object is created but volume creation is not complete and therefore the <code>PersistentVolumeClaim</code> is not yet bound. You must wait until the <code>PersistentVolumeClaim</code> is bound and then create the snapshot.</p>
<h2><a class="header" href="#examples-1" id="examples-1">Examples</a></h2>
<p>See the <a href="drivers.html">Drivers</a> for a list of CSI drivers that implement the snapshot feature.</p>
<h1><a class="header" href="#pod-inline-volume-support" id="pod-inline-volume-support">Pod Inline Volume Support</a></h1>
<h2><a class="header" href="#status-8" id="status-8">Status</a></h2>
<table><thead><tr><th>Status</th><th>Min K8s Version</th><th>Max K8s Version</th></tr></thead><tbody>
<tr><td>Alpha</td><td>1.15</td><td>1.15</td></tr>
<tr><td>Beta</td><td>1.16</td><td>-</td></tr>
</tbody></table>
<h2><a class="header" href="#overview-7" id="overview-7">Overview</a></h2>
<p>Traditionally, volumes that are backed by CSI drivers can only be used with a <code>PersistentVolume</code> and <code>PersistentVolumeClaim</code> object combination. This feature supports ephemeral storage use cases and allows CSI volumes to be specified directly in the pod specification.  At runtime, nested inline volumes follow the ephemeral lifecycle of their associated pods where the driver handles all phases of volume operations as pods are created and destroyed.</p>
<blockquote>
<p>See the <a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-storage/20190122-csi-inline-volumes.md">design document</a> for futher information.</p>
</blockquote>
<h3><a class="header" href="#example-of-inline-csi-pod-spec" id="example-of-inline-csi-pod-spec">Example of inline CSI pod spec</a></h3>
<p>A pod spec with an ephemeral inline CSI volume. Note that because the volume is expected to be ephemeral, the volumeHandle is not provided. Instead, an ID will be generated by kubelet as volume is mounted for pod use.  The generated ID is passed to the CSI driver at <code>NodePublish</code>.</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: some-pod
spec:
  containers:
    ...
  volumes:
      - name: vol
        csi:
          driver: inline.storage.kubernetes.io
          volumeAttributes:
              foo: bar
</code></pre>
<h2><a class="header" href="#implementing-inline-ephemeral-support" id="implementing-inline-ephemeral-support">Implementing inline ephemeral support</a></h2>
<p>Drivers must be modified (or implemented specifically) to support inline ephemeral workflows.  When Kubernetes encounters an inline CSI volume embedded in a pod spec, it treats that volume differently.  Mainly, the driver will only receive <code>NodePublish</code>, during the volume's mount phase, and <code>NodeUnpublish</code> when the pod is going away and the volume is unmounted.   To support inline, a driver must implement the followings:</p>
<ul>
<li>Identity service</li>
<li>Node service</li>
</ul>
<p>Kubernetes 1.16 only allows using a CSI driver for an inline volume if
its <a href="csi-driver-object.html"><code>CSIDriverInfo</code></a> object explicitly declares
that the driver supports that kind of usage in its
<code>volumeLifecycleModes</code> field. This is a safeguard against accidentally
<a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-storage/20190122-csi-inline-volumes.md#support-for-inline-csi-volumes">using a driver the wrong way</a>.</p>
<h3><a class="header" href="#feature-gates" id="feature-gates">Feature gates</a></h3>
<p>To use inline volume, Kubernetes 1.15 binaries must start with the <code>CSIInlineVolume</code> feature gate enabled:</p>
<pre><code>--feature-gates=CSIInlineVolume=true
</code></pre>
<p>Kubernetes &gt;= 1.16 no longer needs this as the feature is enabled by default.</p>
<h3><a class="header" href="#example-implementation-1" id="example-implementation-1">Example implementation</a></h3>
<ul>
<li><a href="https://github.com/kubernetes-csi/csi-driver-host-path">CSI Hostpath driver</a> - an example driver that supports both modes and determines the mode on a case-by-case basis (for Kubernetes 1.16) or can be deployed with support for just one of the two modes (for Kubernetes 1.15).</li>
<li><a href="https://github.com/kubernetes-csi/csi-driver-image-populator">Image populator plugin</a> - an example CSI driver plugin that uses a container image as a volume.</li>
</ul>
<h1><a class="header" href="#volume-limits" id="volume-limits">Volume Limits</a></h1>
<h2><a class="header" href="#status-9" id="status-9">Status</a></h2>
<table><thead><tr><th>Status</th><th>Min K8s Version</th><th>Max K8s Version</th></tr></thead><tbody>
<tr><td>Alpha</td><td>1.11</td><td>1.11</td></tr>
<tr><td>Beta</td><td>1.12</td><td>1.16</td></tr>
<tr><td>GA</td><td>1.17</td><td>-</td></tr>
</tbody></table>
<h2><a class="header" href="#overview-8" id="overview-8">Overview</a></h2>
<p>Some storage providers may have a restriction on the number of volumes that can be used in a Node. This is common in cloud providers, but other providers might impose restriction as well.</p>
<p>Kubernetes will respect this limit as long the CSI driver advertises it. To support volume limits in a CSI driver, the plugin must fill in <code>max_volumes_per_node</code> in <code>NodeGetInfoResponse</code>.</p>
<p>It is recommended that CSI drivers allow for customization of volume limits. That way cluster administrators can distribute the limits of the same storage backends (e.g. iSCSI) accross different drivers, according to their individual needs.</p>
<h1><a class="header" href="#deploying-csi-driver-on-kubernetes" id="deploying-csi-driver-on-kubernetes">Deploying CSI Driver on Kubernetes</a></h1>
<p>This page describes to CSI driver developers how to deploy their driver onto a Kubernetes cluster.</p>
<h2><a class="header" href="#overview-9" id="overview-9">Overview</a></h2>
<p>A CSI driver is typically deployed in Kubernetes as two components:
a controller component and a per-node component.</p>
<h3><a class="header" href="#controller-plugin" id="controller-plugin">Controller Plugin</a></h3>
<p>The controller component can be deployed as a Deployment or StatefulSet on
any node in the cluster. It consists of the CSI driver that implements the
CSI Controller service and one or more
<a href="sidecar-containers.html">sidecar containers</a>. These controller
sidecar containers typically interact with Kubernetes objects and make calls
to the driver's CSI Controller service.</p>
<p>It generally does not need direct access to the host and can perform all its
operations through the Kubernetes API and external control plane services.
Multiple copies of the controller component can be deployed for HA, however
it is recommended to use leader election to ensure there is only one active
controller at a time.</p>
<p>Controller sidecars include the external-provisioner, external-attacher,
external-snapshotter, and external-resizer. Including a sidecar in the
deployment may be optional.  See each sidecar's page for more details.</p>
<h4><a class="header" href="#communication-with-sidecars" id="communication-with-sidecars">Communication with Sidecars</a></h4>
<p><a href="https://docs.google.com/a/greatdanedata.com/drawings/d/1JExJ_98dt0NAsJ7iI0_9loeTn2rbLeEcpOMEvKrF-9w/edit?usp=sharing"><img src="images/sidecar-container.png" alt="sidecar-container" /></a></p>
<p>Sidecar containers manage Kubernetes events and make the appropriate
calls to the CSI driver. The calls are made by sharing a UNIX domain socket
through an emptyDir volume between the sidecars and CSI Driver.</p>
<h4><a class="header" href="#rbac-rules" id="rbac-rules">RBAC Rules</a></h4>
<p>Most controller sidecars interact with Kubernetes objects and therefore need
to set RBAC policies. Each sidecar repository contains example RBAC
configurations.</p>
<h3><a class="header" href="#node-plugin" id="node-plugin">Node Plugin</a></h3>
<p>The node component should be deployed on every node in the cluster through a
DaemonSet. It consists of the CSI driver that implements the CSI Node service and the
<a href="node-driver-registrar">node-driver-registrar</a> sidecar container.</p>
<h4><a class="header" href="#communication-with-kubelet" id="communication-with-kubelet">Communication with Kubelet</a></h4>
<p><a href="https://docs.google.com/a/greatdanedata.com/drawings/d/1NXaVNDh3mSDhog7Q3Y9eELyEF24F8Z-Kk0ujR3pyOes/edit?usp=sharing"><img src="images/kubelet.png" alt="kubelet" /></a></p>
<p>The Kubernetes kubelet runs on every node and is responsible for making the CSI
Node service calls. These calls mount and unmount the storage volume from the
storage system, making it available to the Pod to consume. Kubelet makes calls
to the CSI driver through a UNIX domain socket shared on the host via a HostPath
volume. There is also a second UNIX domain socket that the node-driver-registrar
uses to register the CSI driver to kubelet.</p>
<h4><a class="header" href="#driver-volume-mounts" id="driver-volume-mounts">Driver Volume Mounts</a></h4>
<p>The node plugin needs direct access to the host for making block devices and/or
filesystem mounts available to the Kubernetes kubelet.</p>
<p>The mount point used by the CSI driver must be set to <em>Bidirectional</em> to allow Kubelet
on the host to see mounts created by the CSI driver container. See the example below:</p>
<pre><code class="language-yaml">      containers:
      - name: my-csi-driver
        ...
        volumeMounts:
        - name: socket-dir
          mountPath: /csi
        - name: mountpoint-dir
          mountPath: /var/lib/kubelet/pods
          mountPropagation: &quot;Bidirectional&quot;
      - name: node-driver-registrar
        ...
        volumeMounts:
        - name: registration-dir
          mountPath: /registration
      volumes:
      # This volume is where the socket for kubelet-&gt;driver communication is done
      - name: socket-dir
        hostPath:
          path: /var/lib/kubelet/plugins/&lt;driver-name&gt;
          type: DirectoryOrCreate
      # This volume is where the driver mounts volumes
      - name: mountpoint-dir
        hostPath:
          path: /var/lib/kubelet/pods
          type: Directory
      # This volume is where the node-driver-registrar registers the plugin
      # with kubelet
      - name: registration-dir
        hostPath:
          path: /var/lib/kubelet/plugins_registry
          type: Directory
</code></pre>
<h2><a class="header" href="#deploying" id="deploying">Deploying</a></h2>
<p>Deploying a CSI driver onto Kubernetes is highlighted in detail in <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md#recommended-mechanism-for-deploying-csi-drivers-on-kubernetes"><em>Recommended Mechanism for Deploying CSI Drivers on Kubernetes</em></a>. </p>
<h2><a class="header" href="#enable-privileged-pods" id="enable-privileged-pods">Enable privileged Pods</a></h2>
<p>To use CSI drivers, your Kubernetes cluster must allow privileged pods (i.e. <code>--allow-privileged</code> flag must be set to <code>true</code> for both the API server and the kubelet). This is the default in some environments (e.g. GCE, GKE, <code>kubeadm</code>).</p>
<p>Ensure your API server are started with the privileged flag:</p>
<pre><code class="language-shell">$ ./kube-apiserver ...  --allow-privileged=true ...
</code></pre>
<pre><code class="language-shell">$ ./kubelet ...  --allow-privileged=true ...
</code></pre>
<blockquote>
<p>Note: Starting from Kubernetes 1.13.0, --allow-privileged is true for kubelet. It'll be deprecated in future kubernetes releases.</p>
</blockquote>
<h2><a class="header" href="#enabling-mount-propagation" id="enabling-mount-propagation">Enabling mount propagation</a></h2>
<p>Another feature that CSI depends on is mount propagation.  It allows the sharing of volumes mounted by one container with other containers in the same pod, or even to other pods on the same node.  For mount propagation to work, the Docker daemon for the cluster must allow shared mounts. See the <a href="https://kubernetes.io/docs/concepts/storage/volumes/#mount-propagation">mount propagation docs</a> to find out how to enable this feature for your cluster.  <a href="https://kubernetes.io/docs/concepts/storage/volumes/#configuration">This page</a> explains how to check if shared mounts are enabled and how to configure Docker for shared mounts.</p>
<h3><a class="header" href="#examples-2" id="examples-2">Examples</a></h3>
<ul>
<li>Simple deployment example using a single pod for all components: see the <a href="example.html">hostpath example</a>.</li>
<li>Full deployment example using a <em>DaemonSet</em> for the node plugin and <em>StatefulSet</em> for the controller plugin: TODO</li>
</ul>
<h2><a class="header" href="#more-information" id="more-information">More information</a></h2>
<p>For more information, please read <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md"><em>CSI Volume Plugins in Kubernetes Design Doc</em></a>.</p>
<h1><a class="header" href="#example" id="example">Example</a></h1>
<p>The <a href="https://github.com/kubernetes-csi/csi-driver-host-path">Hostpath CSI driver</a> is a simple sample driver that provisions a directory on the host. It can be used as an example to get started writing a driver, however it is not meant for production use.
The <a href="https://github.com/kubernetes-csi/csi-driver-host-path#deployment">deployment example</a> shows how to deploy and use that driver in Kubernetes.</p>
<p>The example deployment uses the original RBAC rule files that are maintained together with sidecar apps and deploys into the default namespace. A real production should copy the RBAC files and customize them as explained in the comments of those files.</p>
<p>If you encounter any problems, please check the <a href="troubleshooting.html">Troubleshooting page</a>.</p>
<h1><a class="header" href="#testing" id="testing">Testing</a></h1>
<p>This section describes how CSI developers can test their CSI drivers.</p>
<ul>
<li><a href="unit-testing.html">Unit Testing</a></li>
<li><a href="functional-testing.html">Functional Testing</a></li>
</ul>
<h1><a class="header" href="#unit-testing" id="unit-testing">Unit Testing</a></h1>
<p>The <a href="https://github.com/kubernetes-csi/csi-test/tree/master/pkg/sanity">CSI <code>sanity</code></a> package from <a href="https://github.com/kubernetes-csi/csi-test">csi-test</a> can be used for unit testing your CSI driver.</p>
<p>It contains a set of basic tests that all CSI drivers should pass (for example, <code>NodePublishVolume should fail when no volume id is provided</code>, etc.).</p>
<p>This package can be used in two modes:</p>
<ul>
<li>Via a Golang test framework (<code>sanity</code> package is imported as a dependency)</li>
<li>Via a command line against your driver binary.</li>
</ul>
<p>Read the <a href="https://github.com/kubernetes-csi/csi-test/blob/master/pkg/sanity/README.md">documentation of the <code>sanity</code> package</a> for more details.</p>
<h1><a class="header" href="#functional-testing" id="functional-testing">Functional Testing</a></h1>
<p>Drivers should be functionally &quot;end-to-end&quot; tested while deployed in a Kubernetes cluster. Previously, how to do this and what tests to run was left up to driver authors. Now, a standard set of Kubernetes CSI end-to-end tests can be imported and run by third party CSI drivers. This documentation specifies how to do so.</p>
<p>The CSI community is also looking in to establishing an official &quot;CSI Conformance Suite&quot; to recognize &quot;officially certified CSI drivers&quot;.  This documentation will be updated with more information once that process has been defined.</p>
<h1><a class="header" href="#kubernetes-end-to-end-testing-for-csi-storage-plugins" id="kubernetes-end-to-end-testing-for-csi-storage-plugins">Kubernetes End to End Testing for CSI Storage Plugins</a></h1>
<p>Currently, <a href="https://github.com/kubernetes-csi/csi-test/tree/master/cmd/csi-sanity">csi-sanity</a> exists to help test compliance with the CSI spec, but e2e testing of plugins is needed as well to provide plugin authors and users validation that their plugin is integrated well with specific versions of Kubernetes.</p>
<h2><a class="header" href="#setting-up-end-to-end-tests-for-your-csi-plugin" id="setting-up-end-to-end-tests-for-your-csi-plugin">Setting up End to End tests for your CSI Plugin</a></h2>
<h3><a class="header" href="#prerequisites" id="prerequisites">Prerequisites:</a></h3>
<ul>
<li>A Kubernetes v1.13+ Cluster</li>
<li><a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl">Kubectl</a></li>
</ul>
<p>There are two ways to run end-to-end tests for your CSI Plugin</p>
<ol>
<li>use <a href="https://github.com/kubernetes/kubernetes/tree/master/test/e2e/storage/external">Kubernetes E2E Tests</a>, by providing a DriverDefinition YAML file via a parameter. </li>
</ol>
<ul>
<li><strong>Note</strong>: In some cases you would not be able to use this method, in running e2e tests by just providing a YAML file defining your CSI plugin. For example the <a href="https://github.com/kubernetes-csi/csi-driver-nfs">NFS CSI plugin</a> currently does not support dynamic provisoning, so we would want to skip those and run only pre-provisioned tests. For such cases, you would need to write your own testdriver, which is discussed below. </li>
</ul>
<ol start="2">
<li>import the in-tree storage tests and run them using <code>go test</code>. </li>
</ol>
<p>This doc will cover how to run the E2E tests using the second method.</p>
<h2><a class="header" href="#importing-the-e2e-test-suite-as-a-library" id="importing-the-e2e-test-suite-as-a-library">Importing the E2E test suite as a library</a></h2>
<p>In-tree storage e2e tests could be used to test CSI storage plugins. Your repo should be setup similar to how the <a href="https://github.com/kubernetes-csi/csi-driver-nfs">NFS CSI plugin</a> is setup, where the testfiles are in a <code>test</code> directory and the main test file is in the <code>cmd</code> directory.</p>
<p>To be able to import Kubernetes in-tree storage tests, the CSI plugin would need to use <strong>Kubernetes v1.14+</strong> (add to plugin's GoPkg.toml, since pluggable E2E tests become available in v1.14). CSI plugin authors would also be required to implement a <a href="https://github.com/kubernetes/kubernetes/blob/6644db9914379a4a7b3d3487b41b2010f226e4dc/test/e2e/storage/testsuites/testdriver.go#L31">testdriver</a> for their CSI plugin. The testdriver provides required functionality that would help setup testcases for a particular plugin. </p>
<p>For any testdriver these functions would be required (Since it implements the <a href="https://github.com/kubernetes/kubernetes/blob/6644db9914379a4a7b3d3487b41b2010f226e4dc/test/e2e/storage/testsuites/testdriver.go#L31">TestDriver Interface</a>):</p>
<ul>
<li><code>GetDriverInfo() *testsuites.DriverInfo</code></li>
<li><code>SkipUnsupportedTest(pattern testpatterns.TestPattern)</code></li>
<li><code>PrepareTest(f *framework.Framework) (*testsuites.PerTestConfig, func())</code> </li>
</ul>
<p>The <code>PrepareTest</code> method is where you would write code to setup your CSI plugin, and it would be called before each test case. It is recommended that you don't deploy your plugin in this method, and rather deploy it manually before running your tests.</p>
<p><code>GetDriverInfo</code> will return a <code>DriverInfo</code> object that has all of the plugin's capabilities and required information. This object helps tests find the deployed plugin, and also decides which tests should run (depending on the plugin's capabilities).</p>
<p>Here are examples of the NFS and Hostpath DriverInfo objects:</p>
<pre><code>testsuites.DriverInfo{
			Name:        &quot;csi-nfsplugin&quot;,
			MaxFileSize: testpatterns.FileSizeLarge,
			SupportedFsType: sets.NewString(
				&quot;&quot;, // Default fsType
			),
			Capabilities: map[testsuites.Capability]bool{
				testsuites.CapPersistence: true,
				testsuites.CapExec:        true,
			},
}
</code></pre>
<pre><code>testsuites.DriverInfo{
			Name:        &quot;csi-hostpath&quot;,
			FeatureTag:  &quot;&quot;,
			MaxFileSize: testpatterns.FileSizeMedium,
			SupportedFsType: sets.NewString(
				&quot;&quot;, // Default fsType
			),
			Capabilities: map[testsuites.Capability]bool{
				testsuites.CapPersistence: true,
			},
}
</code></pre>
<p>You would define something similar for your CSI plugin.</p>
<p><code>SkipUnsupportedTest</code> simply skips any tests that you define there.</p>
<p>Depending on your plugin's specs, you would implement other interaces defined <a href="https://github.com/kubernetes/kubernetes/blob/6644db9914379a4a7b3d3487b41b2010f226e4dc/test/e2e/storage/testsuites/testdriver.go#L61">here</a>. For example the <a href="https://github.com/kubernetes-csi/csi-driver-nfs/blob/193faa0f2aa92a3be0855764a1126ff3cdcd3e77/test/nfs-testdriver.go#L66">NFS testdriver</a> also implements PreprovisionedVolumeTestDriver and PreprovisionedPVTestDriver interfaces, to enable pre-provisoned tests. </p>
<p>After implementing the testdriver for your CSI plugin, you would create a <code>csi-volumes.go</code> file, where the implemented testdriver is used to run in-tree storage testsuites, <a href="https://github.com/kubernetes-csi/csi-driver-nfs/blob/193faa0f2aa92a3be0855764a1126ff3cdcd3e77/test/csi-volumes.go#L37">similar to how the NFS CSI plugin does so</a>. This is where you would define which testsuites you would want to run for your plugin. All available in-tree testsuites can be found <a href="https://github.com/kubernetes/kubernetes/tree/master/test/e2e/storage/testsuites">here</a>.</p>
<p>Finally, importing the <code>test</code> package into your <a href="https://github.com/kubernetes-csi/csi-driver-nfs/blob/193faa0f2aa92a3be0855764a1126ff3cdcd3e77/cmd/tests/nfs-e2e.go#L18">main test file</a> will <a href="https://github.com/kubernetes-csi/csi-driver-nfs/blob/193faa0f2aa92a3be0855764a1126ff3cdcd3e77/test/csi-volumes.go#L37">initialize the testsuites to run the E2E tests</a>.</p>
<p>The NFS plugin creates a binary to run E2E tests, but you could use <code>go test</code> instead to run E2E tests using a command like this:</p>
<pre><code>go test -v &lt;main test file&gt; -ginkgo.v -ginkgo.progress --kubeconfig=&lt;kubeconfig file&gt; -timeout=0
</code></pre>
<h1><a class="header" href="#drivers" id="drivers">Drivers</a></h1>
<p>The following are a set of CSI driver which can be used with Kubernetes:</p>
<blockquote>
<p>NOTE: If you would like your driver to be added to this table, please open a pull request in <a href="https://github.com/kubernetes-csi/docs/pulls">this repo</a> updating this file. Other Features is allowed to be filled in Raw Block, Snapshot, Expansion and Cloning. If driver did not implement any Other Features, please leave it blank.</p>
</blockquote>
<h2><a class="header" href="#production-drivers" id="production-drivers">Production Drivers</a></h2>
<table><thead><tr><th>Name</th><th>CSI Driver Name</th><th>Compatible with CSI Version(s)</th><th>Description</th><th>Persistence (Beyond Pod Lifetime)</th><th>Supported Access Modes</th><th>Dynamic Provisioning</th><th>Other Features</th></tr></thead><tbody>
<tr><td><a href="https://github.com/AliyunContainerService/csi-plugin">Alicloud Disk</a></td><td><code>diskplugin.csi.alibabacloud.com</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for Alicloud Disk</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Snapshot</td></tr>
<tr><td><a href="https://github.com/AliyunContainerService/csi-plugin">Alicloud NAS</a></td><td><code>nasplugin.csi.alibabacloud.com</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for Alicloud Network Attached Storage (NAS)</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>No</td><td></td></tr>
<tr><td><a href="https://github.com/AliyunContainerService/csi-plugin">Alicloud OSS</a></td><td><code>ossplugin.csi.alibabacloud.com</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for Alicloud Object Storage Service (OSS)</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>No</td><td></td></tr>
<tr><td><a href="https://github.com/huayun-docs/csi-driver-arstor">ArStor CSI</a></td><td><code>arstor.csi.huayun.io</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for Huayun Storage Service (ArStor)</td><td>Persistent and Ephemeral</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Snapshot, Expansion, Cloning</td></tr>
<tr><td><a href="https://github.com/kubernetes-sigs/aws-ebs-csi-driver">AWS Elastic Block Storage</a></td><td><code>ebs.csi.aws.com</code></td><td>v0.3, v1.0</td><td>A Container Storage Interface (CSI) Driver for AWS Elastic Block Storage (EBS)</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Snapshot, Expansion</td></tr>
<tr><td><a href="https://github.com/aws/aws-efs-csi-driver">AWS Elastic File System</a></td><td><code>efs.csi.aws.com</code></td><td>v0.3, v1.0</td><td>A Container Storage Interface (CSI) Driver for AWS Elastic File System (EFS)</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>No</td><td></td></tr>
<tr><td><a href="https://github.com/aws/aws-fsx-csi-driver">AWS FSx for Lustre</a></td><td><code>fsx.csi.aws.com</code></td><td>v0.3, v1.0</td><td>A Container Storage Interface (CSI) Driver for AWS FSx for Lustre (EBS)</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/kubernetes-sigs/azuredisk-csi-driver">Azure disk</a></td><td><code>disk.csi.azure.com</code></td><td>v0.3, v1.0</td><td>A Container Storage Interface (CSI) Driver for Azure disk</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/kubernetes-sigs/azurefile-csi-driver">Azure file</a></td><td><code>file.csi.azure.com</code></td><td>v0.3, v1.0</td><td>A Container Storage Interface (CSI) Driver for Azure file</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/bigtera-ce/ceph-csi">Bigtera VirtualStor (block)</a></td><td><code>csi.block.bigtera.com</code></td><td>v0.3, v1.0.0, v1.1.0</td><td>A Container Storage Interface (CSI) Driver for Bigtera VirtualStor block storage</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Snapshot, Expansion</td></tr>
<tr><td><a href="https://github.com/bigtera-ce/ceph-csi">Bigtera VirtualStor (filesystem)</a></td><td><code>csi.fs.bigtera.com</code></td><td>v0.3, v1.0.0, v1.1.0</td><td>A Container Storage Interface (CSI)  Driver for Bigtera VirtualStor filesystem</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Expansion</td></tr>
<tr><td><a href="https://github.com/ceph/ceph-csi">CephFS</a></td><td><code>cephfs.csi.ceph.com</code></td><td>v0.3, v1.0.0, v1.1.0</td><td>A Container Storage Interface (CSI) Driver for CephFS</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Expansion</td></tr>
<tr><td><a href="https://github.com/ceph/ceph-csi">Ceph RBD</a></td><td><code>rbd.csi.ceph.com</code></td><td>v0.3, v1.0.0, v1.1.0</td><td>A Container Storage Interface (CSI)  Driver for Ceph RBD</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Snapshot, Expansion, Topology</td></tr>
<tr><td><a href="https://github.com/chubaofs/chubaofs-csi">ChubaoFS</a></td><td><code>csi.chubaofs.com</code></td><td>v1.0.0</td><td>A Container Storage Interface (CSI) Driver for ChubaoFS Storage</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/kubernetes/cloud-provider-openstack/tree/master/pkg/csi/cinder">Cinder</a></td><td><code>cinder.csi.openstack.org</code></td><td>v0.3, v1.0, v1.1</td><td>A Container Storage Interface (CSI) Driver for OpenStack Cinder</td><td>Persistent and Ephemeral</td><td>Depends on the storage backend used</td><td>Yes, if storage backend supports it</td><td>Raw Block, Snapshot, Expansion</td></tr>
<tr><td><a href="https://github.com/cloudscale-ch/csi-cloudscale">cloudscale.ch</a></td><td><code>csi.cloudscale.ch</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for the <a href="https://www.cloudscale.ch/">cloudscale.ch</a> IaaS platform</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Snapshot</td></tr>
<tr><td><a href="https://github.com/Datera/datera-csi">Datera</a></td><td><code>dsp.csi.daterainc.io</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for Datera Data Services Platform (DSP)</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Snapshot</td></tr>
<tr><td><a href="https://github.com/dell/csi-isilon">Dell EMC Isilon</a></td><td><code>csi-isilon.dellemc.com</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for <a href="https://www.dellemc.com/en-us/storage/isilon/index.htm">Dell EMC Isilon</a></td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Snapshot</td></tr>
<tr><td><a href="https://github.com/dell/csi-powermax">Dell EMC PowerMax</a></td><td><code>csi-powermax.dellemc.com</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for <a href="https://www.dellemc.com/en-us/storage/powermax.htm">Dell EMC PowerMax</a></td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/dell/csi-unity">Dell EMC Unity</a></td><td><code>csi-unity.dellemc.com</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for <a href="https://www.dellemc.com/en-us/storage/unity.htm">Dell EMC Unity</a></td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Snapshot</td></tr>
<tr><td><a href="https://github.com/dell/csi-vxflexos">Dell EMC VxFlexOS</a></td><td><code>csi-vxflexos.dellemc.com</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for Dell EMC VxFlexOS</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Snapshot</td></tr>
<tr><td><a href="https://github.com/dell/csi-xtremio-deploy">Dell EMC XtremIO</a></td><td><code>csi-xtremio.dellemc.com</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for <a href="https://www.dellemc.com/en-us/storage/xtremio-all-flash.htm">Dell EMC XtremIO</a></td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Snapshot</td></tr>
<tr><td><a href="https://github.com/digitalocean/csi-digitalocean">DigitalOcean Block Storage</a></td><td><code>dobs.csi.digitalocean.com</code></td><td>v0.3, v1.0</td><td>A Container Storage Interface (CSI) Driver for DigitalOcean Block Storage</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Snapshot, Expansion</td></tr>
<tr><td><a href="https://github.com/DriveScale/k8s-plugins">DriveScale</a></td><td><code>csi.drivescale.com</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for DriveScale software composable infrastructure solution</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://ember-csi.io">Ember CSI</a></td><td><code>[x].ember-csi.io</code></td><td>v0.2, v0.3, v1.0</td><td>Multi-vendor CSI plugin supporting over 80 Drivers to provide block and mount storage to Container Orchestration systems.</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Snapshot</td></tr>
<tr><td><a href="https://github.com/kubernetes-sigs/gcp-compute-persistent-disk-csi-driver">GCE Persistent Disk</a></td><td><code>pd.csi.storage.gke.io</code></td><td>v0.3, v1.0</td><td>A Container Storage Interface (CSI) Driver for Google Compute Engine Persistent Disk (GCE PD)</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Snapshot</td></tr>
<tr><td><a href="https://github.com/kubernetes-sigs/gcp-filestore-csi-driver">Google Cloud Filestore</a></td><td><code>com.google.csi.filestore</code></td><td>v0.3</td><td>A Container Storage Interface (CSI) Driver for Google Cloud Filestore</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/ofek/csi-gcs">Google Cloud Storage</a></td><td><code>gcs.csi.ofek.dev</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for Google Cloud Storage</td><td>Persistent and Ephemeral</td><td>Read/Write Multiple Pods</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/gluster/gluster-csi-driver">GlusterFS</a></td><td><code>org.gluster.glusterfs</code></td><td>v0.3, v1.0</td><td>A Container Storage Interface (CSI) Driver for GlusterFS</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Snapshot</td></tr>
<tr><td><a href="https://github.com/gluster/gluster-csi-driver">Gluster VirtBlock</a></td><td><code>org.gluster.glustervirtblock</code></td><td>v0.3, v1.0</td><td>A Container Storage Interface (CSI) Driver for Gluster Virtual Block volumes</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/hammer-space/csi-plugin">Hammerspace CSI</a></td><td><code>com.hammerspace.csi</code></td><td>v0.3, v1.0</td><td>A Container Storage Interface (CSI) Driver for Hammerspace Storage</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Raw Block, Snapshot</td></tr>
<tr><td><a href="https://github.com/hetznercloud/csi-driver">Hetzner Cloud Volumes CSI</a></td><td><code>csi.hetzner.cloud</code></td><td>v0.3, v1.0</td><td>A Container Storage Interface (CSI) Driver for Hetzner Cloud Volumes</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Expansion</td></tr>
<tr><td><a href="https://knowledge.hitachivantara.com/Documents/Adapters_and_Drivers/Storage_Adapters_and_Drivers/Containers">Hitachi Vantara</a></td><td><code>com.hitachi.hspc.csi</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for VSP series Storage</td><td>Persistent</td><td>?</td><td>?</td><td></td></tr>
<tr><td><a href="https://github.com/hpe-storage/csi-driver">HPE</a></td><td><code>csi.hpe.com</code></td><td>v0.3, v1.0, v1.1</td><td>A Container Storage Interface (CSI) driver from HPE</td><td>Persistent and Ephemeral</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Snapshot, Expansion, Cloning</td></tr>
<tr><td><a href="https://github.com/Zetanova/hyperv-csi-driver">HyperV CSI</a></td><td><code>eu.zetanova.csi.hyperv</code></td><td>v1.0, v1.1</td><td>A Container Storage Interface (CSI) driver to manage hyperv hosts</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/ibm/ibm-block-csi-driver">IBM Block Storage</a></td><td><code>block.csi.ibm.com</code></td><td>v1.0, v1.1</td><td>A Container Storage Interface (CSI) <a href="https://www.ibm.com/support/knowledgecenter/SSRQ8T">Driver</a> for IBM Spectrum Virtualize, IBM Storwize, IBM FlashSystem 9100, A9000 and A9000R, IBM DS8880 and DS8900.</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block</td></tr>
<tr><td><a href="https://github.com/IBM/ibm-spectrum-scale-csi">IBM Spectrum Scale</a></td><td><code>spectrumscale.csi.ibm.com</code></td><td>v1.0, v1.1</td><td>A Container Storage Interface (CSI) <a href="https://www.ibm.com/support/knowledgecenter/STXKQY_CSI_SHR">Driver</a> for the IBM Spectrum Scale File System</td><td>Persistent</td><td>Read/Write Multiple Pod</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/OpenInspur/instorage-k8s">Inspur InStorage CSI</a></td><td><code>csi-instorage</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for Inspur AS/HF/CS/CF Series Storage</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Snapshot, Expansion, Cloning</td></tr>
<tr><td><a href="https://github.com/intel/pmem-csi">Intel PMEM-CSI</a></td><td><code>pmem-csi.intel.com</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) driver for <a href="https://pmem.io/">PMEM</a> from Intel</td><td>Persistent and Ephemeral</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block</td></tr>
<tr><td><a href="https://github.com/juicedata/juicefs-csi-driver">JuiceFS</a></td><td><code>csi.juicefs.com</code></td><td>v0.3, v1.0</td><td>A Container Storage Interface (CSI) Driver for JuiceFS File System</td><td>Persistent</td><td>Read/Write Multiple Pod</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/kadalu/kadalu">kaDalu</a></td><td><code>org.kadalu.gluster</code></td><td>v0.3</td><td>A CSI Driver (and operator) for GlusterFS</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/linode/linode-blockstorage-csi-driver">Linode Block Storage</a></td><td><code>linodebs.csi.linode.com</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for Linode Block Storage</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/LINBIT/linstor-csi">LINSTOR</a></td><td><code>io.drbd.linstor-csi</code></td><td>v1.1</td><td>A Container Storage Interface (CSI) Driver for <a href="https://www.linbit.com/en/linstor/">LINSTOR</a> volumes</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Snapshot</td></tr>
<tr><td><a href="https://github.com/longhorn/longhorn">Longhorn</a></td><td><code>driver.longhorn.io</code></td><td>v1.1</td><td>A Container Storage Interface (CSI) Driver for <a href="https://longhorn.io/">Longhorn</a> volumes</td><td>Persistent</td><td>Read/Write Single Node</td><td>Yes</td><td>Raw Block</td></tr>
<tr><td><a href="https://github.com/macrosan-csi/macrosan-csi-driver">MacroSAN</a></td><td><code>csi-macrosan</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for MacroSAN Block Storage</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/kubernetes/cloud-provider-openstack/tree/master/pkg/csi/manila">Manila</a></td><td><code>manila.csi.openstack.org</code></td><td>v1.1, v1.2</td><td>A Container Storage Interface (CSI) Driver for OpenStack Shared File System Service (Manila)</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Snapshot, Topology</td></tr>
<tr><td><a href="https://github.com/mapr/mapr-csi">MapR</a></td><td><code>com.mapr.csi-kdf</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for MapR Data Platform</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Snapshot</td></tr>
<tr><td><a href="https://github.com/moosefs/moosefs-csi">MooseFS</a></td><td><code>com.tuxera.csi.moosefs</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for <a href="https://moosefs.com/">MooseFS</a> clusters.</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/NetApp/trident">NetApp</a></td><td><code>csi.trident.netapp.io</code></td><td>v1.0, v1.1</td><td>A Container Storage Interface (CSI) Driver for NetApp's <a href="https://netapp-trident.readthedocs.io/">Trident</a> container storage orchestrator</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Snapshot, Expansion, Cloning</td></tr>
<tr><td><a href="https://github.com/Nexenta/nexentastor-csi-driver">NexentaStor</a></td><td><code>nexentastor-csi-driver.nexenta.com</code></td><td>v1.0, v1.1</td><td>A Container Storage Interface (CSI) Driver for NexentaStor</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Snapshot, Expansion, Cloning</td></tr>
<tr><td><a href="https://portal.nutanix.com/#/page/docs/details?targetId=CSI-Volume-Driver:CSI-Volume-Driver">Nutanix</a></td><td><code>&quot;com.nutanix.csi&quot;</code></td><td>v0.3, v1.0</td><td>A Container Storage Interface (CSI) Driver for Nutanix</td><td>Persistent</td><td>&quot;Read/Write Single Pod&quot; with Nutanix Volumes and &quot;Read/Write Multiple Pods&quot; with Nutanix Files</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/openebs/csi">OpenEBS</a></td><td><code>cstor.csi.openebs.io</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for  <a href="https://www.openebs.io/">OpenEBS</a></td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Expansion, Snapshot, Cloning</td></tr>
<tr><td><a href="https://github.com/opensds/nbp/tree/master/csi">OpenSDS</a></td><td><code>csi-opensdsplugin</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for <a href="(https://www.opensds.io/)">OpenSDS</a></td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Snapshot</td></tr>
<tr><td><a href="https://github.com/open-e/JovianDSS-KubernetesCSI">Open-E</a></td><td><code>com.open-e.joviandss.csi</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for Open-E JovianDSS Storage</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Snapshot, Cloning</td></tr>
<tr><td><a href="https://github.com/libopenstorage/openstorage/tree/master/csi">Portworx</a></td><td><code>pxd.openstorage.org</code></td><td>v0.3, v1.1</td><td>A Container Storage Interface (CSI) Driver for <a href="https://docs.portworx.com/portworx-install-with-kubernetes/storage-operations/csi/">Portworx</a></td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Snapshot, Expansion</td></tr>
<tr><td><a href="https://github.com/purestorage/helm-charts">Pure Storage CSI</a></td><td><code>pure-csi</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for Pure Storage's <a href="https://purestorage.com/containers">Pure Service Orchestrator</a></td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Snapshot, Cloning, Raw Block, Topology</td></tr>
<tr><td><a href="https://github.com/yunify/qingcloud-csi">QingCloud CSI</a></td><td><code>disk.csi.qingcloud.com</code></td><td>v1.1</td><td>A Container Storage Interface (CSI) Driver for QingCloud Block Storage</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Snapshot, Expansion, Cloning</td></tr>
<tr><td><a href="https://github.com/yunify/qingstor-csi">QingStor CSI</a></td><td><code>csi-neonsan</code></td><td>v0.3</td><td>A Container Storage Interface (CSI) Driver for NeonSAN storage system</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Snapshot</td></tr>
<tr><td><a href="https://github.com/quobyte/quobyte-csi">Quobyte</a></td><td><code>quobyte-csi</code></td><td>v0.2</td><td>A Container Storage Interface (CSI) Driver for Quobyte</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://get.robin.io/">ROBIN</a></td><td><code>robin</code></td><td>v0.3, v1.0</td><td>A Container Storage Interface (CSI) Driver for <a href="https://docs.robin.io">ROBIN</a></td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Raw Block, Snapshot, Cloning</td></tr>
<tr><td><a href="https://github.com/sandstone-storage/sandstone-csi-driver">SandStone</a></td><td><code>csi-sandstone-plugin</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for SandStone USP</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Raw Block, Snapshot, Expansion, Cloning</td></tr>
<tr><td><a href="https://github.com/evan37717/sangfor-eds-csi">Sangfor-EDS</a></td><td><code>eds.csi.sangfor.com</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for Sangfor Distributed File Storage(EDS)</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td></td></tr>
<tr><td><a href="http://www.smartx.com/?locale=en">SmartX</a></td><td><code>csi-smtx-plugin</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for SmartX ZBS Storage</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Snapshot, Expansion</td></tr>
<tr><td><a href="https://docs.storageos.com/docs/platforms/kubernetes/install/">StorageOS</a></td><td><code>storageos</code></td><td>v0.3, v1.0</td><td>A Container Storage Interface (CSI) Driver for <a href="https://storageos.com/">StorageOS</a></td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/TencentCloud/kubernetes-csi-tencentcloud">Tencent Cloud Block Storage</a></td><td><code>com.tencent.cloud.csi.cbs</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for Tencent Cloud Block Storage</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Snapshot</td></tr>
<tr><td><a href="https://github.com/TencentCloud/kubernetes-csi-tencentcloud">Tencent Cloud File Storage</a></td><td><code>com.tencent.cloud.csi.cfs</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for Tencent Cloud File Storage</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/TencentCloud/kubernetes-csi-tencentcloud">Tencent Cloud Object Storage</a></td><td><code>com.tencent.cloud.csi.cosfs</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for Tencent Cloud Object Storage</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>No</td><td></td></tr>
<tr><td><a href="https://github.com/cybozu-go/topolvm">TopoLVM</a></td><td><code>topolvm.cybozu.com</code></td><td>v1.1</td><td>A Container Storage Interface (CSI) Driver for LVM</td><td>Persistent and Ephemeral</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Expansion, Topology Aware</td></tr>
<tr><td><a href="https://xsky-storage.github.io/xsky-csi-driver/csi-block.html">XSKY-EBS</a></td><td><code>csi.block.xsky.com</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for XSKY Distributed Block Storage (X-EBS)</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Snapshot, Expansion, Cloning</td></tr>
<tr><td><a href="https://xsky-storage.github.io/xsky-csi-driver/csi-fs.html">XSKY-EUS</a></td><td><code>csi.fs.xsky.com</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for XSKY Distributed File Storage (X-EUS)</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/kubevault/csi-driver">Vault</a></td><td><code>secrets.csi.kubevault.com</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for mounting HashiCorp Vault secrets as volumes.</td><td>Ephemeral</td><td>N/A</td><td>N/A</td><td></td></tr>
<tr><td><a href="https://github.com/kubernetes-sigs/vsphere-csi-driver">vSphere</a></td><td><code>vsphere.csi.vmware.com</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for VMware vSphere</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block</td></tr>
<tr><td><a href="https://github.com/flant/yandex-csi-driver">Yandex.Cloud</a></td><td><code>yandex.csi.flant.com</code></td><td>v1.2</td><td>A Container Storage Interface (CSI) plugin for Yandex.Cloud Compute Disks</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td></td></tr>
<tr><td><a href="http://www.yanrongyun.com/">YanRongYun</a></td><td>?</td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for YanRong YRCloudFile Storage</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/zadarastorage/zadara-csi">Zadara-CSI</a></td><td><code>csi.zadara.com</code></td><td>v1.0, v1.1</td><td>A Container Storage Interface (CSI) plugin for Zadara VPSA Storage Array &amp; VPSA All-Flash</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Raw Block, Snapshot, Expansion, Cloning</td></tr>
</tbody></table>
<h2><a class="header" href="#sample-drivers" id="sample-drivers">Sample Drivers</a></h2>
<table><thead><tr><th>Name</th><th>Status</th><th>More Information</th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/csi-driver-flex">Flexvolume</a></td><td>Sample</td><td></td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/csi-driver-host-path">HostPath</a></td><td>v1.2.0</td><td>Only use for a single node tests. See the <a href="example.html">Example</a> page for Kubernetes-specific instructions.</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/csi-driver-image-populator">ImagePopulator</a></td><td>Prototype</td><td>Driver that lets you use a container image as an ephemeral volume.</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/csi-test/tree/master/mock/service">In-memory Sample Mock Driver</a></td><td>v0.3.0</td><td>The sample mock driver used for <a href="https://github.com/kubernetes-csi/csi-test/tree/master/cmd/csi-sanity">csi-sanity</a></td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/csi-driver-nfs">NFS</a></td><td>Sample</td><td></td></tr>
<tr><td><a href="https://github.com/jparklab/synology-csi">Synology NAS</a></td><td>v1.0.0</td><td>An unofficial (and unsupported) Container Storage Interface Driver for Synology NAS.</td></tr>
<tr><td><a href="https://github.com/thecodeteam/csi-vfs">VFS Driver</a></td><td>Released</td><td>A CSI plugin that provides a virtual file system.</td></tr>
</tbody></table>
<h1><a class="header" href="#troubleshooting" id="troubleshooting">Troubleshooting</a></h1>
<h1><a class="header" href="#known-issues" id="known-issues">Known Issues</a></h1>
<ul>
<li>[<a href="https://github.com/kubernetes/minikube/issues/3378">minikube-3378</a>]: Volume mount causes minikube VM to become corrupted</li>
</ul>
<h1><a class="header" href="#common-errors" id="common-errors">Common Errors</a></h1>
<h3><a class="header" href="#node-plugin-pod-does-not-start-with-runcontainererror-status" id="node-plugin-pod-does-not-start-with-runcontainererror-status">Node plugin pod does not start with <em>RunContainerError</em> status</a></h3>
<p><code>kubectl describe pod your-nodeplugin-pod</code> shows:</p>
<pre><code>failed to start container &quot;your-driver&quot;: Error response from daemon:
linux mounts: Path /var/lib/kubelet/pods is mounted on / but it is not a shared mount
</code></pre>
<p>Your Docker host is not configured to allow shared mounts. Take a look at <a href="https://kubernetes.io/docs/concepts/storage/volumes/#configuration">this page</a> for instructions to enable them.</p>
<h3><a class="header" href="#external-attacher-cant-find-volumeattachments" id="external-attacher-cant-find-volumeattachments">External attacher can't find <em>VolumeAttachments</em></a></h3>
<p>If you have a Kubernetes 1.9 cluster, not being able to list <em>VolumeAttachment</em>
and the following error are due to the lack of the
<code>storage.k8s.io/v1alpha1=true</code> runtime configuration:</p>
<pre><code>$ kubectl logs csi-pod external-attacher
...
I0306 16:34:50.976069       1 reflector.go:240] Listing and watching *v1alpha1.VolumeAttachment from github.com/kubernetes-csi/external-attacher/vendor/k8s.io/client-go/informers/factory.go:86

E0306 16:34:50.992034       1 reflector.go:205] github.com/kubernetes-csi/external-attacher/vendor/k8s.io/client-go/informers/factory.go:86: Failed to list *v1alpha1.VolumeAttachment: the server could not find the requested resource
...
</code></pre>
<p>Please see the <a href="Kubernetes-1.9.html">Kubernetes 1.9</a> page.</p>
<h3><a class="header" href="#problems-with-the-external-components" id="problems-with-the-external-components">Problems with the external components</a></h3>
<p>The external components images are under active development. It can
happen that they become incompatible with each other. If the
issues above above have been ruled out, <a href="https://github.com/kubernetes/community/tree/master/sig-storage">contact the sig-storage
team</a> and/or
<a href="https://github.com/kubernetes/community/blob/master/contributors/devel/e2e-tests.md#local-clusters">run the e2e test</a>:</p>
<pre><code>go run hack/e2e.go -- --provider=local --test --test_args=&quot;--ginkgo.focus=Feature:CSI&quot;
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
