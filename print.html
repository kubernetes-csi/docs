<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Kubernetes CSI Documentation</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="CSI support for Kubernetes">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="Home.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><a href="UsingCSIDriver.html"><strong aria-hidden="true">2.</strong> Using a CSI Driver</a></li><li><ol class="section"><li><a href="Setup.html"><strong aria-hidden="true">2.1.</strong> Setup</a></li><li><a href="Deployment.html"><strong aria-hidden="true">2.2.</strong> Deployment</a></li><li><a href="Drivers.html"><strong aria-hidden="true">2.3.</strong> Drivers</a></li><li><a href="Usage.html"><strong aria-hidden="true">2.4.</strong> Usage</a></li><li><a href="Example.html"><strong aria-hidden="true">2.5.</strong> Example</a></li></ol></li><li><a href="Development.html"><strong aria-hidden="true">3.</strong> Development</a></li><li><ol class="section"><li><a href="CSI-Driver.html"><strong aria-hidden="true">3.1.</strong> Developing a CSI driver</a></li><li><ol class="section"><li><a href="Implement-Snapshot-Feature.html"><strong aria-hidden="true">3.1.1.</strong> Implement Snapshot Feature</a></li></ol></li><li><a href="CSI-Kubernetes.html"><strong aria-hidden="true">3.2.</strong> Deploying in Kubernetes</a></li><li><a href="Testing.html"><strong aria-hidden="true">3.3.</strong> Testing</a></li><li><ol class="section"><li><a href="Testing-Clients.html"><strong aria-hidden="true">3.3.1.</strong> Clients</a></li><li><a href="Testing-Drivers.html"><strong aria-hidden="true">3.3.2.</strong> Drivers</a></li></ol></li></ol></li><li><a href="Troubleshooting.html"><strong aria-hidden="true">4.</strong> Troubleshooting</a></li><li><a href="References.html"><strong aria-hidden="true">5.</strong> References</a></li><li><a href="Archive.html"><strong aria-hidden="true">6.</strong> Archive</a></li><li><ol class="section"><li><a href="Kubernetes-1.9.html"><strong aria-hidden="true">6.1.</strong> Kubernetes 1.9</a></li><li><a href="Kubernetes-1.10.html"><strong aria-hidden="true">6.2.</strong> Kubernetes 1.10</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Kubernetes CSI Documentation</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#introduction" id="introduction"><h1>Introduction</h1></a>
<a class="header" href="#kubernetes-csi-documentation" id="kubernetes-csi-documentation"><h2>Kubernetes CSI Documentation</h2></a>
<p>Welcome to the CSI for Kubernetes documentation repository. Here you will find information on how to use, develop, and deploy CSI plugins, or drivers, with Kubernetes.</p>
<a class="header" href="#project-status" id="project-status"><h2>Project status</h2></a>
<table><thead><tr><th> Kubernetes </th><th> CSI spec </th><th> Status </th></tr></thead><tbody>
<tr><td> v1.9       </td><td> v0.1     </td><td> Alpha  </td></tr>
<tr><td> v1.10      </td><td> v0.2     </td><td> Beta   </td></tr>
<tr><td> v1.11      </td><td> v0.3     </td><td> Beta   </td></tr>
</tbody></table>
<a class="header" href="#sidecar-container-status" id="sidecar-container-status"><h2>Sidecar container status</h2></a>
<table><thead><tr><th> Container Name </th><th> CSI spec </th><th> Latest Release Tag </th></tr></thead><tbody>
<tr><td> csi-provisioner </td><td> v0.3 </td><td> v0.4.1 </td></tr>
<tr><td> csi-attacher </td><td> v0.3 </td><td> v0.4.1 </td></tr>
<tr><td> driver-registrar </td><td> v0.3 </td><td> v0.4.1 </td></tr>
<tr><td> livenessprobe </td><td> v0.3 </td><td> v0.4.1 </td></tr>
</tbody></table>
<a class="header" href="#installation" id="installation"><h2>Installation</h2></a>
<p>Please see the <a href="Setup.html">Setup</a> page for instructions on how to setup Kubernetes support with CSI.</p>
<a class="header" href="#using-csi-drivers" id="using-csi-drivers"><h1>Using CSI Drivers</h1></a>
<p>Before you can start using CSI, you must understand how to properly setup and configure deploy CSI drivers on top of Kubernetes.  This section provides information on</p>
<ul>
<li><a href="Setup.html">Setup</a> - Information on how to setup the CSI feature</li>
<li><a href="Deployment.html">Deployment</a> - Instructions on deploying a driver</li>
<li><a href="Drivers.html">Drivers</a> - A growning list of available CSI driverse you can use</li>
<li><a href="Usage.html">Usage</a> - Findout the usage mode of CSI drivers</li>
<li><a href="Example.html">Example</a> - Using Hostpath as an example CSI driver</li>
</ul>
<a class="header" href="#setup" id="setup"><h1>Setup</h1></a>
<p>This document has been updated for the latest version of Kubernetes v1.12.  This document outlines the features that are available for CSI.  To get step by step instructions on how to run an example CSI driver, you can read the <a href="./Example.html">Example</a> section.</p>
<a class="header" href="#enabling-features" id="enabling-features"><h2>Enabling features</h2></a>
<p>Some of the features discussed here may be at different stages (alpha, beta, or GA).  Ensure that the feature you want to try is enabled for the Kubernetes release you are using.  To avoid version mismatch, you can enable all of the features discussed here for both kubelet and kube-apiserver with:</p>
<pre><code>--feature-gates=VolumeSnapshotDataSource=true,KubeletPluginsWatcher=true,CSINodeInfo=true,CSIDriverRegistry=true
</code></pre>
<a class="header" href="#enable-privileged-pods" id="enable-privileged-pods"><h2>Enable privileged Pods</h2></a>
<p>To use CSI drivers, your Kubernetes cluster must allow privileged pods (i.e. <code>--allow-privileged</code> flag must be set to <code>true</code> for both the API server and the kubelet). This is the default in some environments (e.g. GCE, GKE, <code>kubeadm</code>).</p>
<p>Ensure your API server are started with the privileged flag:</p>
<pre><code class="language-shell">$ ./kube-apiserver ...  --allow-privileged=true ...
</code></pre>
<pre><code class="language-shell">$ ./kubelet ...  --allow-privileged=true ...
</code></pre>
<a class="header" href="#enabling-mount-propagation" id="enabling-mount-propagation"><h2>Enabling mount propagation</h2></a>
<p>Another feature that CSI depends on is mount propagation.  It allows the sharing of volumes mounted by one container with other containers in the same pod, or even to other pods on the same node.  For mount propagation to work, the Docker daemon for the cluster must allow shared mounts. See the <a href="https://kubernetes.io/docs/concepts/storage/volumes/#mount-propagation">mount propagation docs</a> to find out how to enable this feature for your cluster.  <a href="https://docs.portworx.com/knowledgebase/shared-mount-propagation.html">This page</a> explains how to check if shared mounts are enabled and how to configure Docker for shared mounts.</p>
<a class="header" href="#enable-raw-block-volume-support-alpha" id="enable-raw-block-volume-support-alpha"><h2>Enable raw block volume support (alpha)</h2></a>
<p>Kubernetes now has <a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#raw-block-volume-support">raw block volume Support</a> as an alpha implementation. If you want to use the
<a href="https://kubernetes.io/docs/concepts/storage/volumes/#csi-raw-block-volume-support">CSI raw block volume support</a>, you must enable the feature (for your Kubernetes binaries including apiserver, kubelet, controller manager, etc) with the  <code>feature-gates</code> flag as follow:</p>
<pre><code>$ kube&lt;binary&gt; --feature-gates=BlockVolume=true,CSIBlockVolume=true ...
</code></pre>
<a class="header" href="#csidriver-custom-resource-alpha" id="csidriver-custom-resource-alpha"><h2>CSIDriver custom resource (alpha)</h2></a>
<p>Starting with version 1.12, the <code>CSIDriver</code> custom resource definition (or CRD) has been introduced as a way to represent the CSI drivers running in a cluster. An admin can update the attributes of this object to modify the configuration of its associated driver at runtime.</p>
<blockquote>
<p>You can see the full definition of this CRD <a href="https://github.com/kubernetes/csi-api/blob/master/pkg/crd/crd.go">here</a>.</p>
</blockquote>
<p>The alpha release of <code>CSIDriver</code> exposes three main configuration settings:</p>
<pre><code class="language-yaml">apiVersion: v1
items:
- apiVersion: csi.storage.k8s.io/v1alpha1
  kind: CSIDriver
  metadata:
    name: csi-hostpath
  spec:
    attachRequired: true
    podInfoOnMountVersion: &quot;v1&quot;
</code></pre>
<p>Where:</p>
<ul>
<li><code>metadata:name</code> - the identifying name of the CSI driver.  That name must be unique in the cluster as it is the name that is used to identify the CSI cluster.</li>
<li><code>attachRequired</code> - indicates that the CSI volume driver requires a volume attach operation.  This will cause Kubernetes to call make a <code>CSI.ControllerPublishVolume()</code> call and wait for completion before proceeding to mount.</li>
<li><code>podInfoOnMountVersion</code> - this value indicates that the associated CSI volume driver requires additional pod information (like podName, podUID, etc.) during mount. Leave value empty if you do not want pod info to be transmitted.  Or, provide a value of <code>v1</code> which will cause the Kubelet to send the followings pod information during NodePublishVolume() calls to the driver as <code>VolumeAttributes</code>:</li>
</ul>
<pre><code>csi.storage.k8s.io/pod.name: pod.Name
csi.storage.k8s.io/pod.namespace: pod.Namespace
csi.storage.k8s.io/pod.uid: string(pod.UID)
</code></pre>
<a class="header" href="#enabling-csidriver" id="enabling-csidriver"><h3>Enabling CSIDriver</h3></a>
<p>If you want to use the <code>CSIDriver</code> CRD and get a preview of how configuration will work at runtime, do the followings:</p>
<ol>
<li>Ensure the feature gate is enabled with <code>--feature-gates=CSIDriverRegistry=true</code></li>
<li>Install the <code>CSIDriver</code> CRD on the Kubernetes cluster with the following command:</li>
</ol>
<pre><code>$&gt; kubectl create -f https://raw.githubusercontent.com/kubernetes/csi-api/master/pkg/crd/manifests/csidriver.yaml --validate=false
</code></pre>
<a class="header" href="#listing-registered-csi-drivers" id="listing-registered-csi-drivers"><h3>Listing registered CSI drivers</h3></a>
<p>Using the<code>CSIDriver</code> CRD, it is now possible to query Kubernetes to get a list of registered drivers running in the cluster as shown below:</p>
<pre><code>$&gt; kubectl get csidrivers.csi.storage.k8s.io
NAME           AGE
csi-hostpath   2m
</code></pre>
<p>Or get a more detail view of your registered driver with:</p>
<pre><code>$&gt; kubectl describe csidrivers.csi.storage.k8s.io
Name:         csi-hostpath
Namespace:
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;
API Version:  csi.storage.k8s.io/v1alpha1
Kind:         CSIDriver
Metadata:
  Creation Timestamp:  2018-10-04T21:15:30Z
  Generation:          1
  Resource Version:    390
  Self Link:           /apis/csi.storage.k8s.io/v1alpha1/csidrivers/csi-hostpath
  UID:                 9f854aa6-c81a-11e8-bdce-000c29e88ff1
Spec:
  Attach Required:            true
  Pod Info On Mount Version:
Events:                       &lt;none&gt;
</code></pre>
<a class="header" href="#csinodeinfo-custom-resource-alpha" id="csinodeinfo-custom-resource-alpha"><h2>CSINodeInfo custom resource (alpha)</h2></a>
<p>Object <code>CSINodeInfo</code> is a resource designed to carry binding information between a CSI driver and a cluster node where its volume storage will land.  In the first release, object  <code>CSINodeInfo</code> is used to establish the link between a node, its driver, and the topology keys used for scheduling volume storage.</p>
<blockquote>
<p>You can see the full definition of this CRD <a href="https://github.com/kubernetes/csi-api/blob/master/pkg/crd/crd.go">here</a>.</p>
</blockquote>
<p>The following snippet shows a sample <code>CSIDriverInfo</code> which is usually created by Kubernetes:</p>
<pre><code class="language-yaml">apiVersion: v1
items:
- apiVersion: csi.storage.k8s.io/v1alpha1
  kind: CSINodeInfo
  metadata:
    name: 127.0.0.1
  csiDrivers:
  - driver: csi-hostpath
    nodeID: 127.0.0.1
    topologyKeys: []
...    
</code></pre>
<p>Where:</p>
<ul>
<li><code>csiDrivers</code> - list of CSI drivers running on the node and their properties.</li>
<li><code>driver</code> - the CSI driver that this object refers to.</li>
<li><code>nodeID</code> - the assigned identifier for the node as determined by the driver.</li>
<li><code>topologyKeys</code> - A list of topology keys assigned to the node as supported by the driver.</li>
</ul>
<a class="header" href="#enabling-csinodeinfo" id="enabling-csinodeinfo"><h3>Enabling CSINodeInfo</h3></a>
<p>If you want to use the <code>CSINodeInfo</code> CRD and get a preview of how configuration will work at runtime, do the followings:</p>
<ol>
<li>Ensure the feature gate is enabled with <code>--feature-gates=CSINodeInfo=true</code></li>
<li>Install the <code>CSINodeInfo</code> CRD on the Kubernetes cluster with the following command:</li>
</ol>
<pre><code>$&gt; kubectl create -f https://raw.githubusercontent.com/kubernetes/csi-api/master/pkg/crd/manifests/csinodeinfo.yaml --validate=false
</code></pre>
<a class="header" href="#csi-driver-discovery-beta" id="csi-driver-discovery-beta"><h2>CSI driver discovery (beta)</h2></a>
<p>The CSI driver discovery uses the <a href="https://docs.google.com/document/d/1dtHpGY-gPe9sY7zzMGnm8Ywo09zJfNH-E1KEALFV39s/edit#heading=h.7fe6spexljh6">Kubelet Plugin Watcher</a> feature which allows Kubelet to discover deployed CSI drivers automatically.  The registrar sidecar container exposes an internal registration server via a Unix domain socket path. The Kubelet monitors its <code>registration</code> directory to detect new registration requests. Once detected, the Kubelet contacts the registrar sidecar to query driver information.  The retrieved CSI driver information (including the driver's own socket path) will be used for further interaction with the driver.</p>
<blockquote>
<p>This replaces the previous driver registration mechanism, where the driver-registrar sidecar, rather than kubelet, handles registration.</p>
</blockquote>
<p>Using this discovery feature, instead of the prior registration mechanism, will not have any effect on how drivers behave, however, this will be the way CSI works internally in coming releases.</p>
<a class="header" href="#registrar-sidecar-configuration" id="registrar-sidecar-configuration"><h3>Registrar sidecar configuration</h3></a>
<p>The registrar sidecar container provides configuration functionalities to its associated driver. For instance, using the registrar container, an admin can specify how the driver should behave during volume attachment operations.  Some CLI arguments provided to the registrar container will be used to create the CSIDriver and CSIDriverInfo custom resources discussed earlier.</p>
<p>To configure your driver using the registrar sidecar, you can configure the container as shown in the snippet below:</p>
<pre><code class="language-yaml">- name: driver-registrar
    args:
    - --v=5
    - --csi-address=/csi/csi.sock
    - --mode=node-register
    - --driver-requires-attachment=true
    - --pod-info-mount-version=&quot;v1&quot;
    - --kubelet-registration-path=/var/lib/kubelet/plugins/csi-hostpath/csi.sock
    env:
    - name: KUBE_NODE_NAME
      valueFrom:
        fieldRef:
          apiVersion: v1
          fieldPath: spec.nodeName
    image: quay.io/k8scsi/driver-registrar:v0.4.1
    imagePullPolicy: Always
    volumeMounts:
    - mountPath: /csi
      name: socket-dir
    volumeMounts:
    - name: registration-dir
      mountPath: /registration
...
volumes:
  name: socket-dir
  - hostPath:
      path: /var/lib/kubelet/plugins/csi-hostpath
      type: DirectoryOrCreate
  name: registration-dir
  - hostPath:
      path: /var/lib/kubelet/plugins_registry
      type: Directory
</code></pre>
<p>Where:</p>
<ul>
<li>
<p><code>--csi-address</code> - specifies the Unix domain socket path, on the host, for the CSI driver. It allows the registrar sidecar to communicate with the driver for discovery information.  Mount path <code>/csi</code> is mapped to HostPath entry <code>socket-dir</code> which is mapped to directory <code>/var/lib/kubelet/plugins/csi-hostpath</code></p>
</li>
<li>
<p><code>--mode</code> - this flag specifies how the registar binary will function in either</p>
</li>
<li>
<p><code>--driver-requires-attachment</code> - indicates that this CSI volume driver requires an attach operation (because it implements the CSI <code>ControllerPublishVolume()</code> method), and that Kubernetes should call attach and wait for any attach operation to complete before proceeding to mounting. If value is not specified, default is false meaning attach will not be called.</p>
</li>
<li>
<p><code>--pod-info-mount-version=&quot;v1&quot;</code> - this indicates that the associated CSI volume driver requires additional pod information (like podName, podUID, etc.) during mount. A version of value &quot;v1&quot; will cause the Kubelet send the followings pod information during <code>NodePublishVolume()</code> calls to the driver as VolumeAttributes:</p>
</li>
</ul>
<pre><code>  csi.storage.k8s.io/pod.name: pod.Name
  csi.storage.k8s.io/pod.namespace: pod.Namespace
  csi.storage.k8s.io/pod.uid: string(pod.UID)
</code></pre>
<ul>
<li>
<p><code>--kubelet-registration-path</code> - specifies the fully-qualified path of the Unix domain socket for the CSI driver on the host. This path is constructed using the path from HostPath <code>socket-dir</code> and the additional suffix <code>csi.sock</code>.  The registrar sidecar will provide this path to core CSI components for subsequent volume operations.</p>
</li>
<li>
<p>VolumeMount <code>/csi</code> - is mapped to HostPath <code>/var/lib/kubelet/plugins/csi-hostpath</code>.  It is the root location where the CSI driver's Unix Domain socket file is mounted on the host.</p>
</li>
<li>
<p>VolumeMount <code>/registration</code> is mapped to HostPath <code>/var/lib/kubelet/plugins_registry</code>.  It is the root location where Kubelet watcher scans for new plugin registration.</p>
</li>
</ul>
<a class="header" href="#the-kubelet-root-directory" id="the-kubelet-root-directory"><h3>The Kubelet root directory</h3></a>
<p>In the configuration above, notice that all paths starts with <code>/var/lib/kubelet/plugin</code> That is because the discovery mechanism relies on the Kubelet's root directory (which is by default) <code>/var/lib/kubelet</code>.  Ensure that this path value matches the value specified in the Kubelet's <code>--root-dir</code> argument.</p>
<a class="header" href="#csi-volume-snapshot-support" id="csi-volume-snapshot-support"><h4>CSI Volume Snapshot support</h4></a>
<p><a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/csi-snapshot.md">CSI volume snapshot support</a>: To enable support for Kubernetes volume
snapshotting, you must set the following feature gate on Kubernetes v1.12 (disabled
by default for alpha):</p>
<pre><code>--feature-gates=VolumeSnapshotDataSource=true
</code></pre>
<a class="header" href="#topology-alpha" id="topology-alpha"><h2>Topology (alpha)</h2></a>
<p>In order to support topology-aware dynamic provisioning mechanisms available in Kubernetes, the <em>external-provisioner</em> must have the Topology feature enabled:</p>
<pre><code>--feature-gates=Topology=true
</code></pre>
<p>In addition, in the <em>Kubernetes cluster</em> the <code>CSINodeInfo</code> alpha feature must be enabled (refer to the [CSINodeInfo custom resource]{csinodeinfo-custom-resource-alpha} section for more info):</p>
<pre><code>--feature-gates=CSINodeInfo=true
</code></pre>
<p>as well as the <code>KubeletPluginsWatcher</code> beta feature (currently enabled by default).</p>
<a class="header" href="#archives" id="archives"><h2>Archives</h2></a>
<p>Please visit the <a href="Archive.html">Archives</a> for setup instructions on previous versions of Kubernetes.</p>
<a class="header" href="#deployment" id="deployment"><h1>Deployment</h1></a>
<p>To benefit from the new CSI support, you will need to deploy a CSI driver. Please visit the <a href="Drivers.html">Drivers</a> page to determine how to deploy your specific driver. A functional example based on the HostPath driver is presented in the <a href="Example.html">Example</a> section.</p>
<a class="header" href="#drivers" id="drivers"><h1>Drivers</h1></a>
<p>The following are a set of CSI driver which can be used with Kubernetes:</p>
<blockquote>
<p>NOTE: If you would like your driver to be added to this table, please create an issue in this repo with the information you would like to add here.</p>
</blockquote>
<a class="header" href="#sample-drivers" id="sample-drivers"><h3>Sample Drivers</h3></a>
<table><thead><tr><th>Name </th><th> Status </th><th> More Information</th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/drivers/tree/master/pkg/flexadapter">Flexvolume</a> </td><td> Sample </td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/drivers/tree/master/pkg/hostpath">HostPath</a> </td><td> v0.2.0 </td><td> Only use for a single node tests. See the <a href="Example.html">Example</a> page for Kubernetes-specific instructions.</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/csi-test/tree/master/mock/service">In-memory Sample Mock Driver</a> </td><td> v0.3.0 </td><td> The sample mock driver used for <a href="https://github.com/kubernetes-csi/csi-test/tree/master/cmd/csi-sanity">csi-sanity</a></td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/drivers/tree/master/pkg/nfs">NFS</a> </td><td> Sample </td></tr>
<tr><td><a href="https://github.com/thecodeteam/csi-vfs">VFS Driver</a> </td><td> Released </td><td> A CSI plugin that provides a virtual file system.</td></tr>
</tbody></table>
<a class="header" href="#production-drivers" id="production-drivers"><h3>Production Drivers</h3></a>
<table><thead><tr><th>Name </th><th> Status </th><th> More Information</th></tr></thead><tbody>
<tr><td><a href="https://github.com/DriveScale/k8s-plugins">DriveScale</a></td><td>v1.0.0</td><td>A Container Storage Interface (CSI) Storage Plug-in for DriveScale software composable infrastructure solution</td></tr>
<tr><td><a href="https://github.com/kubernetes/cloud-provider-openstack/tree/master/pkg/csi/cinder">Cinder</a></td><td>v0.2.0</td><td>A Container Storage Interface (CSI) Storage Plug-in for Cinder</td></tr>
<tr><td><a href="https://github.com/digitalocean/csi-digitalocean">DigitalOcean Block Storage</a> </td><td> v0.4.0 </td><td> A Container Storage Interface (CSI) Driver for DigitalOcean Block Storage</td></tr>
<tr><td><a href="https://github.com/kubernetes-sigs/aws-ebs-csi-driver">AWS Elastic Block Storage</a> </td><td> v0.1.0 </td><td> A Container Storage Interface (CSI) Driver for AWS Elastic Block Storage (EBS)</td></tr>
<tr><td><a href="https://github.com/kubernetes-sigs/gcp-compute-persistent-disk-csi-driver">GCE Persistent Disk</a></td><td>Alpha</td><td>A Container Storage Interface (CSI) Storage Plugin for Google Compute Engine Persistent Disk</td></tr>
<tr><td><a href="https://github.com/moosefs/moosefs-csi">MooseFS</a></td><td>v0.0.1 (alpha)</td><td>A Container Storage Interface (CSI) Storage Plugin for <a href="https://moosefs.com/">MooseFS</a> clusters.</td></tr>
<tr><td><a href="https://www.opensds.io/">OpenSDS</a> </td><td> Beta </td><td> For more information, please visit <a href="https://github.com/opensds/nbp/releases">releases</a> and https://github.com/opensds/nbp/tree/master/csi</td></tr>
<tr><td><a href="https://portworx.com/">Portworx</a> </td><td> 0.3.0 </td><td> CSI implementation is available <a href="https://github.com/libopenstorage/openstorage/tree/master/csi">here</a> which can be used as an example also.</td></tr>
<tr><td><a href="https://github.com/ceph/ceph-csi">RBD</a></td><td>v0.2.0</td><td>A Container Storage Interface (CSI) Storage RBD Plug-in for Ceph</td></tr>
<tr><td><a href="https://github.com/ceph/ceph-csi">CephFS</a></td><td>v0.2.0</td><td>A Container Storage Interface (CSI) Storage Plug-in for CephFS</td></tr>
<tr><td><a href="https://github.com/thecodeteam/csi-scaleio">ScaleIO</a></td><td>v0.1.0</td><td>A Container Storage Interface (CSI) Storage Plugin for DellEMC ScaleIO</td></tr>
<tr><td><a href="https://github.com/thecodeteam/csi-vsphere">vSphere</a></td><td>v0.1.0</td><td>A Container Storage Interface (CSI) Storage Plug-in for VMware vSphere</td></tr>
<tr><td><a href="https://github.com/NetApp/trident">NetApp</a> </td><td> v0.2.0 (alpha) </td><td> A Container Storage Interface (CSI) Storage Plug-in for NetApp's <a href="https://netapp-trident.readthedocs.io/">Trident</a> container storage orchestrator</td></tr>
<tr><td><a href="https://ember-csi.io">Ember CSI</a> </td><td> v0.2.0 (alpha) </td><td> Multi-vendor CSI plugin supporting over 80 storage drivers to provide block and mount storage to Container Orchestration systems.</td></tr>
<tr><td><a href="https://portal.nutanix.com/#/page/docs/details?targetId=CSI-Volume-Driver:CSI-Volume-Driver">Nutanix</a> </td><td> beta </td><td> A Container Storage Interface (CSI) Storage Driver for Nutanix</td></tr>
<tr><td><a href="https://github.com/quobyte/quobyte-csi">Quobyte</a> </td><td> v0.2.0 </td><td> A Container Storage Interface (CSI) Plugin for Quobyte</td></tr>
<tr><td><a href="https://github.com/gluster/gluster-csi-driver">GlusterFS</a> </td><td> Beta </td><td> A Container Storage Interface (CSI) Plugin for GlusterFS</td></tr>
</tbody></table>
<a class="header" href="#testing" id="testing"><h2>Testing</h2></a>
<p>There are multiple ways to test your driver. Please see <a href="Testing-Drivers.html">Testing Drivers</a> for more information.</p>
<a class="header" href="#usage" id="usage"><h1>Usage</h1></a>
<p>There are two main models of how to use storage in Kubernetes with CSI drivers. These models include either the usage of pre-provisioned volumes or dynamic provisioned volumes. Please check the documentation of your specific driver for more information.</p>
<a class="header" href="#pre-provisioned-volumes" id="pre-provisioned-volumes"><h3>Pre-provisioned volumes</h3></a>
<p>Pre-provisioned drivers work just as they did before, where the administrator would create a <a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes"><em>PersistentVolume</em></a> specification which would describe the volume to be used. The PersistentVolume specification would need to be setup according to your driver, the difference here is that there is a new section called <em>csi</em> which needs to be setup accordingly. Please see <a href="https://kubernetes.io/docs/concepts/storage/volumes/#csi">Kubernetes Documentation on CSI Volumes</a>.</p>
<p>Here is an example of a <em>PersistentVolume</em> specification of a pre-provisioned volume managed by a CSI driver:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: PersistentVolume
metadata:
  name: manually-created-pv
spec:
  capacity:
    storage: 5Gi
  accessModes:
    - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  csi:
    driver: com.example.team/csi-driver
    volumeHandle: existingVolumeName
    readOnly: false
</code></pre>
<a class="header" href="#dynamic-provisioning" id="dynamic-provisioning"><h3>Dynamic Provisioning</h3></a>
<p>To setup the system for dynamic provisioning, the administrator needs to setup a <a href="https://kubernetes.io/docs/concepts/storage/storage-classes"><em>StorageClass</em></a> pointing to the CSI driverâ€™s external-provisioner and specifying any parameters required by the driver. Here is an example of a StorageClass:</p>
<pre><code class="language-yaml">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: fast-storage
provisioner: com.example.team/csi-driver
parameters:
  type: pd-ssd
</code></pre>
<p>Where,</p>
<ul>
<li><em>provisioner</em>: Must be set to the name of the CSI driver</li>
<li><em>parameters</em>: Must contain any parameters specific to the CSI driver.</li>
</ul>
<p>The user can then create a <em>PersistentVolumeClaim</em> utilizing this StorageClass as follows:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: request-for-storage
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 5Gi
  storageClassName: fast-storage
</code></pre>
<a class="header" href="#csi-provisioner-parameters" id="csi-provisioner-parameters"><h4>CSI Provisioner Parameters</h4></a>
<p>The CSI dynamic provisioner makes <code>CreateVolumeRequest</code> and <code>DeleteVolumeRequest</code> calls to CSI drivers.
The <code>controllerCreateSecrets</code> and <code>controllerDeleteSecrets</code> fields in those requests can be populated
with data from a Kubernetes <code>Secret</code> object by setting <code>csiProvisionerSecretName</code> and <code>csiProvisionerSecretNamespace</code>
parameters in the <code>StorageClass</code>. For example:</p>
<pre><code class="language-yaml">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: fast-storage
provisioner: com.example.team/csi-driver
parameters:
  type: pd-ssd
  csiProvisionerSecretName: fast-storage-provision-key
  csiProvisionerSecretNamespace: pd-ssd-credentials
</code></pre>
<p>The <code>csiProvisionerSecretName</code> and <code>csiProvisionerSecretNamespace</code> parameters
may specify literal values, or a template containing the following variables:</p>
<ul>
<li><code>${pv.name}</code> - replaced with the name of the PersistentVolume object being provisioned</li>
</ul>
<p>Once the CSI volume is created, a corresponding Kubernetes <code>PersistentVolume</code> object is created.
The <code>controllerPublishSecretRef</code>, <code>nodeStageSecretRef</code>, and <code>nodePublishSecretRef</code> fields in the
<code>PersistentVolume</code> object can be populated via the following storage class parameters:</p>
<ul>
<li><code>controllerPublishSecretRef</code> in the PersistentVolume is populated by setting these StorageClass parameters:
<ul>
<li><code>csiControllerPublishSecretName</code></li>
<li><code>csiControllerPublishSecretNamespace</code></li>
</ul>
</li>
<li><code>nodeStageSecretRef</code> in the PersistentVolume is populated by setting these StorageClass parameters:
<ul>
<li><code>csiNodeStageSecretName</code></li>
<li><code>csiNodeStageSecretNamespace</code></li>
</ul>
</li>
<li><code>nodePublishSecretRef</code> in the PersistentVolume is populated by setting these StorageClass parameters:
<ul>
<li><code>csiNodePublishSecretName</code></li>
<li><code>csiNodePublishSecretNamespace</code></li>
</ul>
</li>
</ul>
<p>The <code>csiControllerPublishSecretName</code>, <code>csiNodeStageSecretName</code>, and <code>csiNodePublishSecretName</code> parameters
may specify a literal secret name, or a template containing the following variables:</p>
<ul>
<li><code>${pv.name}</code> - replaced with the name of the PersistentVolume</li>
<li><code>${pvc.name}</code> - replaced with the name of the PersistentVolumeClaim</li>
<li><code>${pvc.namespace}</code> - replaced with the namespace of the PersistentVolumeClaim</li>
<li><code>${pvc.annotations['&lt;ANNOTATION_KEY&gt;']}</code> (e.g. <code>${pvc.annotations['example.com/key']}</code>) - replaced with the value of the specified annotation in the PersistentVolumeClaim</li>
</ul>
<p>The <code>csiControllerPublishSecretNamespace</code>, <code>csiNodeStageSecretNamespace</code>, and <code>csiNodePublishSecretNamespace</code> parameters
may specify a literal namespace name, or a template containing the following variables:</p>
<ul>
<li><code>${pv.name}</code> - replaced with the name of the PersistentVolume</li>
<li><code>${pvc.namespace}</code> - replaced with the namespace of the PersistentVolumeClaim</li>
</ul>
<p>As an example, consider this StorageClass:</p>
<pre><code class="language-yaml">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: fast-storage
provisioner: com.example.team/csi-driver
parameters:
  type: pd-ssd

  csiProvisionerSecretName: fast-storage-provision-key
  csiProvisionerSecretNamespace: pd-ssd-credentials

  csiControllerPublishSecretName: ${pv.name}-publish
  csiControllerPublishSecretNamespace: pd-ssd-credentials

  csiNodeStageSecretName: ${pv.name}-stage
  csiNodeStageSecretNamespace: pd-ssd-credentials

  csiNodePublishSecretName: ${pvc.annotations['com.example.team/key']}
  csiNodePublishSecretNamespace: ${pvc.namespace}
</code></pre>
<p>This StorageClass instructs the CSI provisioner to do the following:</p>
<ul>
<li>send the data in the <code>fast-storage-provision-key</code> secret in the <code>pd-ssd-credentials</code> namespace as part of the create request to the CSI driver</li>
<li>create a PersistentVolume with:
<ul>
<li>a per-volume controller publish and node stage secret, both in the <code>pd-ssd-credentials</code> (those secrets would need to be created separately in response to the PersistentVolume creation before the PersistentVolume could be attached/mounted)</li>
<li>a node publish secret in the same namespace as the PersistentVolumeClaim that triggered the provisioning, with a name specified as an annotation on the PersistentVolumeClaim. This could be used to give the creator of the PersistentVolumeClaim the ability to specify a secret containing a decryption key they have control over.</li>
</ul>
</li>
</ul>
<a class="header" href="#example" id="example"><h1>Example</h1></a>
<p>The
<a href="https://github.com/kubernetes-csi/drivers/tree/master/pkg/hostpath">HostPath</a>
can be used to provision local storage in a single node test. This
section shows how to deploy and use that driver in Kubernetes.</p>
<p>The deployment of a CSI driver determines which RBAC rules are
needed. For example, enabling or disabling leadership election changes
which permissions the external-attacher and external-provisioner need.
This example deployment uses the original RBAC rule files that are
maintained together with those sidecar apps and deploys into the
default namespace.</p>
<p>A real production should copy the RBAC files and customize them as
explained in the comments of those files.</p>
<a class="header" href="#deployment-1" id="deployment-1"><h2>Deployment</h2></a>
<p>This was initially tested with Kubernetes v1.12 and should still work
there. It was also tested with a 1.13 pre-release snapshot. To ensure
that all necessary features are enabled, set the following feature
gate flags to true:</p>
<pre><code>--feature-gates=CSIPersistentVolume=true,MountPropagation=true,VolumeSnapshotDataSource=true,KubeletPluginsWatcher=true,CSINodeInfo=true,CSIDriverRegistry=true
</code></pre>
<p><code>CSIPersistentVolume</code> is enabled by default in v1.10. <code>MountPropagation</code> is enabled by default
in v1.10. <code>VolumeSnapshotDataSource</code> is a new alpha feature in v1.12. <code>KubeletPluginsWatcher</code>
is enabled by default in v1.12. <code>CSINodeInfo</code> and <code>CSIDriverRegistry</code> are new alpha features
in v1.12.</p>
<p>CRDs need to be created manually for <code>CSIDriverRegistry</code> and <code>CSINodeInfo</code>:</p>
<blockquote>
<p>$ kubectl create -f <a href="https://github.com/kubernetes/csi-api/blob/ab0df28581235f5350f27ce9c27485850a3b2802/pkg/crd/testdata/csidriver.yaml">https://raw.githubusercontent.com/kubernetes/csi-api/ab0df28581235f5350f27ce9c27485850a3b2802/pkg/crd/testdata/csidriver.yaml</a> --validate=false
<code>customresourcedefinition.apiextensions.k8s.io/csidrivers.csi.storage.k8s.io created</code></p>
<p>$ kubectl create -f <a href="https://github.com/kubernetes/csi-api/blob/ab0df28581235f5350f27ce9c27485850a3b2802/pkg/crd/testdata/csinodeinfo.yaml">https://raw.githubusercontent.com/kubernetes/csi-api/ab0df28581235f5350f27ce9c27485850a3b2802/pkg/crd/testdata/csinodeinfo.yaml</a> --validate=false
<code>customresourcedefinition.apiextensions.k8s.io/csinodeinfos.csi.storage.k8s.io created</code></p>
</blockquote>
<a class="header" href="#create-rbac-rules-for-csi-provisioner" id="create-rbac-rules-for-csi-provisioner"><h3>Create RBAC rules for CSI provisioner</h3></a>
<blockquote>
<p>$ kubectl create -f <a href="https://github.com/kubernetes-csi/external-provisioner/blob/1cd1c20a6d4b2fcd25c98a008385b436d61d46a4/deploy/kubernetes/rbac.yaml">https://raw.githubusercontent.com/kubernetes-csi/external-provisioner/1cd1c20a6d4b2fcd25c98a008385b436d61d46a4/deploy/kubernetes/rbac.yaml</a></p>
<pre><code>clusterrole.rbac.authorization.k8s.io/external-provisioner-runner created
clusterrolebinding.rbac.authorization.k8s.io/csi-provisioner-role created
role.rbac.authorization.k8s.io/external-provisioner-cfg created
rolebinding.rbac.authorization.k8s.io/csi-provisioner-role-cfg created
</code></pre>
</blockquote>
<a class="header" href="#create-rbac-rules-for-csi-attacher" id="create-rbac-rules-for-csi-attacher"><h3>Create RBAC rules for CSI attacher</h3></a>
<blockquote>
<p>$ kubectl create -f <a href="https://github.com/kubernetes-csi/external-attacher/blob/9da8c6d20d58750ee33d61d0faf0946641f50770/deploy/kubernetes/rbac.yaml">https://raw.githubusercontent.com/kubernetes-csi/external-attacher/9da8c6d20d58750ee33d61d0faf0946641f50770/deploy/kubernetes/rbac.yaml</a></p>
<pre><code>serviceaccount/csi-attacher created
clusterrole.rbac.authorization.k8s.io/external-attacher-runner created
clusterrolebinding.rbac.authorization.k8s.io/csi-attacher-role created
role.rbac.authorization.k8s.io/external-attacher-cfg created
rolebinding.rbac.authorization.k8s.io/csi-attacher-role-cfg created
</code></pre>
</blockquote>
<a class="header" href="#create-rbac-rules-for-node-plugin" id="create-rbac-rules-for-node-plugin"><h3>Create RBAC rules for node plugin</h3></a>
<p>Only the <code>driver-registrar</code> interacts directly with Kubernetes, so it's those RBAC rules that are needed:</p>
<blockquote>
<p>$ kubectl create -f <a href="https://github.com/kubernetes-csi/driver-registrar/blob/87d0059110a8b4a90a6d2b5a8702dd7f3f270b80/deploy/kubernetes/rbac.yaml">https://raw.githubusercontent.com/kubernetes-csi/driver-registrar/87d0059110a8b4a90a6d2b5a8702dd7f3f270b80/deploy/kubernetes/rbac.yaml</a></p>
<pre><code>serviceaccount/csi-driver-registrar created
clusterrole.rbac.authorization.k8s.io/driver-registrar-runner created
clusterrolebinding.rbac.authorization.k8s.io/csi-driver-registrar-role created
</code></pre>
</blockquote>
<a class="header" href="#create-rbac-rules-for-csi-snapshotter" id="create-rbac-rules-for-csi-snapshotter"><h3>Create RBAC rules for CSI snapshotter</h3></a>
<p>The CSI snapshotter is an optional sidecar container. You only need to create these
RBAC rules if you want to test the snapshot feature.</p>
<blockquote>
<p>$ kubectl create -f <a href="https://github.com/kubernetes-csi/external-snapshotter/blob/01bd7f356e6718dee87914232d287631655bef1d/deploy/kubernetes/rbac.yaml">https://raw.githubusercontent.com/kubernetes-csi/external-snapshotter/01bd7f356e6718dee87914232d287631655bef1d/deploy/kubernetes/rbac.yaml</a></p>
<pre><code>serviceaccount/csi-snapshotter created
clusterrole.rbac.authorization.k8s.io/external-snapshotter-runner created
clusterrolebinding.rbac.authorization.k8s.io/csi-snapshotter-role created
</code></pre>
</blockquote>
<a class="header" href="#deploy-driver-registrar-and-hostpath-csi-plugin-in-daemonset-pod" id="deploy-driver-registrar-and-hostpath-csi-plugin-in-daemonset-pod"><h3>Deploy driver-registrar and hostpath CSI plugin in DaemonSet pod</h3></a>
<p>The CSI sidecar apps are going to connect to the CSI driver, therefore
starting it first helps avoid timeouts and intermittent container
restarts:</p>
<blockquote>
<p>$ kubectl create -f <a href="https://github.com/kubernetes/kubernetes/blob/f40a5d1155aae95105a4e9bb8933d750c666e350/test/e2e/testing-manifests/storage-csi/hostpath/hostpath/csi-hostpathplugin.yaml">https://raw.githubusercontent.com/kubernetes/kubernetes/f40a5d1155aae95105a4e9bb8933d750c666e350/test/e2e/testing-manifests/storage-csi/hostpath/hostpath/csi-hostpathplugin.yaml</a>
<code>daemonset.apps/csi-hostpathplugin created</code></p>
<p>$ kubectl get pod</p>
<pre><code>NAME                       READY   STATUS    RESTARTS   AGE
csi-hostpathplugin-4k7hk   2/2     Running   0          22s
</code></pre>
</blockquote>
<a class="header" href="#deploy-csi-provisioner-in-statefulset-pod" id="deploy-csi-provisioner-in-statefulset-pod"><h3>Deploy CSI provisioner in StatefulSet pod</h3></a>
<blockquote>
<p>$ kubectl create -f <a href="https://github.com/kubernetes/kubernetes/blob/f40a5d1155aae95105a4e9bb8933d750c666e350/test/e2e/testing-manifests/storage-csi/hostpath/hostpath/csi-hostpath-provisioner.yaml">https://raw.githubusercontent.com/kubernetes/kubernetes/f40a5d1155aae95105a4e9bb8933d750c666e350/test/e2e/testing-manifests/storage-csi/hostpath/hostpath/csi-hostpath-provisioner.yaml</a></p>
<pre><code>service/csi-hostpath-provisioner created
statefulset.apps/csi-hostpath-provisioner created
</code></pre>
<p>$ kubectl get pod</p>
<pre><code>NAME                         READY   STATUS    RESTARTS   AGE
csi-hostpath-provisioner-0   1/1     Running   0          14s
csi-hostpathplugin-4k7hk     2/2     Running   0          75s
</code></pre>
</blockquote>
<a class="header" href="#deploy-csi-attacher-in-statefulset-pod" id="deploy-csi-attacher-in-statefulset-pod"><h3>Deploy CSI attacher in StatefulSet pod</h3></a>
<blockquote>
<p>$ kubectl create -f <a href="https://github.com/kubernetes/kubernetes/blob/f40a5d1155aae95105a4e9bb8933d750c666e350/test/e2e/testing-manifests/storage-csi/hostpath/hostpath/csi-hostpath-attacher.yaml">https://raw.githubusercontent.com/kubernetes/kubernetes/f40a5d1155aae95105a4e9bb8933d750c666e350/test/e2e/testing-manifests/storage-csi/hostpath/hostpath/csi-hostpath-attacher.yaml</a></p>
<pre><code>service/csi-hostpath-attacher created
statefulset.apps/csi-hostpath-attacher created
</code></pre>
<p>$ kubectl get pod</p>
<pre><code>NAME                         READY   STATUS    RESTARTS   AGE
csi-hostpath-attacher-0      1/1     Running   0          14s
csi-hostpath-provisioner-0   1/1     Running   0          56s
csi-hostpathplugin-4k7hk     2/2     Running   0          117s
</code></pre>
</blockquote>
<a class="header" href="#deploy-livenessprobe-with-csi-plugin" id="deploy-livenessprobe-with-csi-plugin"><h3>Deploy livenessprobe with CSI plugin</h3></a>
<p>The CSI community provides a livenessprobe side-container that can be integrated with the CSI driver services (Node and Controller) to provide the liveness of the CSI service containers.</p>
<p>The livenessprobe side-container will expose the an http endpoint that will be used in a kubernetes liveness probe.</p>
<p>Below is an example configuration which needs to be added to CSI driver services (Node and Controller) yamls:</p>
<p>Note: This example is derived from <a href="https://github.com/kubernetes-csi/livenessprobe#using-livenessprobe">using-livenessprobe</a> from <a href="https://github.com/kubernetes-csi/livenessprobe">kubernetes-csi/livenessprobe</a></p>
<pre><code class="language-yaml">- name: hostpath-driver
    image: quay.io/k8scsi/hostpathplugin:vx.x.x
    imagePullPolicy: Always
    securityContext:
      privileged: true
#
# Defining port which will be used to GET plugin health status
# 9808 is default, but can be changed.
#
    ports:
    - containerPort: 9808
      name: healthz
      protocol: TCP
    livenessProbe:
      failureThreshold: 5
      httpGet:
        path: /healthz
        port: healthz
      initialDelaySeconds: 10
      timeoutSeconds: 3
      periodSeconds: 2
      failureThreshold: 1
...
#
# Spec for liveness probe sidecar container
# 
 - name: liveness-probe
    imagePullPolicy: Always
    volumeMounts:
    - mountPath: /csi
      name: socket-dir
    image: quay.io/k8scsi/livenessprobe:v0.4.1
    args:
    - --csi-address=/csi/csi.sock
    - --connection-timeout=3s
    - --health-port=9898
#
</code></pre>
<p>Where:</p>
<ul>
<li>
<p><code>--csi-address</code> - specifies the Unix domain socket path, as seen in the container, for the CSI driver. It allows the livenessprobe sidecar to communicate with the driver for driver liveness information.  Mount path <code>/csi</code> is mapped to HostPath entry <code>socket-dir</code> which is mapped to directory <code>/var/lib/kubelet/plugins/csi-hostpath</code></p>
</li>
<li>
<p><code>--connection-timeout</code> - specifies the timeout duration of waiting for CSI driver socket in seconds. (default 30s)</p>
</li>
<li>
<p><code>--health-port</code> - specifies the TCP ports for listening healthz requests (default &quot;9808&quot;)</p>
</li>
</ul>
<a class="header" href="#deploy-csi-snapshotter-in-statefulset-pod" id="deploy-csi-snapshotter-in-statefulset-pod"><h3>Deploy CSI snapshotter in StatefulSet pod</h3></a>
<p>The CSI snapshotter is an optional sidecar container. You only need to deploy it if you
want to test the snapshot feature.</p>
<blockquote>
<p>$ kubectl create -f <a href="https://github.com/kubernetes-csi/docs/blob/387dce893e59c1fcf3f4192cbea254440b6f0f07/book/src/example/snapshot/csi-hostpath-snapshotter.yaml">https://raw.githubusercontent.com/kubernetes-csi/docs/387dce893e59c1fcf3f4192cbea254440b6f0f07/book/src/example/snapshot/csi-hostpath-snapshotter.yaml</a></p>
<pre><code>service/csi-hostpath-snapshotter created
statefulset.apps/csi-hostpath-snapshotter created
</code></pre>
<p>$ kubectl get pod</p>
<pre><code>NAME                         READY   STATUS    RESTARTS   AGE
csi-hostpath-attacher-0      1/1     Running   0          58s
csi-hostpath-provisioner-0   1/1     Running   0          100s
csi-hostpath-snapshotter-0   1/1     Running   0          12s
csi-hostpathplugin-4k7hk     2/2     Running   0          2m41s
</code></pre>
</blockquote>
<a class="header" href="#usage-1" id="usage-1"><h2>Usage</h2></a>
<p>Dynamic provisioning is enabled by creating a <code>csi-hostpath-sc</code> storage class.</p>
<blockquote>
<p>$ kubectl create -f <a href="https://github.com/kubernetes-csi/docs/blob/387dce893e59c1fcf3f4192cbea254440b6f0f07/book/src/example/usage/csi-storageclass.yaml">https://raw.githubusercontent.com/kubernetes-csi/docs/387dce893e59c1fcf3f4192cbea254440b6f0f07/book/src/example/usage/csi-storageclass.yaml</a>
<code>storageclass.storage.k8s.io/csi-hostpath-sc created</code></p>
</blockquote>
<p>We can use this storage class to create and claim a new volume:</p>
<blockquote>
<p>$ kubectl create -f <a href="https://github.com/kubernetes-csi/docs/blob/387dce893e59c1fcf3f4192cbea254440b6f0f07/book/src/example/usage/csi-pvc.yaml">https://raw.githubusercontent.com/kubernetes-csi/docs/387dce893e59c1fcf3f4192cbea254440b6f0f07/book/src/example/usage/csi-pvc.yaml</a>
<code>persistentvolumeclaim/csi-pvc created</code></p>
<p>$ kubectl get pvc</p>
<pre><code>NAME      STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS      AGE
csi-pvc   Bound    pvc-0571cc14-c714-11e8-8911-000c2967769a   1Gi        RWO            csi-hostpath-sc   3s
</code></pre>
<p>$ kubectl get pv</p>
<pre><code>NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM             STORAGECLASS      REASON   AGE
pvc-0571cc14-c714-11e8-8911-000c2967769a   1Gi        RWO            Delete           Bound    default/csi-pvc   csi-hostpath-sc            3s
</code></pre>
</blockquote>
<p>The HostPath driver is configured to create new volumes under <code>/tmp</code> inside
the <code>hostpath</code> container in the CSI hostpath plugin DaemonSet pod and thus
persist as long as the DaemonSet pod itself.
We can use such volumes in another pod like this:</p>
<blockquote>
<p>$ kubectl create -f <a href="https://github.com/kubernetes-csi/docs/blob/387dce893e59c1fcf3f4192cbea254440b6f0f07/book/src/example/usage/csi-app.yaml">https://raw.githubusercontent.com/kubernetes-csi/docs/387dce893e59c1fcf3f4192cbea254440b6f0f07/book/src/example/usage/csi-app.yaml</a>
<code>pod/my-csi-app created</code></p>
<p>$ kubectl get pods</p>
<pre><code>NAME                         READY   STATUS    RESTARTS   AGE
csi-hostpath-attacher-0      1/1     Running   0          117s
csi-hostpath-provisioner-0   1/1     Running   0          2m39s
csi-hostpath-snapshotter-0   1/1     Running   0          71s
csi-hostpathplugin-4k7hk     2/2     Running   0          3m40s
my-csi-app                   1/1     Running   0          14s
</code></pre>
<p>$ kubectl describe pods/my-csi-app</p>
<pre><code>Name:               my-csi-app
Namespace:          default
Priority:           0
PriorityClassName:  &lt;none&gt;
Node:               127.0.0.1/127.0.0.1
Start Time:         Wed, 03 Oct 2018 06:59:19 -0700
Labels:             &lt;none&gt;
Annotations:        &lt;none&gt;
Status:             Running
IP:                 172.17.0.5
Containers:
  my-frontend:
    Container ID:  docker://fd2950af39a155bdf08d1da341cfb23aa0d1af3eaaad6950a946355789606e8c
    Image:         busybox
    Image ID:      docker-pullable://busybox@sha256:2a03a6059f21e150ae84b0973863609494aad70f0a80eaeb64bddd8d92465812
    Port:          &lt;none&gt;
    Host Port:     &lt;none&gt;
    Command:
      sleep
      1000000
    State:          Running
      Started:      Wed, 03 Oct 2018 06:59:22 -0700
    Ready:          True
    Restart Count:  0
    Environment:    &lt;none&gt;
    Mounts:
      /data from my-csi-volume (rw)
      /var/run/secrets/kubernetes.io/serviceaccount from default-token-xms2g (ro)
Conditions:
  Type              Status
  Initialized       True
  Ready             True
  ContainersReady   True
  PodScheduled      True
Volumes:
  my-csi-volume:
    Type:       PersistentVolumeClaim (a reference to a PersistentVolumeClaim in the same namespace)
    ClaimName:  csi-pvc
    ReadOnly:   false
  default-token-xms2g:
    Type:        Secret (a volume populated by a Secret)
    SecretName:  default-token-xms2g
    Optional:    false
QoS Class:       BestEffort
Node-Selectors:  &lt;none&gt;
Tolerations:     node.kubernetes.io/not-ready:NoExecute for 300s
                 node.kubernetes.io/unreachable:NoExecute for 300s
Events:
  Type    Reason                  Age   From                     Message
  ----    ------                  ----  ----                     -------
  Normal  Scheduled               69s   default-scheduler        Successfully assigned default/my-csi-app to 127.0.0.1
  Normal  SuccessfulAttachVolume  69s   attachdetach-controller  AttachVolume.Attach succeeded for volume &quot;pvc-0571cc14-c714-11e8-8911-000c2967769a&quot;
  Normal  Pulling                 67s   kubelet, 127.0.0.1       pulling image &quot;busybox&quot;
  Normal  Pulled                  67s   kubelet, 127.0.0.1       Successfully pulled image &quot;busybox&quot;
  Normal  Created                 67s   kubelet, 127.0.0.1       Created container
  Normal  Started                 66s   kubelet, 127.0.0.1       Started container
</code></pre>
</blockquote>
<a class="header" href="#confirming-the-setup" id="confirming-the-setup"><h2>Confirming the setup</h2></a>
<p>Writing inside the app container should be visible in <code>/tmp</code> of the <code>hostpath</code> container:</p>
<pre><code>$ kubectl exec -it my-csi-app /bin/sh
/ # touch /data/hello-world
/ # exit

$ kubectl exec -it $(kubectl get pods --selector app=csi-hostpathplugin -o jsonpath='{.items[*].metadata.name}') -c hostpath /bin/sh
/ # find / -name hello-world
/tmp/057485ab-c714-11e8-bb16-000c2967769a/hello-world
/ # exit
</code></pre>
<p>There should be a <code>VolumeAttachment</code> while the app has the volume mounted:</p>
<blockquote>
<p>$ kubectl get VolumeAttachment</p>
<pre><code>Name:         csi-a4e97f3af2161c6d081b8e96c58ed00c9bf1e1745e89b2545e24505437f015df
Namespace:
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;
API Version:  storage.k8s.io/v1beta1
Kind:         VolumeAttachment
Metadata:
  Creation Timestamp:  2018-10-03T13:59:19Z
  Resource Version:    1730
  Self Link:           /apis/storage.k8s.io/v1beta1/volumeattachments/csi-a4e97f3af2161c6d081b8e96c58ed00c9bf1e1745e89b2545e24505437f015df
  UID:                 862d7241-c714-11e8-8911-000c2967769a
Spec:
  Attacher:   csi-hostpath
  Node Name:  127.0.0.1
  Source:
    Persistent Volume Name:  pvc-0571cc14-c714-11e8-8911-000c2967769a
Status:
  Attached:  true
Events:      &lt;none&gt;
</code></pre>
</blockquote>
<a class="header" href="#snapshot-support" id="snapshot-support"><h2>Snapshot support</h2></a>
<p>Enable dynamic provisioning of volume snapshot by creating a volume snapshot
class as follows:</p>
<blockquote>
<p>$ kubectl create -f <a href="https://github.com/kubernetes-csi/docs/blob/387dce893e59c1fcf3f4192cbea254440b6f0f07/book/src/example/snapshot/csi-snapshotclass.yaml">https://raw.githubusercontent.com/kubernetes-csi/docs/387dce893e59c1fcf3f4192cbea254440b6f0f07/book/src/example/snapshot/csi-snapshotclass.yaml</a>
<code>volumesnapshotclass.snapshot.storage.k8s.io/csi-hostpath-snapclass created</code></p>
<p>$ kubectl get volumesnapshotclass</p>
<pre><code>NAME                     AGE
csi-hostpath-snapclass   11s
</code></pre>
<p>$ kubectl describe volumesnapshotclass</p>
<pre><code>Name:         csi-hostpath-snapclass
Namespace:
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;
API Version:  snapshot.storage.k8s.io/v1alpha1
Kind:         VolumeSnapshotClass
Metadata:
  Creation Timestamp:  2018-10-03T14:15:30Z
  Generation:          1
  Resource Version:    2418
  Self Link:           /apis/snapshot.storage.k8s.io/v1alpha1/volumesnapshotclasses/csi-hostpath-snapclass
  UID:                 c8f5bc47-c716-11e8-8911-000c2967769a
Snapshotter:           csi-hostpath
Events:                &lt;none&gt;
</code></pre>
</blockquote>
<p>Use the volume snapshot class to dynamically create a volume snapshot:</p>
<blockquote>
<p>$ kubectl create -f <a href="https://github.com/kubernetes-csi/docs/blob/387dce893e59c1fcf3f4192cbea254440b6f0f07/book/src/example/snapshot/csi-snapshot.yaml">https://raw.githubusercontent.com/kubernetes-csi/docs/387dce893e59c1fcf3f4192cbea254440b6f0f07/book/src/example/snapshot/csi-snapshot.yaml</a>
<code>volumesnapshot.snapshot.storage.k8s.io/new-snapshot-demo created</code></p>
<p>$ kubectl get volumesnapshot</p>
<pre><code>NAME                AGE
new-snapshot-demo   12s
</code></pre>
<p>$ kubectl get volumesnapshotcontent</p>
<pre><code>NAME                                               AGE
snapcontent-f55db632-c716-11e8-8911-000c2967769a   14s
</code></pre>
<p>$ kubectl describe volumesnapshot</p>
<pre><code>Name:         new-snapshot-demo
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;
API Version:  snapshot.storage.k8s.io/v1alpha1
Kind:         VolumeSnapshot
Metadata:
  Creation Timestamp:  2018-10-03T14:16:45Z
  Generation:          1
  Resource Version:    2476
  Self Link:           /apis/snapshot.storage.k8s.io/v1alpha1/namespaces/default/volumesnapshots/new-snapshot-demo
  UID:                 f55db632-c716-11e8-8911-000c2967769a
Spec:
  Snapshot Class Name:    csi-hostpath-snapclass
  Snapshot Content Name:  snapcontent-f55db632-c716-11e8-8911-000c2967769a
  Source:
    Kind:  PersistentVolumeClaim
    Name:  csi-pvc
Status:
  Creation Time:  2018-10-03T14:16:45Z
  Ready:          true
  Restore Size:   1Gi
Events:           &lt;none&gt;
</code></pre>
<p>$ kubectl describe volumesnapshotcontent</p>
<pre><code>Name:         snapcontent-f55db632-c716-11e8-8911-000c2967769a
Namespace:
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;
API Version:  snapshot.storage.k8s.io/v1alpha1
Kind:         VolumeSnapshotContent
Metadata:
  Creation Timestamp:  2018-10-03T14:16:45Z
  Generation:          1
  Resource Version:    2474
  Self Link:           /apis/snapshot.storage.k8s.io/v1alpha1/volumesnapshotcontents/snapcontent-f55db632-c716-11e8-8911-000c2967769a
  UID:                 f561411f-c716-11e8-8911-000c2967769a
Spec:
  Csi Volume Snapshot Source:
    Creation Time:    1538576205471577525
    Driver:           csi-hostpath
    Restore Size:     1073741824
    Snapshot Handle:  f55ff979-c716-11e8-bb16-000c2967769a
  Persistent Volume Ref:
    API Version:        v1
    Kind:               PersistentVolume
    Name:               pvc-0571cc14-c714-11e8-8911-000c2967769a
    Resource Version:   1573
    UID:                0575b966-c714-11e8-8911-000c2967769a
  Snapshot Class Name:  csi-hostpath-snapclass
  Volume Snapshot Ref:
    API Version:       snapshot.storage.k8s.io/v1alpha1
    Kind:              VolumeSnapshot
    Name:              new-snapshot-demo
    Namespace:         default
    Resource Version:  2472
    UID:               f55db632-c716-11e8-8911-000c2967769a
Events:                &lt;none&gt;
</code></pre>
</blockquote>
<a class="header" href="#restore-volume-from-snapshot-support" id="restore-volume-from-snapshot-support"><h2>Restore volume from snapshot support</h2></a>
<p>Follow the following example to create a volume from a volume snapshot:</p>
<blockquote>
<p>$ kubectl create -f <a href="https://github.com/kubernetes-csi/docs/blob/387dce893e59c1fcf3f4192cbea254440b6f0f07/book/src/example/snapshot/csi-restore.yaml">https://raw.githubusercontent.com/kubernetes-csi/docs/387dce893e59c1fcf3f4192cbea254440b6f0f07/book/src/example/snapshot/csi-restore.yaml</a>
<code>persistentvolumeclaim/hpvc-restore created</code></p>
<p>$ kubectl get pvc</p>
<pre><code>NAME           STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS      AGE
csi-pvc        Bound    pvc-0571cc14-c714-11e8-8911-000c2967769a   1Gi        RWO            csi-hostpath-sc   24m
hpvc-restore   Bound    pvc-77324684-c717-11e8-8911-000c2967769a   1Gi        RWO            csi-hostpath-sc   6s
</code></pre>
<p>$ kubectl get pv</p>
<pre><code>NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                  STORAGECLASS      REASON   AGE
pvc-0571cc14-c714-11e8-8911-000c2967769a   1Gi        RWO            Delete           Bound    default/csi-pvc        csi-hostpath-sc            25m
pvc-77324684-c717-11e8-8911-000c2967769a   1Gi        RWO            Delete           Bound    default/hpvc-restore   csi-hostpath-sc            33s
</code></pre>
</blockquote>
<p>If you encounter any problems, please check the <a href="Troubleshooting.html">Troubleshooting page</a>.</p>
<a class="header" href="#development" id="development"><h1>Development</h1></a>
<p>This section describes to developers how to create and deploy a CSI driver for Kubernetes.</p>
<a class="header" href="#developing-a-csi-driver" id="developing-a-csi-driver"><h1>Developing a CSI driver</h1></a>
<p>To write a CSI Driver, a developer must create an application which implements the three <em>Identity</em>, <em>Controller</em>, and <em>Node</em> services as described in the <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md#rpc-interface">CSI specification</a>.</p>
<p>The <a href="Drivers.html">Drivers</a> page contains a set of drivers which may be used as an example of how to write a CSI driver.</p>
<p>If this is your first driver, you can start with the <a href="https://github.com/kubernetes-csi/csi-test/tree/master/mock/service">in-memory sample Mock Driver</a> used for <a href="https://github.com/kubernetes-csi/csi-test/tree/master/cmd/csi-sanity">csi-sanity</a></p>
<a class="header" href="#other-resources" id="other-resources"><h1>Other Resources</h1></a>
<p>Here are some other resources useful for writing CSI drivers:</p>
<ul>
<li><a href="https://arslan.io/2018/06/21/how-to-write-a-container-storage-interface-csi-plugin/">How to write a Container Storage Interface (CSI) plugin - by Fatih Arslan</a></li>
<li><a href="https://medium.com/@maniankara/understanding-the-container-storage-interface-csi-ddbeb966a3b">Understanding Container Storage Interface (CSI) - by Anoop Maniankara</a> (4 min read)</li>
</ul>
<a class="header" href="#implement-snapshot-feature" id="implement-snapshot-feature"><h1>Implement Snapshot Feature</h1></a>
<p>To implement the snapshot feature, a CSI driver needs to support controller capabilities CREATE_DELETE_SNAPSHOT and LIST_SNAPSHOTS, and implement controller RPCs CreateSnapshot, DeleteSnapshot, and ListSnapshots. For details,  see the CSI spec <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md">here</a>.</p>
<p>Here are some example CSI plugins that have implemented the snapshot feature:</p>
<ul>
<li><a href="https://github.com/kubernetes-sigs/gcp-compute-persistent-disk-csi-driver">GCE PD CSI driver</a></li>
<li><a href="https://github.com/opensds/nbp/tree/master/csi/server">OpenSDS CSI driver</a></li>
<li><a href="https://github.com/ceph/ceph-csi/tree/master/pkg/rbd">Ceph RBD CSI driver</a></li>
<li><a href="https://github.com/gluster/gluster-csi-driver">GlusterFS CSI driver</a></li>
</ul>
<p>You can find more sample and production CSI drivers <a href="https://kubernetes-csi.github.io/docs/Drivers.html">here</a>. Please note that drivers may or may not have implemented the snapshot feature.</p>
<a class="header" href="#snapshot-apis" id="snapshot-apis"><h2>Snapshot APIs</h2></a>
<p>The volume snapshot APIs are implemented as CRDs <a href="https://github.com/kubernetes-csi/external-snapshotter/tree/master/pkg/apis/volumesnapshot/v1alpha1">here</a>. Once you deploy the CSI sidecar containers which includes the external snapshotter in your cluster, the external-snapshotter will pre-install the Snapshot CRDs.</p>
<a class="header" href="#enable-volumesnapshotdatasource-feature-gate" id="enable-volumesnapshotdatasource-feature-gate"><h2>Enable VolumeSnapshotDataSource Feature Gate</h2></a>
<p>Since volume snapshot is an alpha feature in Kubernetes v1.12, you need to enable a new alpha feature gate called VolumeSnapshotDataSource in API server binary.</p>
<pre><code>--feature-gates=VolumeSnapshotDataSource=true
</code></pre>
<a class="header" href="#deploy-external-snapshotter-with-csi-driver" id="deploy-external-snapshotter-with-csi-driver"><h2>Deploy External-Snapshotter with CSI Driver</h2></a>
<p>The snapshot controller is implemented as a sidecar helper container called <a href="https://github.com/kubernetes-csi/external-snapshotter">External-Snapshotter</a>. <em>External-Snapshotter</em> watches <em>VolumeSnapshot</em> and <em>VolumeSnapshotContent</em> API objects and triggers <em>CreateSnapshot</em> and <em>DeleteSnapshot</em> operations.</p>
<p>It is recommended that sidecar containers <em>External-Snapshotter</em> and <em>External-Provisioner</em> be deployed together with CSI driver in a StatefulSet. See this <a href="https://github.com/kubernetes-csi/external-snapshotter/tree/master/deploy/kubernetes/setup-csi-snapshotter.yaml">example yaml file</a> which deploys <em>External-Snapshotter</em> and <em>External-Provisioner</em> with the Hostpath CSI driver. Run the following command to start the sidecar containers and the CSI driver:</p>
<pre><code>kubectl create -f setup-csi-snapshotter.yaml
</code></pre>
<a class="header" href="#test-snapshot-feature" id="test-snapshot-feature"><h2>Test Snapshot Feature</h2></a>
<p>Use the following <a href="https://github.com/kubernetes-csi/external-snapshotter/tree/master/examples/kubernetes">example yaml files</a> to test the snapshot feature.</p>
<p>Create a <em>StorageClass</em>:</p>
<pre><code>kubectl create -f storageclass.yaml
</code></pre>
<p>Create a <em>PVC</em>:</p>
<pre><code>kubectl create -f pvc.yaml
</code></pre>
<p>Create a <em>VolumeSnapshotClass</em>:</p>
<pre><code>kubectl create -f snapshotclass.yaml
</code></pre>
<p>Create a <em>VolumeSnapshot</em>:</p>
<pre><code>kubectl create -f snapshot.yaml
</code></pre>
<p>Create a <em>PVC</em> from a <em>VolumeSnapshot</em>:</p>
<pre><code>kuberctl create -f restore.yaml
</code></pre>
<a class="header" href="#pvc-not-bound" id="pvc-not-bound"><h3>PVC not Bound</h3></a>
<p>If a PVC is not bound, the attempt to create a volume snapshot from that PVC will fail. No retries will be attempted. An event will be logged to indicate that the PVC is not bound.</p>
<p>Note that this could happen if the PVC spec and the VolumeSnapshot spec are in the same yaml file. In this case, when the VolumeSnapshot object is created, the PVC object is created but volume creation is not complete and therefore PVC is not bound yet. You need to wait until the PVC is bound and try to create the snapshot again.</p>
<a class="header" href="#deploying-in-kubernetes" id="deploying-in-kubernetes"><h1>Deploying in Kubernetes</h1></a>
<p>This page describes to CSI driver developers how to deploy their driver onto a Kubernetes cluster.</p>
<a class="header" href="#overview" id="overview"><h2>Overview</h2></a>
<p>There are three components plus the kubelet that enable CSI drivers to provide storage to Kubernetes. These components are sidecar containers which are responsible for communication with both Kubernetes and the CSI driver, making the appropriate CSI calls for their respectful Kubernetes events.</p>
<a class="header" href="#sidecar-containers" id="sidecar-containers"><h2>Sidecar Containers</h2></a>
<p><a href="https://docs.google.com/a/greatdanedata.com/drawings/d/1JExJ_98dt0NAsJ7iI0_9loeTn2rbLeEcpOMEvKrF-9w/edit?usp=sharing"><img src="images/sidecar-container.png" alt="sidecar-container" /></a></p>
<p>Sidecar containers manage Kubernetes events and make the appropriate calls to the CSI driver. These are the <em>external attacher</em>, <em>external provisioner</em>, <em>external snapshotter</em> and the <em>driver registrar</em>.</p>
<a class="header" href="#external-attacher" id="external-attacher"><h3>External Attacher</h3></a>
<p><a href="https://github.com/kubernetes-csi/external-attacher">external-attacher</a> is a sidecar container that watches Kubernetes <em>VolumeAttachment</em> objects and triggers CSI <em>ControllerPublish</em> and <em>ControllerUnpublish</em> operations against a driver endpoint. As of this writing, the external attacher does not support leader election and therefore there can be only one running per CSI driver.  For more information please read <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md#attaching-and-detaching"><em>Attaching and Detaching</em></a>.</p>
<p>Note, even though this is called the <em>external attacher</em>, its function is to call the CSI API calls <em>ControllerPublish</em> and <em>ControllerUnpublish</em>. These calls most likely will occur in a node which is <em>not</em> the one that will mount the volume. For this reason, many CSI drivers do not support these calls, instead doing the attach/detach and mount/unmount both in the CSI <em>NodePublish</em> and <em>NodeUnpublish</em> calls done by the kubelet at the node which is supposed to mount.</p>
<a class="header" href="#external-provisioner" id="external-provisioner"><h3>External Provisioner</h3></a>
<p><a href="https://github.com/kubernetes-csi/external-provisioner">external-provisioner</a> is a Sidecar container that watches Kubernetes <em>PersistentVolumeClaim</em> objects and triggers CSI <em>CreateVolume</em> and <em>DeleteVolume</em> operations against a driver endpoint. For more information please read <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md#provisioning-and-deleting"><em>Provisioning and Deleting</em></a>.</p>
<a class="header" href="#external-snapshotter" id="external-snapshotter"><h3>External Snapshotter</h3></a>
<p><a href="https://github.com/kubernetes-csi/external-snapshotter">external-snapshotter</a> is a Sidecar container that watches Kubernetes <em>VolumeSnapshot</em> objects and triggers CSI <em>CreateSnapshot</em> and <em>DeleteSnapshot</em> operations against a driver endpoint. For more information please read <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/csi-snapshot.md"><em>Snapshot Design Proposal</em></a>.</p>
<a class="header" href="#driver-registrar" id="driver-registrar"><h3>Driver Registrar</h3></a>
<p><a href="https://github.com/kubernetes-csi/driver-registrar">driver-registrar</a> is a sidecar container that registers the CSI driver with kubelet, and adds the drivers custom NodeId to a label on the Kubernetes Node API Object. It does this by communicating with the <em>Identity</em> service on the CSI driver and also calling the CSI <em>GetNodeId</em> operation. The driver registrar must have the Kubernetes name for the node set through the environment variable <code>KUBE_NODE_NAME</code> as follows:</p>
<pre><code class="language-yaml">        - name: csi-driver-registrar
          imagePullPolicy: Always
          image: quay.io/k8scsi/driver-registrar:v0.2.0
          args:
            - &quot;--v=5&quot;
            - &quot;--csi-address=$(ADDRESS)&quot;
          env:
            - name: ADDRESS
              value: /csi/csi.sock
            - name: KUBE_NODE_NAME
              valueFrom:
                fieldRef:
                  fieldPath: spec.nodeName
          volumeMounts:
            - name: socket-dir
              mountPath: /csi
</code></pre>
<a class="header" href="#kubelet" id="kubelet"><h3>Kubelet</h3></a>
<p><a href="https://docs.google.com/a/greatdanedata.com/drawings/d/1NXaVNDh3mSDhog7Q3Y9eELyEF24F8Z-Kk0ujR3pyOes/edit?usp=sharing"><img src="images/kubelet.png" alt="kubelet" /></a></p>
<p>The Kubernetes kubelet runs on every node and is responsible for making the CSI calls <em>NodePublish</em> and <em>NodeUnpublish</em>. These calls mount and unmount the storage volume from the storage system, making it available to the Pod to consume. As shown in the <em>external-attacher</em>, most CSI drivers choose to implement both their attach/detach and mount/unmount calls in the <em>NodePublish</em> and <em>NodeUnpublish</em> calls. They do this because the kubelet makes the request on the node which is to consume the volume.</p>
<a class="header" href="#mount-point" id="mount-point"><h3>Mount point</h3></a>
<p>The mount point used by the CSI driver must be set to <em>Bidirectional</em>. See the example below:</p>
<pre><code class="language-yaml">          volumeMounts:
            - name: socket-dir
              mountPath: /csi
            - name: mountpoint-dir
              mountPath: /var/lib/kubelet/pods
              mountPropagation: &quot;Bidirectional&quot;
      volumes:
        - name: socket-dir
          hostPath:
            path: /var/lib/kubelet/plugins/csi-hostpath
            type: DirectoryOrCreate
        - name: mountpoint-dir
          hostPath:
            path: /var/lib/kubelet/pods
            type: Directory
</code></pre>
<a class="header" href="#rbac-rules" id="rbac-rules"><h3>RBAC Rules</h3></a>
<p>Side car containers need the appropriate permissions to be able to access and manipulate Kubernetes objects. Here are the RBAC rules needed:</p>
<pre><code class="language-yaml">kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: csi-hostpath-role
rules:
  - apiGroups: [&quot;&quot;]
    resources: [&quot;persistentvolumes&quot;]
    verbs: [&quot;create&quot;, &quot;delete&quot;, &quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;update&quot;]
  - apiGroups: [&quot;&quot;]
    resources: [&quot;persistentvolumeclaims&quot;]
    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;update&quot;]
  - apiGroups: [&quot;&quot;]
    resources: [&quot;nodes&quot;]
    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;update&quot;]
  - apiGroups: [&quot;storage.k8s.io&quot;]
    resources: [&quot;storageclasses&quot;]
    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]
  - apiGroups: [&quot;storage.k8s.io&quot;]
    resources: [&quot;volumeattachments&quot;]
    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;update&quot;]
</code></pre>
<a class="header" href="#deploying" id="deploying"><h2>Deploying</h2></a>
<p>Deploying a CSI driver onto Kubernetes is highlighted in detail in <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md#recommended-mechanism-for-deploying-csi-drivers-on-kubernetes"><em>Recommended Mechanism for Deploying CSI Drivers on Kubernetes</em></a>.</p>
<a class="header" href="#examples" id="examples"><h3>Examples</h3></a>
<ul>
<li>Simple deployment example using a single pod for all components: see the <a href="Example.html">hostpath example</a>.</li>
<li>Full deployment example using a <em>DaemonSet</em> for the node plugin and <em>StatefulSet</em> for the controller plugin: check the <a href="https://github.com/kubernetes-csi/drivers/tree/master/pkg/nfs/deploy/kubernetes">NFS driver deployment files</a>.</li>
</ul>
<a class="header" href="#more-information" id="more-information"><h2>More information</h2></a>
<p>For more information, please read <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md"><em>CSI Volume Plugins in Kubernetes Design Doc</em></a>.</p>
<a class="header" href="#testing-1" id="testing-1"><h1>Testing</h1></a>
<p>This document describes to developers how they can test their CSI clients or drivers.</p>
<a class="header" href="#testing-csi-clients" id="testing-csi-clients"><h1>Testing CSI Clients</h1></a>
<p>If you are writing a CSI client, like a CO or a side car container, then you can use some of the following methods to test your application.</p>
<ul>
<li><em>csi-test unit test mock driver</em>: The csi-test repo provides an automatically generated Golang mock code to be used for unit tests.</li>
<li><em>mock-driver</em>: This driver can be used as an external service to test your gRPC calls.</li>
<li><em>hostPath driver</em>: This driver can be used on a single node to tests for mounting and unmounting of storage.</li>
</ul>
<a class="header" href="#csi-test-unit-test-mock-driver" id="csi-test-unit-test-mock-driver"><h1>CSI-Test Unit Test Mock Driver</h1></a>
<p>The <a href="https://github.com/kubernetes-csi/csi-test">csi-test</a> unit test mock driver enables Golang clients to test all aspects of their code. This is done by using the mock driver generated using <a href="https://github.com/golang/mock">GoMock</a>, which let's the caller verify parameters and test for returned values. Here is a small example:</p>
<pre><code class="language-go">    // Setup mock
    m := gomock.NewController(&amp;mock_utils.SafeGoroutineTester{})
    defer m.Finish()
    driver := mock_driver.NewMockIdentityServer(m)

    // Setup input
    in := &amp;csi.GetPluginInfoRequest{
        Version: &amp;csi.Version{
            Major: 0,
            Minor: 1,
            Patch: 0,
        },
    }

    // Setup mock outout
    out := &amp;csi.GetPluginInfoResponse{
        Name:          &quot;mock&quot;,
        VendorVersion: &quot;0.1.1&quot;,
        Manifest: map[string]string{
            &quot;hello&quot;: &quot;world&quot;,
        },
    }

    // Setup expectation
    // !IMPORTANT!: Must set context expected value to gomock.Any() to match any value
    driver.EXPECT().GetPluginInfo(gomock.Any(), in).Return(out, nil).Times(1)

    // Create a new RPC
    server := mock_driver.NewMockCSIDriver(&amp;mock_driver.MockCSIDriverServers{
        Identity: driver,
    })
    conn, err := server.Nexus()
    if err != nil {
        t.Errorf(&quot;Error: %s&quot;, err.Error())
    }
    defer server.Close()

    // Make call
    c := csi.NewIdentityClient(conn)
    r, err := c.GetPluginInfo(context.Background(), in)
    if err != nil {
        t.Errorf(&quot;Error: %s&quot;, err.Error())
    }

    name := r.GetName()
    if name != &quot;mock&quot; {
        t.Errorf(&quot;Unknown name: %s\n&quot;, name)
    }
</code></pre>
<a class="header" href="#more-information-1" id="more-information-1"><h2>More Information</h2></a>
<p>For more examples and information see:</p>
<ul>
<li><a href="https://github.com/kubernetes-csi/external-attacher/blob/master/pkg/connection/connection_test.go">external-attacher side car container</a></li>
<li><a href="https://github.com/golang/mock">Golang GoMock</a></li>
</ul>
<a class="header" href="#hostpath-driver" id="hostpath-driver"><h1>HostPath Driver</h1></a>
<p>The <a href="https://github.com/kubernetes-csi/drivers/tree/master/pkg/hostpath">hostPath</a> driver is probably the simplest CSI driver to use for testing on a single node. This is the driver that is for CSI e2e tests in Kubernetes. See the <a href="Example.html">Example</a> page for deployment and usage instructions.</p>
<a class="header" href="#testing-csi-drivers" id="testing-csi-drivers"><h1>Testing CSI Drivers</h1></a>
<p>There are multiple ways to test your driver, some still in development. This page will describe each of the multiple methods to test your driver.</p>
<a class="header" href="#unit-testing" id="unit-testing"><h2>Unit Testing</h2></a>
<p>There are multiple ways to test your driver. One way is to exercise every call by writing your own client for your unit tests as done in the <a href="https://github.com/libopenstorage/openstorage/tree/master/csi">Portworx driver</a>.</p>
<p>Another way to test your driver is to use the <a href="https://github.com/kubernetes-csi/csi-test/tree/master/pkg/sanity"><code>sanity</code></a> package from <a href="https://github.com/kubernetes-csi/csi-test">csi-test</a>. This simple package contains a single call which will test your driver according to the CSI specification. Here is an example of how it can be used:</p>
<pre><code class="language-go">func TestMyDriver(t *testing.T) {
    // Setup the full driver and its environment
    ... setup driver ...

    // Now call the test suite
    sanity.Test(t, driverEndpointAddress)
}
</code></pre>
<a class="header" href="#functional-testing" id="functional-testing"><h2>Functional Testing</h2></a>
<p>For functional testing you can again provide your own model, or some of the following tools:</p>
<a class="header" href="#csi-sanity" id="csi-sanity"><h3>csi-sanity</h3></a>
<p><a href="https://github.com/kubernetes-csi/csi-test/tree/master/cmd/csi-sanity">csi-sanity</a> is a program from <a href="https://github.com/kubernetes-csi/csi-test">csi-test</a> which tests your driver based on the <a href="https://github.com/kubernetes-csi/csi-test/tree/master/pkg/sanity"><code>sanity</code></a> package.</p>
<p>Here is a sample way to use it:</p>
<pre><code>$ csi-sanity --ginkgo.v --csi.endpoint=&lt;your csi driver endpoint&gt;
</code></pre>
<p>For more information please see <a href="https://github.com/kubernetes-csi/csi-test/tree/master/cmd/csi-sanity">csi-sanity</a></p>
<a class="header" href="#troubleshooting" id="troubleshooting"><h1>Troubleshooting</h1></a>
<a class="header" href="#node-plugin-pod-does-not-start-with-runcontainererror-status" id="node-plugin-pod-does-not-start-with-runcontainererror-status"><h3>Node plugin pod does not start with <em>RunContainerError</em> status</h3></a>
<p><code>kubectl describe pod your-nodeplugin-pod</code> shows:</p>
<pre><code>failed to start container &quot;your-driver&quot;: Error response from daemon:
linux mounts: Path /var/lib/kubelet/pods is mounted on / but it is not a shared mount
</code></pre>
<p>Your Docker host is not configured to allow shared mounts. Take a look at <a href="https://docs.portworx.com/knowledgebase/shared-mount-propagation.html">this page</a> for instructions to enable them.</p>
<a class="header" href="#external-attacher-cant-find-volumeattachments" id="external-attacher-cant-find-volumeattachments"><h3>External attacher can't find <em>VolumeAttachments</em></h3></a>
<p>If you have a Kubernetes 1.9 cluster, not being able to list <em>VolumeAttachment</em>
and the following error are due to the lack of the
<code>storage.k8s.io/v1alpha1=true</code> runtime configuration:</p>
<pre><code>$ kubectl logs csi-pod external-attacher
...
I0306 16:34:50.976069       1 reflector.go:240] Listing and watching *v1alpha1.VolumeAttachment from github.com/kubernetes-csi/external-attacher/vendor/k8s.io/client-go/informers/factory.go:86

E0306 16:34:50.992034       1 reflector.go:205] github.com/kubernetes-csi/external-attacher/vendor/k8s.io/client-go/informers/factory.go:86: Failed to list *v1alpha1.VolumeAttachment: the server could not find the requested resource
...
</code></pre>
<p>Please see the <a href="Kubernetes-1.9.html">Kubernetes 1.9</a> page.</p>
<a class="header" href="#problems-with-the-external-components" id="problems-with-the-external-components"><h3>Problems with the external components</h3></a>
<p>The external components images are under active development. It can
happen that they become incompatible with each other. If the
issues above above have been ruled out, <a href="https://github.com/kubernetes/community/tree/master/sig-storage">contact the sig-storage
team</a> and/or
<a href="https://github.com/kubernetes/community/blob/master/contributors/devel/e2e-tests.md#local-clusters">run the e2e test</a>:</p>
<pre><code>go run hack/e2e.go -- --provider=local --test --test_args=&quot;--ginkgo.focus=Feature:CSI&quot;
</code></pre>
<a class="header" href="#references" id="references"><h1>References</h1></a>
<ul>
<li><a href="https://github.com/container-storage-interface/spec/blob/master/spec.md">CSI Specification</a></li>
<li><a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md">CSI Volume Plugins in Kubernetes Design Doc</a></li>
</ul>
<a class="header" href="#archive" id="archive"><h1>Archive</h1></a>
<p>In this section, you will find information about CSI support in older Kubernetes versions.</p>
<a class="header" href="#csi-with-kubernetes-19" id="csi-with-kubernetes-19"><h1>CSI with Kubernetes 1.9</h1></a>
<p>Since CSI support is alpha in Kubernetes 1.9, the following flags must be set explictly:</p>
<ul>
<li>API Server binary:</li>
</ul>
<pre><code>--allow-privileged=true
--feature-gates=CSIPersistentVolume=true,MountPropagation=true
--runtime-config=storage.k8s.io/v1alpha1=true
</code></pre>
<ul>
<li>Controller-manager binary</li>
</ul>
<pre><code>--feature-gates=CSIPersistentVolume=true
</code></pre>
<ul>
<li>Kubelet</li>
</ul>
<pre><code>--allow-privileged=true
--feature-gates=CSIPersistentVolume=true,MountPropagation=true
</code></pre>
<a class="header" href="#developers" id="developers"><h2>Developers</h2></a>
<p>If you are a developer and are using the script <code>cluster/kube-up.sh</code> from the Kubernetes repo, then you can set values using the following environment variables:</p>
<pre><code>export KUBE_RUNTIME_CONFIG=&quot;storage.k8s.io/v1alpha1=true&quot;
export KUBE_FEATURE_GATES=&quot;MountPropagation=true,CSIPersistentVolume=true&quot;
</code></pre>
<p>When using the script <code>hack/local-up-cluster.sh</code>, set the same variables without the <code>KUBE_</code> prefix:</p>
<pre><code>export RUNTIME_CONFIG=&quot;storage.k8s.io/v1alpha1=true&quot;
export FEATURE_GATES=&quot;MountPropagation=true,CSIPersistentVolume=true&quot;
</code></pre>
<a class="header" href="#confirming-the-setup-1" id="confirming-the-setup-1"><h2>Confirming the setup</h2></a>
<p>Once the system is up, to confirm if the runtime config has taken effect, the following command should return that there are no resources and not return an error:</p>
<pre><code class="language-bash">$ kubectl get volumeattachments
</code></pre>
<p>To confirm that the feature gate has taken effect, submit the following fake PersistentVolume specification. If it is accepted, then we can confirm that the feature gate has been set correctly, and you may go ahead and delete it:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: PersistentVolume
metadata:
    name: fakepv
spec:
    capacity:
        storage: 1Gi
    accessModes:
        - ReadWriteMany
    csi:
        driver: fake
        volumeHandle: &quot;1&quot;
        readOnly: false
</code></pre>
<a class="header" href="#csi-with-kubernetes-110" id="csi-with-kubernetes-110"><h1>CSI with Kubernetes 1.10</h1></a>
<p>TBD</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
