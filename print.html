<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Kubernetes CSI Developer Documentation</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="This site documents how to develop and deploy a Container Storage Interface (CSI) driver on Kubernetes.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="developing.html"><strong aria-hidden="true">2.</strong> Developing a CSI Driver for Kubernetes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="project-policies.html"><strong aria-hidden="true">2.1.</strong> Versioning, Support, Compatibility Policies</a></li><li class="chapter-item expanded "><a href="kubernetes-changelog.html"><strong aria-hidden="true">2.2.</strong> Kubernetes Changelog</a></li><li class="chapter-item expanded "><a href="kubernetes-cluster-controllers.html"><strong aria-hidden="true">2.3.</strong> Kubernetes Cluster Controllers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="snapshot-controller.html"><strong aria-hidden="true">2.3.1.</strong> Snapshot Controller</a></li><li class="chapter-item expanded "><a href="snapshot-validation-webhook.html"><strong aria-hidden="true">2.3.2.</strong> Snapshot Validation Webhook</a></li><li class="chapter-item expanded "><a href="csi-proxy.html"><strong aria-hidden="true">2.3.3.</strong> CSI Proxy</a></li></ol></li><li class="chapter-item expanded "><a href="sidecar-containers.html"><strong aria-hidden="true">2.4.</strong> Sidecar Containers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="external-attacher.html"><strong aria-hidden="true">2.4.1.</strong> external-attacher</a></li><li class="chapter-item expanded "><a href="external-provisioner.html"><strong aria-hidden="true">2.4.2.</strong> external-provisioner</a></li><li class="chapter-item expanded "><a href="external-resizer.html"><strong aria-hidden="true">2.4.3.</strong> external-resizer</a></li><li class="chapter-item expanded "><a href="external-snapshotter.html"><strong aria-hidden="true">2.4.4.</strong> external-snapshotter</a></li><li class="chapter-item expanded "><a href="livenessprobe.html"><strong aria-hidden="true">2.4.5.</strong> livenessprobe</a></li><li class="chapter-item expanded "><a href="node-driver-registrar.html"><strong aria-hidden="true">2.4.6.</strong> node-driver-registrar</a></li><li class="chapter-item expanded "><a href="cluster-driver-registrar.html"><strong aria-hidden="true">2.4.7.</strong> cluster-driver-registrar</a></li><li class="chapter-item expanded "><a href="external-health-monitor-controller.html"><strong aria-hidden="true">2.4.8.</strong> external-health-monitor-controller</a></li><li class="chapter-item expanded "><a href="external-health-monitor-agent.html"><strong aria-hidden="true">2.4.9.</strong> external-health-monitor-agent</a></li></ol></li><li class="chapter-item expanded "><a href="csi-objects.html"><strong aria-hidden="true">2.5.</strong> CSI objects</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="csi-driver-object.html"><strong aria-hidden="true">2.5.1.</strong> CSIDriver Object</a></li><li class="chapter-item expanded "><a href="csi-node-object.html"><strong aria-hidden="true">2.5.2.</strong> CSINode Object</a></li></ol></li><li class="chapter-item expanded "><a href="features.html"><strong aria-hidden="true">2.6.</strong> Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="secrets-and-credentials.html"><strong aria-hidden="true">2.6.1.</strong> Secrets &amp; Credentials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="secrets-and-credentials-storage-class.html"><strong aria-hidden="true">2.6.1.1.</strong> StorageClass Secrets</a></li><li class="chapter-item expanded "><a href="secrets-and-credentials-volume-snapshot-class.html"><strong aria-hidden="true">2.6.1.2.</strong> VolumeSnapshotClass Secrets</a></li></ol></li><li class="chapter-item expanded "><a href="topology.html"><strong aria-hidden="true">2.6.2.</strong> Topology</a></li><li class="chapter-item expanded "><a href="raw-block.html"><strong aria-hidden="true">2.6.3.</strong> Raw Block Volume</a></li><li class="chapter-item expanded "><a href="skip-attach.html"><strong aria-hidden="true">2.6.4.</strong> Skip Attach</a></li><li class="chapter-item expanded "><a href="pod-info.html"><strong aria-hidden="true">2.6.5.</strong> Pod Info on Mount</a></li><li class="chapter-item expanded "><a href="volume-expansion.html"><strong aria-hidden="true">2.6.6.</strong> Volume expansion</a></li><li class="chapter-item expanded "><a href="volume-datasources.html"><strong aria-hidden="true">2.6.7.</strong> Data Sources</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="volume-cloning.html"><strong aria-hidden="true">2.6.7.1.</strong> Cloning</a></li><li class="chapter-item expanded "><a href="snapshot-restore-feature.html"><strong aria-hidden="true">2.6.7.2.</strong> Volume Snapshot &amp; Restore</a></li></ol></li><li class="chapter-item expanded "><a href="ephemeral-local-volumes.html"><strong aria-hidden="true">2.6.8.</strong> Ephemeral Local Volumes</a></li><li class="chapter-item expanded "><a href="volume-limits.html"><strong aria-hidden="true">2.6.9.</strong> Volume Limits</a></li><li class="chapter-item expanded "><a href="storage-capacity-tracking.html"><strong aria-hidden="true">2.6.10.</strong> Storage Capacity Tracking</a></li><li class="chapter-item expanded "><a href="volume-health-monitor.html"><strong aria-hidden="true">2.6.11.</strong> Volume Health Monitoring</a></li><li class="chapter-item expanded "><a href="token-requests.html"><strong aria-hidden="true">2.6.12.</strong> Token Requests</a></li><li class="chapter-item expanded "><a href="support-fsgroup.html"><strong aria-hidden="true">2.6.13.</strong> FSGroup Support</a></li><li class="chapter-item expanded "><a href="csi-windows.html"><strong aria-hidden="true">2.6.14.</strong> CSI Windows</a></li><li class="chapter-item expanded "><a href="prevent-volume-mode-conversion.html"><strong aria-hidden="true">2.6.15.</strong> Volume Mode Conversion</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="deploying.html"><strong aria-hidden="true">3.</strong> Deploying a CSI Driver on Kubernetes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="example.html"><strong aria-hidden="true">3.1.</strong> Example</a></li></ol></li><li class="chapter-item expanded "><a href="testing-drivers.html"><strong aria-hidden="true">4.</strong> Driver Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="unit-testing.html"><strong aria-hidden="true">4.1.</strong> Unit Testing</a></li><li class="chapter-item expanded "><a href="functional-testing.html"><strong aria-hidden="true">4.2.</strong> Functional Testing</a></li></ol></li><li class="chapter-item expanded "><a href="drivers.html"><strong aria-hidden="true">5.</strong> Drivers</a></li><li class="chapter-item expanded "><a href="api.html"><strong aria-hidden="true">6.</strong> API Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="api/volume-snapshot.html"><strong aria-hidden="true">6.1.</strong> Volume Snapshot</a></li></ol></li><li class="chapter-item expanded "><a href="troubleshooting.html"><strong aria-hidden="true">7.</strong> Troubleshooting</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Kubernetes CSI Developer Documentation</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<h2><a class="header" href="#kubernetes-container-storage-interface-csi-documentation" id="kubernetes-container-storage-interface-csi-documentation">Kubernetes Container Storage Interface (CSI) Documentation</a></h2>
<p>This site documents how to develop, deploy, and test a <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md">Container Storage Interface</a> (CSI) driver on Kubernetes.</p>
<p>The <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md">Container Storage Interface</a> (CSI) is a standard for exposing arbitrary block and file storage systems to containerized workloads on Container Orchestration Systems (COs) like Kubernetes. Using CSI third-party storage providers can write and deploy plugins exposing new storage systems in Kubernetes without ever having to touch the core Kubernetes code.</p>
<p>The target audience for this site is third-party developers interested in developing CSI drivers for Kubernetes.</p>
<p>Kubernetes users interested in how to deploy or manage an existing CSI driver on Kubernetes should look at the documentation provided by the author of the CSI driver.</p>
<p>Kubernetes users interested in how to use a CSI driver should look at <a href="https://kubernetes.io/docs/concepts/storage/volumes/#csi">kubernetes.io documentation</a>.</p>
<h2><a class="header" href="#kubernetes-releases" id="kubernetes-releases">Kubernetes Releases</a></h2>
<table><thead><tr><th>Kubernetes</th><th>CSI Spec Compatibility</th><th>Status</th></tr></thead><tbody>
<tr><td>v1.9</td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v0.1.0">v0.1.0</a></td><td>Alpha</td></tr>
<tr><td>v1.10</td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v0.2.0">v0.2.0</a></td><td>Beta</td></tr>
<tr><td>v1.11</td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a></td><td>Beta</td></tr>
<tr><td>v1.13</td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a>, <a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>GA</td></tr>
</tbody></table>
<h1><a class="header" href="#development-and-deployment" id="development-and-deployment">Development and Deployment</a></h1>
<h2><a class="header" href="#minimum-requirements-for-developing-and-deploying-a-csi-driver-for-kubernetes" id="minimum-requirements-for-developing-and-deploying-a-csi-driver-for-kubernetes">Minimum Requirements (for Developing and Deploying a CSI driver for Kubernetes)</a></h2>
<p>Kubernetes is as minimally prescriptive about packaging and deployment of a CSI Volume Driver as possible.</p>
<p>The only requirements are around how Kubernetes (master and node) components find and communicate with a CSI driver.</p>
<p>Specifically, the following is dictated by Kubernetes regarding CSI:</p>
<ul>
<li>Kubelet to CSI Driver Communication
<ul>
<li>Kubelet directly issues CSI calls (like <code>NodeStageVolume</code>, <code>NodePublishVolume</code>, etc.) to CSI drivers via a Unix Domain Socket to mount and unmount volumes.</li>
<li>Kubelet discovers CSI drivers (and the Unix Domain Socket to use to interact with a CSI driver) via the <a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/pluginmanager/pluginwatcher/README.md">kubelet plugin registration mechanism</a>.</li>
<li>Therefore, all CSI drivers deployed on Kubernetes MUST register themselves using the kubelet plugin registration mechanism on each supported node.</li>
</ul>
</li>
<li>Master to CSI Driver Communication
<ul>
<li>Kubernetes master components do not communicate directly (via a Unix Domain Socket or otherwise) with CSI drivers.</li>
<li>Kubernetes master components interact only with the Kubernetes API.</li>
<li>Therefore, CSI drivers that require operations that depend on the Kubernetes API (like volume create, volume attach, volume snapshot, etc.) MUST watch the Kubernetes API and trigger the appropriate CSI operations against it.</li>
</ul>
</li>
</ul>
<p>Because these requirements are minimally prescriptive, CSI driver developers are free to implement and deploy their drivers as they see fit.</p>
<p><em>That said, to ease development and deployment, the mechanism described below is recommended.</em></p>
<h2><a class="header" href="#recommended-mechanism-for-developing-and-deploying-a-csi-driver-for-kubernetes" id="recommended-mechanism-for-developing-and-deploying-a-csi-driver-for-kubernetes">Recommended Mechanism (for Developing and Deploying a CSI driver for Kubernetes)</a></h2>
<p>The Kubernetes development team has established a &quot;Recommended Mechanism&quot; for developing, deploying, and testing CSI Drivers on Kubernetes.
It aims to reduce boilerplate code and  simplify the overall process for CSI Driver developers.</p>
<p>This &quot;Recommended Mechanism&quot; makes use of the following components:</p>
<ul>
<li>Kubernetes CSI <a href="sidecar-containers.html">Sidecar Containers</a></li>
<li>Kubernetes CSI <a href="csi-objects.html">objects</a></li>
<li>CSI <a href="testing-drivers.html">Driver Testing</a> tools</li>
</ul>
<p>To implement a CSI driver using this mechanism, a CSI driver developer should:</p>
<ol>
<li>Create a containerized application implementing the <em>Identity</em>, <em>Node</em>, and optionally the <em>Controller</em> services described in the <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md#rpc-interface">CSI specification</a>  (the CSI driver container).
<ul>
<li>See <a href="developing.html">Developing CSI Driver</a> for more information.</li>
</ul>
</li>
<li>Unit test it using csi-sanity.
<ul>
<li>See <a href="unit-testing.html">Driver - Unit Testing</a> for more information.</li>
</ul>
</li>
<li>Define Kubernetes API YAML files that deploy the CSI driver container along with appropriate sidecar containers.
<ul>
<li>See <a href="deploying.html">Deploying in Kubernetes</a> for more information.</li>
</ul>
</li>
<li>Deploy the driver on a Kubernetes cluster and run end-to-end functional tests on it.
<ul>
<li>See <a href="functional-testing.html">Driver - Functional Testing</a></li>
</ul>
</li>
</ol>
<h2><a class="header" href="#reference-links" id="reference-links">Reference Links</a></h2>
<ul>
<li><a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md">Design Doc</a></li>
</ul>
<h1><a class="header" href="#developing-csi-driver-for-kubernetes" id="developing-csi-driver-for-kubernetes">Developing CSI Driver for Kubernetes</a></h1>
<h2><a class="header" href="#remain-informed" id="remain-informed">Remain Informed</a></h2>
<p>All developers of CSI drivers should join https://groups.google.com/forum/#!forum/container-storage-interface-drivers-announce to remain informed about changes to CSI or Kubernetes that may affect existing CSI drivers.</p>
<h2><a class="header" href="#overview" id="overview">Overview</a></h2>
<p>The first step to creating a CSI driver is writing an application implementing the <a href="https://grpc.io/docs/">gRPC</a> services described in the <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md#rpc-interface">CSI specification</a></p>
<p>At a minimum, CSI drivers must implement the following CSI services:</p>
<ul>
<li>CSI <code>Identity</code> service
<ul>
<li>Enables callers (Kubernetes components and CSI sidecar containers) to identify the driver and what optional functionality it supports.</li>
</ul>
</li>
<li>CSI <code>Node</code> service
<ul>
<li>Only <code>NodePublishVolume</code>, <code>NodeUnpublishVolume</code>, and <code>NodeGetCapabilities</code> are required.</li>
<li>Required methods enable callers to make a volume available at a specified path and discover what optional  functionality the driver supports.</li>
</ul>
</li>
</ul>
<p>All CSI services may be implemented in the same CSI driver application. The CSI driver application should be containerized to make it easy to deploy on Kubernetes. Once containerized, the CSI driver can be paired with CSI <a href="sidecar-containers.html">Sidecar Containers</a> and deployed in node and/or controller mode as appropriate.</p>
<h2><a class="header" href="#capabilities" id="capabilities">Capabilities</a></h2>
<p>If your driver supports additional features, CSI &quot;capabilities&quot; can be used to advertise the optional methods/services it supports, for example:</p>
<ul>
<li><code>CONTROLLER_SERVICE</code> (<code>PluginCapability</code>)
<ul>
<li>The entire CSI <code>Controller</code> service is optional. This capability indicates the driver implement one or more of the methods in the CSI <code>Controller</code> service.</li>
</ul>
</li>
<li><code>VOLUME_ACCESSIBILITY_CONSTRAINTS</code> (<code>PluginCapability</code>)
<ul>
<li>This capability indicates the volumes for this driver may not be equally accessible from all nodes in the cluster, and that the driver will return additional topology related information that Kubernetes can use to schedule workloads more intelligently or influence where a volume will be provisioned.</li>
</ul>
</li>
<li><code>VolumeExpansion</code> (<code>PluginCapability</code>)
<ul>
<li>This capability indicates the driver supports resizing (expanding) volumes after creation.</li>
</ul>
</li>
<li><code>CREATE_DELETE_VOLUME</code> (<code>ControllerServiceCapability</code>)
<ul>
<li>This capability indicates the driver supports dynamic volume provisioning and deleting.</li>
</ul>
</li>
<li><code>PUBLISH_UNPUBLISH_VOLUME</code> (<code>ControllerServiceCapability</code>)
<ul>
<li>This capability indicates the driver implements <code>ControllerPublishVolume</code> and <code>ControllerUnpublishVolume</code> -- operations that correspond to the Kubernetes volume attach/detach operations. This may, for example, result in a &quot;volume attach&quot; operation against the Google Cloud control plane to attach the specified volume to the specified node for the Google Cloud PD CSI Driver.</li>
</ul>
</li>
<li><code>CREATE_DELETE_SNAPSHOT</code> (<code>ControllerServiceCapability</code>)
<ul>
<li>This capability indicates the driver supports provisioning volume snapshots and the ability to provision new volumes using those snapshots.</li>
</ul>
</li>
<li><code>CLONE_VOLUME</code> (<code>ControllerServiceCapability</code>)
<ul>
<li>This capability indicates the driver supports cloning of volumes.</li>
</ul>
</li>
<li><code>STAGE_UNSTAGE_VOLUME</code> (<code>NodeServiceCapability</code>)
<ul>
<li>This capability indicates the driver implements <code>NodeStageVolume</code> and <code>NodeUnstageVolume</code> -- operations that correspond to the Kubernetes volume device mount/unmount operations. This may, for example, be used to create a global (per node) volume mount of a block storage device.</li>
</ul>
</li>
</ul>
<p>This is an partial list, please see the <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md">CSI spec</a> for a complete list of capabilities.
Also see the <a href="features.html">Features</a> section to understand how a feature integrates with Kubernetes.</p>
<h1><a class="header" href="#versioning-support-and-kubernetes-compatibility" id="versioning-support-and-kubernetes-compatibility">Versioning, Support, and Kubernetes Compatibility</a></h1>
<h2><a class="header" href="#versioning" id="versioning">Versioning</a></h2>
<p>Each Kubernetes CSI component version is expressed as <em>x.y.z</em>, where <em>x</em> is the
major version, <em>y</em> is the minor version, and <em>z</em> is the patch version,
following <a href="https://semver.org/">Semantic Versioning</a>.</p>
<p>Patch version releases only contain bug fixes that do not break any backwards
compatibility.</p>
<p>Minor version releases may contain new functionality that do not
break any backwards compatibility (except for alpha features).</p>
<p>Major version releases may contain new functionality or fixes that may break
backwards compatibility with previous major releases. Changes that require a
major version increase include: removing or changing API, flags, or behavior, new
RBAC requirements that are not opt-in, new Kubernetes minimum version
requirements.</p>
<p>A litmus test for not breaking compatibility is to replace the image of a
component in an existing deployment without changing that deployment in any
other way.</p>
<p>To minimize the number of branches we need to support, we do not have a general
policy for releasing new minor versions on older majors. We will make exceptions
for work related to meeting production readiness requirements. Only the previous
major version will be eligible for these exceptions, so long as the time between
the previous major version and the current major version is under six months.
For example, if &quot;X.0.0&quot; and &quot;X+1.0.0&quot; were released under six months apart,
&quot;X.0.0&quot; would be eligible for new minor releases.</p>
<h2><a class="header" href="#support" id="support">Support</a></h2>
<p>The Kubernetes CSI project follows the broader Kubernetes project on support.
Every minor release branch will be supported with patch releases on an as-needed
basis for at least 1 year,
starting with the first release of that minor version. In addition, the minor
release branch will be supported for at least 3 months after the next minor
version is released, to allow time to integrate with the latest release.</p>
<h3><a class="header" href="#alpha-features" id="alpha-features">Alpha Features</a></h3>
<p>Alpha features are subject to break or be
removed across Kubernetes and CSI component releases. There is no guarantee alpha
features will continue to function if upgrading the Kubernetes cluster or
upgrading a CSI sidecar or controller.</p>
<h2><a class="header" href="#kubernetes-compatibility" id="kubernetes-compatibility">Kubernetes Compatibility</a></h2>
<p>Each release of a CSI component has a minimum, maximum and recommended Kubernetes version
that it is compatible with.</p>
<h3><a class="header" href="#minimum-version" id="minimum-version">Minimum Version</a></h3>
<p>Minimum version specifies the lowest Kubernetes version where the component will
function with the most basic functionality, and no additional features added later.
Generally, this aligns with the Kubernetes version where that CSI spec version was added.</p>
<h3><a class="header" href="#maximum-version" id="maximum-version">Maximum Version</a></h3>
<p>The maximum Kubernetes version specifies the last working Kubernetes version for
all beta and GA features that the component supports. This generally aligns with one
Kubernetes release before support for the CSI spec version was removed or if a particular
Kubernetes API or feature was removed.</p>
<h3><a class="header" href="#recommended-version" id="recommended-version">Recommended Version</a></h3>
<p>Note that any new features added may have
dependencies on Kubernetes versions greater than the minimum Kubernetes version.
The recommended Kubernetes version specifies the lowest Kubernetes version
needed where all its supported features will function correctly. Trying to use a
new sidecar feature on a Kubernetes cluster below the recommended Kubernetes
version may fail to function correctly. For that reason, it is encouraged to
stay as close to the recommended Kubernetes version as possible.</p>
<p>For more details on which features are supported with which Kubernetes versions
and their corresponding CSI components, please see each feature's individual page.</p>
<h1><a class="header" href="#kubernetes-changelog" id="kubernetes-changelog">Kubernetes Changelog</a></h1>
<p>This page summarizes major CSI changes made in each Kubernetes release. For
details on individual features, visit the <a href="features.html">Features section</a>.</p>
<h2><a class="header" href="#kubernetes-123" id="kubernetes-123">Kubernetes 1.23</a></h2>
<h3><a class="header" href="#features" id="features">Features</a></h3>
<ul>
<li>GA
<ul>
<li>CSI fsgroup policy</li>
<li>Non-recusrive fsgroup ownership</li>
<li>Generic ephemeral volumes</li>
</ul>
</li>
<li>Beta
<ul>
<li>Delegate fsgroup to CSI driver</li>
</ul>
</li>
<li>Alpha
<ul>
<li>Recover from Expansion Failure</li>
<li>Honor PV Reclaim Policy</li>
<li>RBD CSI Migration</li>
<li>Portworx CSI migration</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#kubernetes-122" id="kubernetes-122">Kubernetes 1.22</a></h2>
<h3><a class="header" href="#features-1" id="features-1">Features</a></h3>
<ul>
<li>GA
<ul>
<li>Windows CSI (CSI-Proxy API v1)</li>
<li>Pod token requests (CSIServiceAccountToken)</li>
</ul>
</li>
<li>Alpha
<ul>
<li>ReadWriteOncePod access mode</li>
<li>Delegate fsgroup to CSI driver</li>
<li>Generic data populators</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#kubernetes-121" id="kubernetes-121">Kubernetes 1.21</a></h2>
<h3><a class="header" href="#features-2" id="features-2">Features</a></h3>
<ul>
<li>Beta
<ul>
<li>Pod token requests (CSIServiceAccountToken)</li>
<li>Storage capacity tracking</li>
<li>Generic ephemeral volumes</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#kubernetes-120" id="kubernetes-120">Kubernetes 1.20</a></h2>
<h3><a class="header" href="#breaking-changes" id="breaking-changes">Breaking Changes</a></h3>
<ul>
<li>Kubelet no longer creates the target_path for NodePublishVolume
in accordance with the CSI spec. Kubelet also no longer checks if staging and
target paths are mounts or corrupted. CSI drivers need to be idempotent and do
any necessary mount verification.</li>
</ul>
<h3><a class="header" href="#features-3" id="features-3">Features</a></h3>
<ul>
<li>GA
<ul>
<li>Volume snapshots and restore</li>
</ul>
</li>
<li>Beta
<ul>
<li>CSI fsgroup policy</li>
<li>Non-recusrive fsgroup ownership</li>
</ul>
</li>
<li>Alpha
<ul>
<li>Pod token requests (CSIServiceAccountToken)</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#kubernetes-119" id="kubernetes-119">Kubernetes 1.19</a></h2>
<h3><a class="header" href="#deprecations" id="deprecations">Deprecations</a></h3>
<ul>
<li>Behaviour of NodeExpandVolume being called between NodeStage and NodePublish is
deprecated for CSI volumes. CSI drivers should support calling NodeExpandVolume
after NodePublish if they have node EXPAND_VOLUME capability</li>
</ul>
<h3><a class="header" href="#features-4" id="features-4">Features</a></h3>
<ul>
<li>Beta
<ul>
<li>CSI on Windows</li>
<li>CSI migration for AzureDisk and vSphere drivers</li>
</ul>
</li>
<li>Alpha
<ul>
<li>CSI fsgroup policy</li>
<li>Generic ephemeral volumes</li>
<li>Storage capacity tracking</li>
<li>Volume health monitoring</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#kubernetes-118" id="kubernetes-118">Kubernetes 1.18</a></h2>
<h3><a class="header" href="#deprecations-1" id="deprecations-1">Deprecations</a></h3>
<ul>
<li><code>storage.k8s.io/v1beta1</code> <code>CSIDriver</code> object has been deprecated and will be
removed in a future release.</li>
<li>In a future release, kubelet will no longer create the CSI NodePublishVolume
target directory, in accordance with the CSI specification. CSI drivers may
need to be updated accordingly to properly create and process the target path.</li>
</ul>
<h3><a class="header" href="#features-5" id="features-5">Features</a></h3>
<ul>
<li>GA
<ul>
<li>Raw block volumes</li>
<li>Volume cloning</li>
<li>Skip attach</li>
<li>Pod info on mount</li>
</ul>
</li>
<li>Beta
<ul>
<li>CSI migration for Openstack cinder driver.</li>
</ul>
</li>
<li>Alpha
<ul>
<li>CSI on Windows</li>
</ul>
</li>
<li><code>storage.k8s.io/v1</code> <code>CSIDriver</code> object introduced.</li>
</ul>
<h2><a class="header" href="#kubernetes-117" id="kubernetes-117">Kubernetes 1.17</a></h2>
<h3><a class="header" href="#breaking-changes-1" id="breaking-changes-1">Breaking Changes</a></h3>
<ul>
<li>CSI 0.3 support has been removed. CSI 0.3 drivers will no longer function.</li>
</ul>
<h3><a class="header" href="#deprecations-2" id="deprecations-2">Deprecations</a></h3>
<ul>
<li><code>storage.k8s.io/v1beta1</code> <code>CSINode</code> object has been deprecated and will be
removed in a future release.</li>
</ul>
<h3><a class="header" href="#features-6" id="features-6">Features</a></h3>
<ul>
<li>GA
<ul>
<li>Volume topology</li>
<li>Volume limits</li>
</ul>
</li>
<li>Beta
<ul>
<li>Volume snapshots and restore</li>
<li>CSI migration for AWS EBS and GCE PD drivers</li>
</ul>
</li>
<li><code>storage.k8s.io/v1</code> <code>CSINode</code> object introduced.</li>
</ul>
<h2><a class="header" href="#kubernetes-116" id="kubernetes-116">Kubernetes 1.16</a></h2>
<h3><a class="header" href="#features-7" id="features-7">Features</a></h3>
<ul>
<li>Beta
<ul>
<li>Volume cloning</li>
<li>Volume expansion</li>
<li>Ephemeral local volumes</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#kubernetes-115" id="kubernetes-115">Kubernetes 1.15</a></h2>
<h3><a class="header" href="#features-8" id="features-8">Features</a></h3>
<ul>
<li>Volume capacity usage metrics</li>
<li>Alpha
<ul>
<li>Volume cloning</li>
<li>Ephemeral local volumes</li>
<li>Resizing secrets</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#kubernetes-114" id="kubernetes-114">Kubernetes 1.14</a></h2>
<h3><a class="header" href="#breaking-changes-2" id="breaking-changes-2">Breaking Changes</a></h3>
<ul>
<li><code>csi.storage.k8s.io/v1alpha1</code> <code>CSINodeInfo</code> and <code>CSIDriver</code> CRDs are no longer supported.</li>
</ul>
<h3><a class="header" href="#features-9" id="features-9">Features</a></h3>
<ul>
<li>Beta
<ul>
<li>Topology</li>
<li>Raw block</li>
<li>Skip attach</li>
<li>Pod info on mount</li>
</ul>
</li>
<li>Alpha
<ul>
<li>Volume expansion</li>
</ul>
</li>
<li><code>storage.k8s.io/v1beta1</code> <code>CSINode</code> and <code>CSIDriver</code> objects introduced.</li>
</ul>
<h2><a class="header" href="#kubernetes-113" id="kubernetes-113">Kubernetes 1.13</a></h2>
<h3><a class="header" href="#deprecations-3" id="deprecations-3">Deprecations</a></h3>
<ul>
<li>CSI spec 0.2 and 0.3 are deprecated and support will be removed in Kubernetes 1.17.</li>
</ul>
<h3><a class="header" href="#features-10" id="features-10">Features</a></h3>
<ul>
<li>GA support added for <a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">CSI spec
1.0</a>.</li>
</ul>
<h2><a class="header" href="#kubernetes-112" id="kubernetes-112">Kubernetes 1.12</a></h2>
<h3><a class="header" href="#breaking-changes-3" id="breaking-changes-3">Breaking Changes</a></h3>
<p>Kubelet device plugin registration is enabled by default, which requires CSI
plugins to use <code>driver-registrar:v0.3.0</code> to register with kubelet.</p>
<h3><a class="header" href="#features-11" id="features-11">Features</a></h3>
<ul>
<li>Alpha
<ul>
<li>Snapshots</li>
<li>Topology</li>
<li>Skip attach</li>
<li>Pod info on mount</li>
</ul>
</li>
<li><code>csi.storage.k8s.io/v1alpha1</code> <code>CSINodeInfo</code> and <code>CSIDriver</code> CRDs were
introduced and have to be installed before deploying a CSI driver.</li>
</ul>
<h2><a class="header" href="#kubernetes-111" id="kubernetes-111">Kubernetes 1.11</a></h2>
<h3><a class="header" href="#features-12" id="features-12">Features</a></h3>
<ul>
<li>Beta support added for <a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">CSI spec
0.3</a>.</li>
<li>Alpha
<ul>
<li>Raw block</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#kubernetes-110" id="kubernetes-110">Kubernetes 1.10</a></h2>
<h3><a class="header" href="#breaking-changes-4" id="breaking-changes-4">Breaking Changes</a></h3>
<ul>
<li>CSI spec 0.1 is no longer supported.</li>
</ul>
<h3><a class="header" href="#features-13" id="features-13">Features</a></h3>
<ul>
<li>Beta support added for <a href="https://github.com/container-storage-interface/spec/releases/tag/v0.2.0">CSI spec 0.2</a>.
This added optional <code>NodeStageVolume</code> and <code>NodeUnstageVolume</code> calls which
map to Kubernetes <code>MountDevice</code> and <code>UnmountDevice</code> operations.</li>
</ul>
<h2><a class="header" href="#kubernetes-19" id="kubernetes-19">Kubernetes 1.9</a></h2>
<h3><a class="header" href="#features-14" id="features-14">Features</a></h3>
<ul>
<li>Alpha support added for <a href="https://github.com/container-storage-interface/spec/releases/tag/v0.1.0">CSI spec
0.1</a>.</li>
</ul>
<h1><a class="header" href="#kubernetes-cluster-controllers" id="kubernetes-cluster-controllers">Kubernetes Cluster Controllers</a></h1>
<p>The Kubernetes cluster controllers are responsible for managing snapshot objects and operations across multiple CSI drivers, so they should be bundled and deployed by the Kubernetes distributors as part of their Kubernetes cluster management process (independent of any CSI Driver).</p>
<p>The Kubernetes development team maintains the following Kubernetes cluster controllers:</p>
<ul>
<li><a href="snapshot-controller.html">snapshot-controller</a></li>
</ul>
<h1><a class="header" href="#snapshot-controller" id="snapshot-controller">Snapshot Controller</a></h1>
<h2><a class="header" href="#status-and-releases" id="status-and-releases">Status and Releases</a></h2>
<p><strong>Git Repository:</strong> <a href="https://github.com/kubernetes-csi/external-snapshotter">https://github.com/kubernetes-csi/external-snapshotter</a></p>
<p><strong>Status:</strong> GA v4.0.0+</p>
<p>When Volume Snapshot is promoted to Beta in Kubernetes 1.17, the CSI external-snapshotter sidecar controller is split into two controllers: a snapshot-controller and a CSI external-snapshotter sidecar. See the following table for snapshot-controller release information.</p>
<h3><a class="header" href="#supported-versions" id="supported-versions">Supported Versions</a></h3>
<table><thead><tr><th>Latest stable release</th><th>Branch</th><th>Min CSI Version</th><th>Max CSI Version</th><th>Container Image</th><th><a href="kubernetes-compatibility.html#minimum-version">Min K8s Version</a></th><th><a href="kubernetes-compatibility.html#maximum-version">Max K8s Version</a></th><th><a href="kubernetes-compatibility.html#recommended-version">Recommended K8s Version</a></th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/external-snapshotter/releases/tag/v4.2.1">external-snapshotter v4.2.1</a></td><td><a href="https://github.com/kubernetes-csi/external-snapshotter/tree/release-4.2">release-4.2</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/snapshot-controller:v4.2.1</td><td>v1.20</td><td>-</td><td>v1.22</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-snapshotter/releases/tag/v4.1.1">external-snapshotter v4.1.1</a></td><td><a href="https://github.com/kubernetes-csi/external-snapshotter/tree/release-4.1">release-4.1</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/snapshot-controller:v4.1.1</td><td>v1.20</td><td>-</td><td>v1.20</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-snapshotter/releases/tag/v4.0.1">external-snapshotter v4.0.1</a></td><td><a href="https://github.com/kubernetes-csi/external-snapshotter/tree/release-4.0">release-4.0</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/snapshot-controller:v4.0.1</td><td>v1.20</td><td>-</td><td>v1.20</td></tr>
</tbody></table>
<h3><a class="header" href="#unsupported-versions" id="unsupported-versions">Unsupported Versions</a></h3>
<table><thead><tr><th>Latest stable release</th><th>Branch</th><th>Min CSI Version</th><th>Max CSI Version</th><th>Container Image</th><th><a href="kubernetes-compatibility.html#minimum-version">Min K8s Version</a></th><th><a href="kubernetes-compatibility.html#maximum-version">Max K8s Version</a></th><th><a href="kubernetes-compatibility.html#recommended-version">Recommended K8s Version</a></th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/external-snapshotter/releases/tag/v3.0.3">external-snapshotter v3.0.3 (beta)</a></td><td><a href="https://github.com/kubernetes-csi/external-snapshotter/tree/release-3.0">release-3.0</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/snapshot-controller:v3.0.3</td><td>v1.17</td><td>-</td><td>v1.17</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-snapshotter/releases/tag/v2.1.4">external-snapshotter v2.1.4 (beta)</a></td><td><a href="https://github.com/kubernetes-csi/external-snapshotter/tree/release-2.1">release-2.1</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>quay.io/k8scsi/snapshot-controller:v2.1.4</td><td>v1.17</td><td>-</td><td>v1.17</td></tr>
</tbody></table>
<p>For more information on the CSI external-snapshotter sidecar, see <a href="external-snapshotter.html">this external-snapshotter page</a>.</p>
<h2><a class="header" href="#description" id="description">Description</a></h2>
<p>The snapshot controller will be watching the Kubernetes API server for <code>VolumeSnapshot</code> and <code>VolumeSnapshotContent</code> CRD objects. The CSI <code>external-snapshotter</code> sidecar only watches the Kubernetes API server for <code>VolumeSnapshotContent</code> CRD objects. The snapshot controller will be creating the <code>VolumeSnapshotContent</code> CRD object which triggers the CSI <code>external-snapshotter</code> sidecar to create a snapshot on the storage system.</p>
<p>For detailed snapshot beta design changes, see the design doc <a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-storage/177-volume-snapshot/README.md">here</a>.</p>
<p>For detailed information about volume snapshot and restore functionality, see <a href="snapshot-restore-feature.html">Volume Snapshot &amp; Restore</a>.</p>
<p>For detailed information (binary parameters, RBAC rules, etc.), see <a href="https://github.com/kubernetes-csi/external-snapshotter/blob/release-3.0/README.md">https://github.com/kubernetes-csi/external-snapshotter/blob/release-3.0/README.md</a>.</p>
<h2><a class="header" href="#deployment" id="deployment">Deployment</a></h2>
<p>Kubernetes distributors should bundle and deploy the controller and CRDs as part of their Kubernetes cluster management process (independent of any CSI Driver).</p>
<p>If your cluster does not come pre-installed with the correct components, you may manually install these components by executing the following steps.</p>
<p>Install Snapshot Beta CRDs per cluster:</p>
<pre><code>kubectl create -f  https://raw.githubusercontent.com/kubernetes-csi/external-snapshotter/release-3.0/client/config/crd/snapshot.storage.k8s.io_volumesnapshotclasses.yaml

kubectl create -f  https://raw.githubusercontent.com/kubernetes-csi/external-snapshotter/release-3.0/client/config/crd/snapshot.storage.k8s.io_volumesnapshotcontents.yaml

kubectl create -f  https://raw.githubusercontent.com/kubernetes-csi/external-snapshotter/release-3.0/client/config/crd/snapshot.storage.k8s.io_volumesnapshots.yaml
</code></pre>
<p>Install Snapshot Controller per cluster:</p>
<pre><code>kubectl apply -f https://raw.githubusercontent.com/kubernetes-csi/external-snapshotter/release-3.0/deploy/kubernetes/snapshot-controller/rbac-snapshot-controller.yaml

kubectl apply -f https://raw.githubusercontent.com/kubernetes-csi/external-snapshotter/release-3.0/deploy/kubernetes/snapshot-controller/setup-snapshot-controller.yaml
</code></pre>
<h1><a class="header" href="#snapshot-validation-webhook" id="snapshot-validation-webhook">Snapshot Validation Webhook</a></h1>
<h2><a class="header" href="#status-and-releases-1" id="status-and-releases-1">Status and Releases</a></h2>
<p><strong>Git Repository:</strong> <a href="https://github.com/kubernetes-csi/external-snapshotter">https://github.com/kubernetes-csi/external-snapshotter</a></p>
<p><strong>Status:</strong> GA as of 4.0.0</p>
<p>There is a new validating webhook server which provides tightened validation on snapshot objects. This SHOULD be installed by the Kubernetes distros along with the snapshot-controller, not end users. It SHOULD be installed in all Kubernetes clusters that has the snapshot feature enabled.</p>
<h3><a class="header" href="#supported-versions-1" id="supported-versions-1">Supported Versions</a></h3>
<table><thead><tr><th>Latest stable release</th><th>Branch</th><th>Min CSI Version</th><th>Max CSI Version</th><th>Container Image</th><th><a href="kubernetes-compatibility.html#minimum-version">Min K8s Version</a></th><th><a href="kubernetes-compatibility.html#maximum-version">Max K8s Version</a></th><th><a href="kubernetes-compatibility.html#recommended-version">Recommended K8s Version</a></th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/external-snapshotter/releases/tag/v4.1.1">snapshot-validation-webhook v4.1.1</a></td><td><a href="https://github.com/kubernetes-csi/external-snapshotter/tree/release-4.1">release-4.1</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/snapshot-validation-webhook:v4.1.0</td><td>v1.20</td><td>-</td><td>v1.20</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-snapshotter/releases/tag/v4.0.1">snapshot-validation-webhook v4.0.1</a></td><td><a href="https://github.com/kubernetes-csi/external-snapshotter/tree/release-4.0">release-4.0</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/snapshot-validation-webhook:v4.0.1</td><td>v1.20</td><td>-</td><td>v1.20</td></tr>
</tbody></table>
<h3><a class="header" href="#unsupported-versions-1" id="unsupported-versions-1">Unsupported Versions</a></h3>
<table><thead><tr><th>Latest stable release</th><th>Branch</th><th>Min CSI Version</th><th>Max CSI Version</th><th>Container Image</th><th><a href="kubernetes-compatibility.html#minimum-version">Min K8s Version</a></th><th><a href="kubernetes-compatibility.html#maximum-version">Max K8s Version</a></th><th><a href="kubernetes-compatibility.html#recommended-version">Recommended K8s Version</a></th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/external-snapshotter/releases/tag/v3.0.3">snapshot-validation-webhook v3.0.3</a></td><td><a href="https://github.com/kubernetes-csi/external-snapshotter/tree/release-3.0">release-3.0</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/snapshot-validation-webhook:v3.0.3</td><td>v1.17</td><td>-</td><td>v1.17</td></tr>
</tbody></table>
<h2><a class="header" href="#description-1" id="description-1">Description</a></h2>
<p>The snapshot validating webhook is an HTTP callback which responds to <a href="https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/">admission requests</a>. It is part of a larger <a href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-storage/1900-volume-snapshot-validation-webhook">plan</a> to tighten validation for volume snapshot objects. This webhook introduces the <a href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-storage/1900-volume-snapshot-validation-webhook#backwards-compatibility">ratcheting validation</a> mechanism targeting the tighter validation. The cluster admin or Kubernetes distribution admin should install the webhook alongside the snapshot controllers and CRDs.</p>
<blockquote>
<p>:warning: <strong>WARNING</strong>: Cluster admins choosing not to install the webhook server and participate in the phased release process can cause future problems when upgrading from <code>v1beta1</code> to <code>v1</code> volumesnapshot API, if there are currently persisted objects which fail the new stricter validation. Potential impacts include being unable to delete invalid snapshot objects.</p>
</blockquote>
<h2><a class="header" href="#deployment-1" id="deployment-1">Deployment</a></h2>
<p>Kubernetes distributors should bundle and deploy the snapshot validation webhook along with the snapshot controller and CRDs as part of their Kubernetes cluster management process (independent of any CSI Driver).</p>
<p>Read more about how to install the example webhook <a href="https://github.com/kubernetes-csi/external-snapshotter/tree/master/deploy/kubernetes/webhook-example">here</a>.</p>
<h1><a class="header" href="#csi-proxy" id="csi-proxy">CSI Proxy</a></h1>
<h2><a class="header" href="#status-and-releases-2" id="status-and-releases-2">Status and Releases</a></h2>
<p><strong>Git Repository:</strong> <a href="https://github.com/kubernetes-csi/csi-proxy">https://github.com/kubernetes-csi/csi-proxy</a></p>
<p><strong>Status:</strong> V1 starting with v1.0.0</p>
<table><thead><tr><th>Status</th><th>Min K8s Version</th><th>Max K8s Version</th></tr></thead><tbody>
<tr><td>v0.1.0</td><td>1.18</td><td>-</td></tr>
<tr><td>v0.2.0+</td><td>1.18</td><td>-</td></tr>
<tr><td>v1.0.0+</td><td>1.18</td><td>-</td></tr>
</tbody></table>
<h2><a class="header" href="#description-2" id="description-2">Description</a></h2>
<p>CSI Proxy is a binary that exposes a set of gRPC APIs around storage operations over named pipes in Windows. A container, such as CSI node plugins, can mount the named pipes depending on operations it wants to exercise on the host and invoke the APIs.</p>
<p>Each named pipe will support a specific version of an API (e.g. v1alpha1, v2beta1) that targets a specific area of storage (e.g. disk, volume, file, SMB, iSCSI). For example, <code>\\.\pipe\csi-proxy-filesystem-v1alpha1</code>, <code>\\.\pipe\csi-proxy-disk-v1beta1</code>. Any release of csi-proxy.exe binary will strive to maintain backward compatibility across as many prior stable versions of an API group as possible. Please see details in this <a href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-windows/1122-windows-csi-support">CSI Windows support KEP</a></p>
<h2><a class="header" href="#usage" id="usage">Usage</a></h2>
<p>Run csi-proxy.exe binary directly on a Windows node. The command line options are:</p>
<ul>
<li>
<p><code>-kubelet-path</code>: This is the prefix path of the kubelet directory in the host file system (the default value is set to <code>C:\var\lib\kubelet</code>)</p>
</li>
<li>
<p><code>-windows-service</code>: Configure as a Windows Service</p>
</li>
<li>
<p><code>-log_file</code>: If non-empty, use this log file. (Note: must set <code>logtostdrr</code>=false if setting -log_file)</p>
</li>
</ul>
<p>Note that <code>-kubelet-pod-path</code> and <code>-kubelet-csi-plugins-path</code> were used in prior 1.0.0 versions, and they are now replaced by new parameter <code>-kubelet-path</code></p>
<p>For detailed information (binary parameters, etc.), see the README of the relevant branch.</p>
<h2><a class="header" href="#deployment-2" id="deployment-2">Deployment</a></h2>
<p>It the responsibility of the Kubernetes distribution or cluster admin to install csi-proxy. Directly run csi-proxy.exe binary or run it as a Windows Service on Kubernetes nodes.
For example,</p>
<pre><code>    $flags = &quot;-windows-service -log_file=\etc\kubernetes\logs\csi-proxy.log -logtostderr=false&quot;
    sc.exe create csiproxy binPath= &quot;${env:NODE_DIR}\csi-proxy.exe $flags&quot;
    sc.exe failure csiproxy reset= 0 actions= restart/10000
    sc.exe start csiproxy
</code></pre>
<h1><a class="header" href="#kubernetes-csi-sidecar-containers" id="kubernetes-csi-sidecar-containers">Kubernetes CSI Sidecar Containers</a></h1>
<p>Kubernetes CSI Sidecar Containers are a set of standard containers that aim to simplify the development and deployment of CSI Drivers on Kubernetes.</p>
<p>These containers contain common logic to watch the Kubernetes API, trigger appropriate operations against the CSI volume driver container, and update the Kubernetes API as appropriate.</p>
<p>The containers are intended to be bundled with third-party CSI driver containers and deployed together as pods.</p>
<p>The containers are developed and maintained by the Kubernetes Storage community.</p>
<p>Use of the containers is strictly optional, but highly recommended.</p>
<p>Benefits of these sidecar containers include:</p>
<ul>
<li>Reduction of &quot;boilerplate&quot; code.
<ul>
<li>CSI Driver developers do not have to worry about complicated, &quot;Kubernetes specific&quot; code.</li>
</ul>
</li>
<li>Separation of concerns.
<ul>
<li>Code that interacts with the Kubernetes API is isolated from (and in a different container then) the code that implements the CSI interface.</li>
</ul>
</li>
</ul>
<p>The Kubernetes development team maintains the following Kubernetes CSI Sidecar Containers:</p>
<ul>
<li><a href="external-provisioner.html">external-provisioner</a></li>
<li><a href="external-attacher.html">external-attacher</a></li>
<li><a href="external-snapshotter.html">external-snapshotter</a></li>
<li><a href="external-resizer.html">external-resizer</a></li>
<li><a href="node-driver-registrar.html">node-driver-registrar</a></li>
<li><a href="cluster-driver-registrar.html">cluster-driver-registrar</a> (deprecated)</li>
<li><a href="livenessprobe.html">livenessprobe</a></li>
</ul>
<h1><a class="header" href="#csi-external-attacher" id="csi-external-attacher">CSI external-attacher</a></h1>
<h2><a class="header" href="#status-and-releases-3" id="status-and-releases-3">Status and Releases</a></h2>
<p><strong>Git Repository:</strong> <a href="https://github.com/kubernetes-csi/external-attacher">https://github.com/kubernetes-csi/external-attacher</a></p>
<p><strong>Status:</strong> GA/Stable</p>
<h3><a class="header" href="#supported-versions-2" id="supported-versions-2">Supported Versions</a></h3>
<table><thead><tr><th>Latest stable release</th><th>Branch</th><th>Min CSI Version</th><th>Max CSI Version</th><th>Container Image</th><th><a href="kubernetes-compatibility.html#minimum-version">Min K8s Version</a></th><th><a href="kubernetes-compatibility.html#maximum-version">Max K8s Version</a></th><th><a href="kubernetes-compatibility.html#recommended-version">Recommended K8s Version</a></th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/external-attacher/releases/tag/v3.4.0">external-attacher v3.4.0</a></td><td><a href="https://github.com/kubernetes-csi/external-attacher/tree/release-3.4">release-3.4</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/csi-attacher:v3.4.0</td><td>v1.17</td><td>-</td><td>v1.22</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-attacher/releases/tag/v3.3.0">external-attacher v3.3.0</a></td><td><a href="https://github.com/kubernetes-csi/external-attacher/tree/release-3.3">release-3.3</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/csi-attacher:v3.3.0</td><td>v1.17</td><td>-</td><td>v1.22</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-attacher/releases/tag/v3.2.1">external-attacher v3.2.1</a></td><td><a href="https://github.com/kubernetes-csi/external-attacher/tree/release-3.2">release-3.2</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/csi-attacher:v3.2.1</td><td>v1.17</td><td>-</td><td>v1.17</td></tr>
</tbody></table>
<h3><a class="header" href="#unsupported-versions-2" id="unsupported-versions-2">Unsupported Versions</a></h3>
<table><thead><tr><th>Latest stable release</th><th>Branch</th><th>Min CSI Version</th><th>Max CSI Version</th><th>Container Image</th><th><a href="kubernetes-compatibility.html#minimum-version">Min K8s Version</a></th><th><a href="kubernetes-compatibility.html#maximum-version">Max K8s Version</a></th><th><a href="kubernetes-compatibility.html#recommended-version">Recommended K8s Version</a></th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/external-attacher/releases/tag/v3.1.0">external-attacher v3.1.0</a></td><td><a href="https://github.com/kubernetes-csi/external-attacher/tree/release-3.1">release-3.1</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/csi-attacher:v3.1.0</td><td>v1.17</td><td>-</td><td>v1.17</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-attacher/releases/tag/v3.0.2">external-attacher v3.0.2</a></td><td><a href="https://github.com/kubernetes-csi/external-attacher/tree/release-3.0">release-3.0</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/csi-attacher:v3.0.2</td><td>v1.17</td><td>-</td><td>v1.17</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-attacher/releases/tag/v2.2.0">external-attacher v2.2.0</a></td><td><a href="https://github.com/kubernetes-csi/external-attacher/tree/release-2.2">release-2.2</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>quay.io/k8scsi/csi-attacher:v2.2.0</td><td>v1.14</td><td>-</td><td>v1.17</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-attacher/releases/tag/v2.1.0">external-attacher v2.1.0</a></td><td><a href="https://github.com/kubernetes-csi/external-attacher/tree/release-2.1">release-2.1</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>quay.io/k8scsi/csi-attacher:v2.1.0</td><td>v1.14</td><td>-</td><td>v1.17</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-attacher/releases/tag/v2.0.0">external-attacher v2.0.0</a></td><td><a href="https://github.com/kubernetes-csi/external-attacher/tree/release-2.0">release-2.0</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>quay.io/k8scsi/csi-attacher:v2.0.0</td><td>v1.14</td><td>-</td><td>v1.15</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-attacher/releases/tag/v1.2.1">external-attacher v1.2.1</a></td><td><a href="https://github.com/kubernetes-csi/external-attacher/tree/release-1.2">release-1.2</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>quay.io/k8scsi/csi-attacher:v1.2.1</td><td>v1.13</td><td>-</td><td>v1.15</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-attacher/releases/tag/v1.1.1">external-attacher v1.1.1</a></td><td><a href="https://github.com/kubernetes-csi/external-attacher/tree/release-1.1">release-1.1</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>quay.io/k8scsi/csi-attacher:v1.1.1</td><td>v1.13</td><td>-</td><td>v1.14</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-attacher/releases/tag/v0.4.2">external-attacher v0.4.2</a></td><td><a href="https://github.com/kubernetes-csi/external-attacher/tree/release-0.4">release-0.4</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a></td><td>quay.io/k8scsi/csi-attacher:v0.4.2</td><td>v1.10</td><td>v1.16</td><td>v1.10</td></tr>
</tbody></table>
<h2><a class="header" href="#description-3" id="description-3">Description</a></h2>
<p>The CSI <code>external-attacher</code> is a sidecar container that watches the Kubernetes API server for <code>VolumeAttachment</code> objects and triggers <code>Controller[Publish|Unpublish]Volume</code> operations against a CSI endpoint.</p>
<h2><a class="header" href="#usage-1" id="usage-1">Usage</a></h2>
<p>CSI drivers that require integrating with the Kubernetes volume attach/detach hooks should use this sidecar container, and advertise the CSI <code>PUBLISH_UNPUBLISH_VOLUME</code> controller capability.</p>
<p>For detailed information (binary parameters, RBAC rules, etc.), see <a href="https://github.com/kubernetes-csi/external-attacher/blob/master/README.md">https://github.com/kubernetes-csi/external-attacher/blob/master/README.md</a>.</p>
<h2><a class="header" href="#deployment-3" id="deployment-3">Deployment</a></h2>
<p>The CSI <code>external-attacher</code> is deployed as a controller. See <a href="deploying.html">deployment section</a> for more details.</p>
<h1><a class="header" href="#csi-external-provisioner" id="csi-external-provisioner">CSI external-provisioner</a></h1>
<h2><a class="header" href="#status-and-releases-4" id="status-and-releases-4">Status and Releases</a></h2>
<p><strong>Git Repository:</strong> <a href="https://github.com/kubernetes-csi/external-provisioner">https://github.com/kubernetes-csi/external-provisioner</a></p>
<p><strong>Status:</strong> GA/Stable</p>
<h3><a class="header" href="#supported-versions-3" id="supported-versions-3">Supported Versions</a></h3>
<table><thead><tr><th>Latest stable release</th><th>Branch</th><th>Min CSI Version</th><th>Max CSI Version</th><th>Container Image</th><th><a href="kubernetes-compatibility.html#minimum-version">Min K8s Version</a></th><th><a href="kubernetes-compatibility.html#maximum-version">Max K8s Version</a></th><th><a href="kubernetes-compatibility.html#recommended-version">Recommended K8s Version</a></th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/external-provisioner/releases/tag/v3.1.0">external-provisioner v3.1.0</a></td><td><a href="https://github.com/kubernetes-csi/external-provisioner/tree/release-3.1">release-3.1</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.5.0">v1.5.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/csi-provisioner:v3.1.0</td><td>v1.20</td><td>-</td><td>v1.22</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-provisioner/releases/tag/v3.0.0">external-provisioner v3.0.0</a></td><td><a href="https://github.com/kubernetes-csi/external-provisioner/tree/release-3.0">release-3.0</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.5.0">v1.5.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/csi-provisioner:v3.0.0</td><td>v1.20</td><td>-</td><td>v1.22</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-provisioner/releases/tag/v2.2.2">external-provisioner v2.2.2</a></td><td><a href="https://github.com/kubernetes-csi/external-provisioner/tree/release-2.2">release-2.2</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.4.0">v1.4.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/csi-provisioner:v2.2.2</td><td>v1.17</td><td>-</td><td>v1.21</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-provisioner/releases/tag/v2.1.2">external-provisioner v2.1.2</a></td><td><a href="https://github.com/kubernetes-csi/external-provisioner/tree/release-2.1">release-2.1</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/csi-provisioner:v2.1.2</td><td>v1.17</td><td>-</td><td>v1.19</td></tr>
</tbody></table>
<h3><a class="header" href="#unsupported-versions-3" id="unsupported-versions-3">Unsupported Versions</a></h3>
<table><thead><tr><th>Latest stable release</th><th>Branch</th><th>Min CSI Version</th><th>Max CSI Version</th><th>Container Image</th><th><a href="kubernetes-compatibility.html#minimum-version">Min K8s Version</a></th><th><a href="kubernetes-compatibility.html#maximum-version">Max K8s Version</a></th><th><a href="kubernetes-compatibility.html#recommended-version">Recommended K8s Version</a></th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/external-provisioner/releases/tag/v2.0.5">external-provisioner v2.0.5</a></td><td><a href="https://github.com/kubernetes-csi/external-provisioner/tree/release-2.0">release-2.0</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/csi-provisioner:v2.0.5</td><td>v1.17</td><td>-</td><td>v1.19</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-provisioner/releases/tag/v1.6.1">external-provisioner v1.6.1</a></td><td><a href="https://github.com/kubernetes-csi/external-provisioner/tree/release-1.6">release-1.6</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/csi-provisioner:v1.6.1</td><td>v1.13</td><td>v1.21</td><td>v1.18</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-provisioner/releases/tag/v1.5.0">external-provisioner v1.5.0</a></td><td><a href="https://github.com/kubernetes-csi/external-provisioner/tree/release-1.5">release-1.5</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>quay.io/k8scsi/csi-provisioner:v1.5.0</td><td>v1.13</td><td>v1.21</td><td>v1.17</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-provisioner/releases/tag/v1.4.0">external-provisioner v1.4.0</a></td><td><a href="https://github.com/kubernetes-csi/external-provisioner/tree/release-1.4">release-1.4</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>quay.io/k8scsi/csi-provisioner:v1.4.0</td><td>v1.13</td><td>v1.21</td><td>v1.16</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-provisioner/releases/tag/v1.3.1">external-provisioner v1.3.1</a></td><td><a href="https://github.com/kubernetes-csi/external-provisioner/tree/release-1.3">release-1.3</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>quay.io/k8scsi/csi-provisioner:v1.3.1</td><td>v1.13</td><td>v1.19</td><td>v1.15</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-provisioner/releases/tag/v1.2.2">external-provisioner v1.2.0</a></td><td><a href="https://github.com/kubernetes-csi/external-provisioner/tree/release-1.2">release-1.2</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>quay.io/k8scsi/csi-provisioner:v1.2.0</td><td>v1.13</td><td>v1.19</td><td>v1.14</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-provisioner/releases/tag/v0.4.2">external-provisioner v0.4.2</a></td><td><a href="https://github.com/kubernetes-csi/external-provisioner/tree/release-0.4">release-0.4</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a></td><td>quay.io/k8scsi/csi-provisioner:v0.4.2</td><td>v1.10</td><td>v1.16</td><td>v1.10</td></tr>
</tbody></table>
<h2><a class="header" href="#description-4" id="description-4">Description</a></h2>
<p>The CSI <code>external-provisioner</code> is a sidecar container that watches the Kubernetes API server for <code>PersistentVolumeClaim</code> objects.</p>
<p>It calls <code>CreateVolume</code> against the specified CSI endpoint to provision a new volume.</p>
<p>Volume provisioning is triggered by the creation of a new Kubernetes <code>PersistentVolumeClaim</code> object, if the PVC references a Kubernetes <code>StorageClass</code>, and the name in the <code>provisioner</code> field of the storage class matches the name returned by the specified CSI endpoint in the <code>GetPluginInfo</code> call.</p>
<p>Once a new volume is successfully provisioned, the sidecar container creates a Kubernetes <code>PersistentVolume</code> object to represent the volume.</p>
<p>The deletion of a <code>PersistentVolumeClaim</code> object bound to a <code>PersistentVolume</code> corresponding to this driver with a <code>delete</code> reclaim policy causes the sidecar container to trigger a <code>DeleteVolume</code> operation against the specified CSI endpoint to delete the volume. Once the volume is successfully deleted, the sidecar container also deletes the <code>PersistentVolume</code> object representing the volume.</p>
<h3><a class="header" href="#datasources" id="datasources">DataSources</a></h3>
<p>The external-provisioner provides the ability to request a volume be pre-populated from a data source during provisioning.
For more information on how data sources are handled see <a href="volume-datasources.html">DataSources</a>.</p>
<h4><a class="header" href="#snapshot" id="snapshot">Snapshot</a></h4>
<p>The CSI <code>external-provisioner</code> supports the <code>Snapshot</code> DataSource. If a <code>Snapshot</code> CRD is specified as a data source on a PVC object, the sidecar container fetches the information about the snapshot by fetching the <code>SnapshotContent</code> object and populates the data source field in the resulting <code>CreateVolume</code> call to indicate to the storage system that the new volume should be populated using the specified snapshot.</p>
<h4><a class="header" href="#persistentvolumeclaim-clone" id="persistentvolumeclaim-clone">PersistentVolumeClaim (clone)</a></h4>
<p>Cloning is also implemented by specifying a <code>kind:</code> of type <code>PersistentVolumeClaim</code> in the DataSource field of a Provision request.  It's the responsbility of the external-provisioner to verify that the claim specified in the DataSource object exists, is in the same storage class as the volume being provisioned and that the claim is currently <code>Bound</code>.</p>
<h3><a class="header" href="#storageclass-parameters" id="storageclass-parameters">StorageClass Parameters</a></h3>
<p>When provisioning a new volume, the CSI <code>external-provisioner</code> sets the <code>map&lt;string, string&gt; parameters</code> field in the CSI <code>CreateVolumeRequest</code> call to the key/values specified in the <code>StorageClass</code> it is handling.</p>
<p>The CSI <code>external-provisioner</code> (v1.0.1+) also reserves the parameter keys prefixed with <code>csi.storage.k8s.io/</code>. Any <code>StorageClass</code> keys prefixed with <code>csi.storage.k8s.io/</code> are not passed to the CSI driver as an opaque <code>parameter</code>.</p>
<p>The following reserved <code>StorageClass</code> parameter keys trigger behavior in the CSI <code>external-provisioner</code>:</p>
<ul>
<li><code>csi.storage.k8s.io/provisioner-secret-name</code></li>
<li><code>csi.storage.k8s.io/provisioner-secret-namespace</code></li>
<li><code>csi.storage.k8s.io/controller-publish-secret-name</code></li>
<li><code>csi.storage.k8s.io/controller-publish-secret-namespace</code></li>
<li><code>csi.storage.k8s.io/node-stage-secret-name</code></li>
<li><code>csi.storage.k8s.io/node-stage-secret-namespace</code></li>
<li><code>csi.storage.k8s.io/node-publish-secret-name</code></li>
<li><code>csi.storage.k8s.io/node-publish-secret-namespace</code></li>
<li><code>csi.storage.k8s.io/fstype</code></li>
</ul>
<p>If the PVC <code>VolumeMode</code> is set to <code>Filesystem</code>, and the value of <code>csi.storage.k8s.io/fstype</code> is specified, it is used to populate the <code>FsType</code> in <code>CreateVolumeRequest.VolumeCapabilities[x].AccessType</code> and the <code>AccessType</code> is set to <code>Mount</code>.</p>
<p>For more information on how secrets are handled see <a href="secrets-and-credentials.html">Secrets &amp; Credentials</a>.</p>
<p>Example <code>StorageClass</code>:</p>
<pre><code>apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: gold-example-storage
provisioner: exampledriver.example.com
parameters:
  disk-type: ssd
  csi.storage.k8s.io/fstype: ext4
  csi.storage.k8s.io/provisioner-secret-name: mysecret
  csi.storage.k8s.io/provisioner-secret-namespace: mynamespace
</code></pre>
<h3><a class="header" href="#persistentvolumeclaim-and-persistentvolume-parameters" id="persistentvolumeclaim-and-persistentvolume-parameters">PersistentVolumeClaim and PersistentVolume Parameters</a></h3>
<p>The CSI <code>external-provisioner</code> (v1.6.0+) introduces the <code>--extra-create-metadata</code> flag, which automatically sets the following <code>map&lt;string, string&gt; parameters</code> in the CSI <code>CreateVolumeRequest</code>:</p>
<ul>
<li><code>csi.storage.k8s.io/pvc/name</code></li>
<li><code>csi.storage.k8s.io/pvc/namespace</code></li>
<li><code>csi.storage.k8s.io/pv/name</code></li>
</ul>
<p>These parameters are not part of the <code>StorageClass</code>, but are internally generated using the name and namespace of the source <code>PersistentVolumeClaim</code> and <code>PersistentVolume</code>.</p>
<h2><a class="header" href="#usage-2" id="usage-2">Usage</a></h2>
<p>CSI drivers that support dynamic volume provisioning should use this sidecar container, and advertise the CSI <code>CREATE_DELETE_VOLUME</code> controller capability.</p>
<p>For detailed information (binary parameters, RBAC rules, etc.), see <a href="https://github.com/kubernetes-csi/external-provisioner/blob/master/README.md">https://github.com/kubernetes-csi/external-provisioner/blob/master/README.md</a>.</p>
<h2><a class="header" href="#deployment-4" id="deployment-4">Deployment</a></h2>
<p>The CSI <code>external-provisioner</code> is deployed as a controller. See <a href="deploying.html">deployment section</a> for more details.</p>
<h1><a class="header" href="#csi-external-resizer" id="csi-external-resizer">CSI external-resizer</a></h1>
<h2><a class="header" href="#status-and-releases-5" id="status-and-releases-5">Status and Releases</a></h2>
<p><strong>Git Repository:</strong> <a href="https://github.com/kubernetes-csi/external-resizer">https://github.com/kubernetes-csi/external-resizer</a></p>
<p><strong>Status:</strong> Beta starting with v0.3.0</p>
<h3><a class="header" href="#supported-versions-4" id="supported-versions-4">Supported Versions</a></h3>
<table><thead><tr><th>Latest stable release</th><th>Branch</th><th>Min CSI Version</th><th>Max CSI Version</th><th>Container Image</th><th><a href="kubernetes-compatibility.html#minimum-version">Min K8s Version</a></th><th><a href="kubernetes-compatibility.html#maximum-version">Max K8s Version</a></th><th><a href="kubernetes-compatibility.html#recommended-version">Recommended K8s Version</a></th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/external-resizer/tree/v1.4.0">external-resizer v1.4.0</a></td><td><a href="https://github.com/kubernetes-csi/external-resizer/tree/release-1.4">release-1.4</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.5.0">v1.4.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/csi-resizer:v1.4.0</td><td>v1.16</td><td>-</td><td>v1.23</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-resizer/tree/v1.3.0">external-resizer v1.3.0</a></td><td><a href="https://github.com/kubernetes-csi/external-resizer/tree/release-1.3">release-1.3</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.3.0">v1.3.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/csi-resizer:v1.3.0</td><td>v1.16</td><td>-</td><td>v1.22</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-resizer/tree/v1.2.0">external-resizer v1.2.0</a></td><td><a href="https://github.com/kubernetes-csi/external-resizer/tree/release-1.2">release-1.2</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.2.0">v1.2.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/csi-resizer:v1.2.0</td><td>v1.16</td><td>-</td><td>v1.21</td></tr>
</tbody></table>
<h3><a class="header" href="#unsupported-versions-4" id="unsupported-versions-4">Unsupported Versions</a></h3>
<table><thead><tr><th>Latest stable release</th><th>Branch</th><th>Min CSI Version</th><th>Max CSI Version</th><th>Container Image</th><th><a href="kubernetes-compatibility.html#minimum-version">Min K8s Version</a></th><th><a href="kubernetes-compatibility.html#maximum-version">Max K8s Version</a></th><th><a href="kubernetes-compatibility.html#recommended-version">Recommended K8s Version</a></th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/external-resizer/tree/v1.1.0">external-resizer v1.1.0</a></td><td><a href="https://github.com/kubernetes-csi/external-resizer/tree/release-1.1">release-1.1</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.2.0">v1.2.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/csi-resizer:v1.1.0</td><td>v1.16</td><td>-</td><td>v1.16</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-resizer/tree/v0.5.0">external-resizer v0.5.0</a></td><td><a href="https://github.com/kubernetes-csi/external-resizer/tree/release-0.5">release-0.5</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.2.0">v1.2.0</a></td><td>-</td><td>quay.io/k8scsi/csi-resizer:v0.5.0</td><td>v1.15</td><td>-</td><td>v1.16</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-resizer/tree/v0.2.0">external-resizer v0.2.0</a></td><td><a href="https://github.com/kubernetes-csi/external-resizer/tree/release-0.2">release-0.2</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.1.0">v1.1.0</a></td><td>-</td><td>quay.io/k8scsi/csi-resizer:v0.2.0</td><td>v1.15</td><td>-</td><td>v1.15</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-resizer/tree/v0.1.0">external-resizer v0.1.0</a></td><td><a href="https://github.com/kubernetes-csi/external-resizer/tree/release-0.1">release-0.1</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.1.0">v1.1.0</a></td><td>-</td><td>quay.io/k8scsi/csi-resizer:v0.1.0</td><td>v1.14</td><td>v1.14</td><td>v1.14</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-resizer/tree/v1.0.1">external-resizer v1.0.1</a></td><td><a href="https://github.com/kubernetes-csi/external-resizer/tree/release-1.0">release-1.0</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.2.0">v1.2.0</a></td><td>-</td><td>quay.io/k8scsi/csi-resizer:v1.0.1</td><td>v1.16</td><td>-</td><td>v1.16</td></tr>
</tbody></table>
<h2><a class="header" href="#description-5" id="description-5">Description</a></h2>
<p>The CSI <code>external-resizer</code> is a sidecar container that watches the Kubernetes API server for <code>PersistentVolumeClaim</code> object edits and
triggers <code>ControllerExpandVolume</code> operations against a CSI endpoint if user requested more storage on <code>PersistentVolumeClaim</code> object.</p>
<h2><a class="header" href="#usage-3" id="usage-3">Usage</a></h2>
<p>CSI drivers that support Kubernetes volume expansion should use this sidecar container, and advertise the CSI <code>VolumeExpansion</code> plugin capability.</p>
<h2><a class="header" href="#deployment-5" id="deployment-5">Deployment</a></h2>
<p>The CSI <code>external-resizer</code> is deployed as a controller. See <a href="deploying.html">deployment section</a> for more details.</p>
<h1><a class="header" href="#csi-external-snapshotter" id="csi-external-snapshotter">CSI external-snapshotter</a></h1>
<h2><a class="header" href="#status-and-releases-6" id="status-and-releases-6">Status and Releases</a></h2>
<p><strong>Git Repository:</strong> <a href="https://github.com/kubernetes-csi/external-snapshotter">https://github.com/kubernetes-csi/external-snapshotter</a></p>
<p><strong>Status:</strong> GA v4.0.0+</p>
<h3><a class="header" href="#supported-versions-5" id="supported-versions-5">Supported Versions</a></h3>
<table><thead><tr><th>Latest stable release</th><th>Branch</th><th>Min CSI Version</th><th>Max CSI Version</th><th>Container Image</th><th><a href="kubernetes-compatibility.html#minimum-version">Min K8s Version</a></th><th><a href="kubernetes-compatibility.html#maximum-version">Max K8s Version</a></th><th><a href="kubernetes-compatibility.html#recommended-version">Recommended K8s Version</a></th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/external-snapshotter/releases/tag/v5.0.1">external-snapshotter v5.0.1</a></td><td><a href="https://github.com/kubernetes-csi/external-snapshotter/tree/release-5.0">release-5.1</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.5.0">v1.0.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/csi-snapshotter:v5.0.1</td><td>v1.20</td><td>-</td><td>v1.22</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-snapshotter/releases/tag/v4.2.1">external-snapshotter v4.2.1</a></td><td><a href="https://github.com/kubernetes-csi/external-snapshotter/tree/release-4.2">release-4.2</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.3.0">v1.0.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/csi-snapshotter:v4.2.1</td><td>v1.20</td><td>-</td><td>v1.22</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-snapshotter/releases/tag/v4.1.1">external-snapshotter v4.1.1</a></td><td><a href="https://github.com/kubernetes-csi/external-snapshotter/tree/release-4.1">release-4.1</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/csi-snapshotter:v4.1.1</td><td>v1.20</td><td>-</td><td>v1.20</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-snapshotter/releases/tag/v4.0.1">external-snapshotter v4.0.1</a></td><td><a href="https://github.com/kubernetes-csi/external-snapshotter/tree/release-4.0">release-4.0</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/csi-snapshotter:v4.0.1</td><td>v1.20</td><td>-</td><td>v1.20</td></tr>
</tbody></table>
<h3><a class="header" href="#unsupported-versions-5" id="unsupported-versions-5">Unsupported Versions</a></h3>
<table><thead><tr><th>Latest stable release</th><th>Branch</th><th>Min CSI Version</th><th>Max CSI Version</th><th>Container Image</th><th><a href="kubernetes-compatibility.html#minimum-version">Min K8s Version</a></th><th><a href="kubernetes-compatibility.html#maximum-version">Max K8s Version</a></th><th><a href="kubernetes-compatibility.html#recommended-version">Recommended K8s Version</a></th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/external-snapshotter/releases/tag/v3.0.3">external-snapshotter v3.0.3 (beta)</a></td><td><a href="https://github.com/kubernetes-csi/external-snapshotter/tree/release-3.0">release-3.0</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/csi-snapshotter:v3.0.3</td><td>v1.17</td><td>-</td><td>v1.17</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-snapshotter/releases/tag/v2.1.4">external-snapshotter v2.1.4 (beta)</a></td><td><a href="https://github.com/kubernetes-csi/external-snapshotter/tree/release-2.1">release-2.1</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/csi-snapshotter:v2.1.4</td><td>v1.17</td><td>-</td><td>v1.17</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-snapshotter/releases/tag/v1.2.2">external-snapshotter v1.2.2 (alpha)</a></td><td><a href="https://github.com/kubernetes-csi/external-snapshotter/tree/release-1.2">release-1.2</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>quay.io/k8scsi/csi-snapshotter:v1.2.2</td><td>v1.13</td><td>v1.16</td><td>v1.14</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-snapshotter/releases/tag/v0.4.2">external-snapshotter v0.4.2 (alpha)</a></td><td><a href="https://github.com/kubernetes-csi/external-snapshotter/tree/release-0.4">release-0.4</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a></td><td>quay.io/k8scsi/csi-snapshotter:v0.4.2</td><td>v1.12</td><td>v1.16</td><td>v1.12</td></tr>
</tbody></table>
<p>To use the snapshot beta and GA feature, a snapshot controller is also required. For more information, see <a href="snapshot-controller.html">this snapshot-controller page</a>.</p>
<h2><a class="header" href="#snapshot-betaga" id="snapshot-betaga">Snapshot Beta/GA</a></h2>
<h3><a class="header" href="#description-6" id="description-6">Description</a></h3>
<p>Starting with the Beta version, the snapshot controller will be watching the Kubernetes API server for <code>VolumeSnapshot</code> and <code>VolumeSnapshotContent</code> CRD objects. The CSI <code>external-snapshotter</code> sidecar only watches the Kubernetes API server for <code>VolumeSnapshotContent</code> CRD objects. The CSI <code>external-snapshotter</code> sidecar is also responsible for calling the CSI RPCs CreateSnapshot, DeleteSnapshot, and ListSnapshots.</p>
<h4><a class="header" href="#volumesnapshotclass-parameters" id="volumesnapshotclass-parameters">VolumeSnapshotClass Parameters</a></h4>
<p>When provisioning a new volume snapshot, the CSI <code>external-snapshotter</code> sets the <code>map&lt;string, string&gt; parameters</code> field in the CSI <code>CreateSnapshotRequest</code> call to the key/values specified in the <code>VolumeSnapshotClass</code> it is handling.</p>
<p>The CSI <code>external-snapshotter</code> also reserves the parameter keys prefixed with <code>csi.storage.k8s.io/</code>. Any <code>VolumeSnapshotClass</code> keys prefixed with <code>csi.storage.k8s.io/</code> are not passed to the CSI driver as an opaque <code>parameter</code>.</p>
<p>The following reserved <code>VolumeSnapshotClass</code> parameter keys trigger behavior in the CSI <code>external-snapshotter</code>:</p>
<ul>
<li><code>csi.storage.k8s.io/snapshotter-secret-name</code> (v1.0.1+)</li>
<li><code>csi.storage.k8s.io/snapshotter-secret-namespace</code> (v1.0.1+)</li>
<li><code>csi.storage.k8s.io/snapshotter-list-secret-name</code> (v2.1.0+)</li>
<li><code>csi.storage.k8s.io/snapshotter-list-secret-namespace</code> (v2.1.0+)</li>
</ul>
<p>For more information on how secrets are handled see <a href="secrets-and-credentials.html">Secrets &amp; Credentials</a>.</p>
<h4><a class="header" href="#volumesnapshot-and-volumesnapshotcontent-parameters" id="volumesnapshot-and-volumesnapshotcontent-parameters">VolumeSnapshot and VolumeSnapshotContent Parameters</a></h4>
<p>The CSI <code>external-snapshotter</code> (v4.0.0+) introduces the <code>--extra-create-metadata</code> flag, which automatically sets the following <code>map&lt;string, string&gt; parameters</code> in the CSI <code>CreateSnapshotRequest</code>:</p>
<ul>
<li><code>csi.storage.k8s.io/volumesnapshot/name</code></li>
<li><code>csi.storage.k8s.io/volumesnapshot/namespace</code></li>
<li><code>csi.storage.k8s.io/volumesnapshotcontent/name</code></li>
</ul>
<p>These parameters are internally generated using the name and namespace of the source <code>VolumeSnapshot</code> and <code>VolumeSnapshotContent</code>.</p>
<p>For detailed snapshot beta design changes, see the design doc <a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-storage/177-volume-snapshot/README.md">here</a>.</p>
<p>For detailed information about volume snapshot and restore functionality, see <a href="snapshot-restore-feature.html">Volume Snapshot &amp; Restore</a>.</p>
<h3><a class="header" href="#usage-4" id="usage-4">Usage</a></h3>
<p>CSI drivers that support provisioning volume snapshots and the ability to provision new volumes using those snapshots should use this sidecar container, and advertise the CSI <code>CREATE_DELETE_SNAPSHOT</code> controller capability.</p>
<p>For detailed information (binary parameters, RBAC rules, etc.), see <a href="https://github.com/kubernetes-csi/external-snapshotter/blob/release-2.0/README.md">https://github.com/kubernetes-csi/external-snapshotter/blob/release-2.0/README.md</a>.</p>
<h3><a class="header" href="#deployment-6" id="deployment-6">Deployment</a></h3>
<p>The CSI <code>external-snapshotter</code> is deployed as a sidecar controller. See <a href="deploying.html">deployment section</a> for more details.</p>
<p>For an example deployment, see <a href="https://github.com/kubernetes-csi/external-snapshotter/blob/release-2.0/deploy/kubernetes/csi-snapshotter/setup-csi-snapshotter.yaml">this example</a> which deploys <code>external-snapshotter</code> and <code>external-provisioner</code> with the Hostpath CSI driver.</p>
<h2><a class="header" href="#snapshot-alpha" id="snapshot-alpha">Snapshot Alpha</a></h2>
<h3><a class="header" href="#description-7" id="description-7">Description</a></h3>
<p>The CSI <code>external-snapshotter</code> is a sidecar container that watches the Kubernetes API server for <code>VolumeSnapshot</code> and <code>VolumeSnapshotContent</code> CRD objects.</p>
<p>The creation of a new <code>VolumeSnapshot</code> object referencing a <code>SnapshotClass</code> CRD object corresponding to this driver causes the sidecar container to trigger a <code>CreateSnapshot</code> operation against the specified CSI endpoint to provision a new snapshot. When a new snapshot is successfully provisioned, the sidecar container creates a Kubernetes <code>VolumeSnapshotContent</code> object to represent the new snapshot.</p>
<p>The deletion of a <code>VolumeSnapshot</code> object bound to a <code>VolumeSnapshotContent</code> corresponding to this driver with a <code>delete</code> deletion policy causes the sidecar container to trigger a <code>DeleteSnapshot</code> operation against the specified CSI endpoint to delete the snapshot. Once the snapshot is successfully deleted, the sidecar container also deletes the <code>VolumeSnapshotContent</code> object representing the snapshot.</p>
<h3><a class="header" href="#usage-5" id="usage-5">Usage</a></h3>
<p>CSI drivers that support provisioning volume snapshots and the ability to provision new volumes using those snapshots should use this sidecar container, and advertise the CSI <code>CREATE_DELETE_SNAPSHOT</code> controller capability.</p>
<p>For detailed information (binary parameters, RBAC rules, etc.), see <a href="https://github.com/kubernetes-csi/external-snapshotter/blob/release-1.2/README.md">https://github.com/kubernetes-csi/external-snapshotter/blob/release-1.2/README.md</a>.</p>
<h3><a class="header" href="#deployment-7" id="deployment-7">Deployment</a></h3>
<p>The CSI <code>external-snapshotter</code> is deployed as a controller. See <a href="deploying.html">deployment section</a> for more details.</p>
<p>For an example deployment, see <a href="https://github.com/kubernetes-csi/external-snapshotter/tree/release-1.2/deploy/kubernetes/setup-csi-snapshotter.yaml">this example</a> which deploys <code>external-snapshotter</code> and <code>external-provisioner</code> with the Hostpath CSI driver.</p>
<h1><a class="header" href="#csi-livenessprobe" id="csi-livenessprobe">CSI livenessprobe</a></h1>
<h2><a class="header" href="#status-and-releases-7" id="status-and-releases-7">Status and Releases</a></h2>
<p><strong>Git Repository:</strong> <a href="https://github.com/kubernetes-csi/livenessprobe">https://github.com/kubernetes-csi/livenessprobe</a></p>
<p><strong>Status:</strong> GA/Stable</p>
<h3><a class="header" href="#supported-versions-6" id="supported-versions-6">Supported Versions</a></h3>
<table><thead><tr><th>Latest stable release</th><th>Branch</th><th>Min CSI Version</th><th>Max CSI Version</th><th>Container Image</th><th><a href="kubernetes-compatibility.html#minimum-version">Min K8s Version</a></th><th><a href="kubernetes-compatibility.html#maximum-version">Max K8s Version</a></th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/livenessprobe/releases/tag/v2.5.0">livenessprobe v2.6.0</a></td><td><a href="https://github.com/kubernetes-csi/livenessprobe/tree/release-2.6">release-2.6</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/livenessprobe:v2.6.0</td><td>v1.13</td><td>-</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/livenessprobe/releases/tag/v2.5.0">livenessprobe v2.5.0</a></td><td><a href="https://github.com/kubernetes-csi/livenessprobe/tree/release-2.5">release-2.5</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/livenessprobe:v2.5.0</td><td>v1.13</td><td>-</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/livenessprobe/releases/tag/v2.4.0">livenessprobe v2.4.0</a></td><td><a href="https://github.com/kubernetes-csi/livenessprobe/tree/release-2.4">release-2.4</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/livenessprobe:v2.4.0</td><td>v1.13</td><td>-</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/livenessprobe/releases/tag/v2.3.0">livenessprobe v2.3.0</a></td><td><a href="https://github.com/kubernetes-csi/livenessprobe/tree/release-2.3">release-2.3</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/livenessprobe:v2.3.0</td><td>v1.13</td><td>-</td></tr>
</tbody></table>
<h3><a class="header" href="#unsupported-versions-6" id="unsupported-versions-6">Unsupported Versions</a></h3>
<table><thead><tr><th>Latest stable release</th><th>Branch</th><th>Min CSI Version</th><th>Max CSI Version</th><th>Container Image</th><th><a href="kubernetes-compatibility.html#minimum-version">Min K8s Version</a></th><th><a href="kubernetes-compatibility.html#maximum-version">Max K8s Version</a></th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/livenessprobe/releases/tag/v2.2.0">livenessprobe v2.2.0</a></td><td><a href="https://github.com/kubernetes-csi/livenessprobe/tree/release-2.2">release-2.2</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/livenessprobe:v2.2.0</td><td>v1.13</td><td>-</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/livenessprobe/releases/tag/v2.1.0">livenessprobe v2.1.0</a></td><td><a href="https://github.com/kubernetes-csi/livenessprobe/tree/release-2.1">release-2.1</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/livenessprobe:v2.1.0</td><td>v1.13</td><td>-</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/livenessprobe/releases/tag/v2.0.0">livenessprobe v2.0.0</a></td><td><a href="https://github.com/kubernetes-csi/livenessprobe/tree/release-2.0">release-2.0</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>quay.io/k8scsi/livenessprobe:v2.0.0</td><td>v1.13</td><td>-</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/livenessprobe/releases/tag/v1.1.0">livenessprobe v1.1.0</a></td><td><a href="https://github.com/kubernetes-csi/livenessprobe/tree/release-1.1">release-1.1</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>quay.io/k8scsi/livenessprobe:v1.1.0</td><td>v1.13</td><td>-</td></tr>
<tr><td>Unsupported.</td><td>No 0.x branch.</td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a></td><td>quay.io/k8scsi/livenessprobe:v0.4.1</td><td>v1.10</td><td>v1.16</td></tr>
</tbody></table>
<h2><a class="header" href="#description-8" id="description-8">Description</a></h2>
<p>The CSI <code>livenessprobe</code> is a sidecar container that monitors the health of the CSI driver and reports it to Kubernetes via the <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/">Liveness Probe mechanism</a>. This enables Kubernetes to automatically detect issues with the driver and restart the pod to try and fix the issue.</p>
<h2><a class="header" href="#usage-6" id="usage-6">Usage</a></h2>
<p>All CSI drivers should use the liveness probe to improve the availability of the driver while deployed on Kubernetes.</p>
<p>For detailed information (binary parameters, RBAC rules, etc.), see <a href="https://github.com/kubernetes-csi/livenessprobe/blob/master/README.md">https://github.com/kubernetes-csi/livenessprobe/blob/master/README.md</a>.</p>
<h2><a class="header" href="#deployment-8" id="deployment-8">Deployment</a></h2>
<p>The CSI <code>livenessprobe</code> is deployed as part of controller and node deployments. See <a href="deploying.html">deployment section</a> for more details.</p>
<h1><a class="header" href="#csi-node-driver-registrar" id="csi-node-driver-registrar">CSI node-driver-registrar</a></h1>
<h2><a class="header" href="#status-and-releases-8" id="status-and-releases-8">Status and Releases</a></h2>
<p><strong>Git Repository:</strong> <a href="https://github.com/kubernetes-csi/node-driver-registrar">https://github.com/kubernetes-csi/node-driver-registrar</a></p>
<p><strong>Status:</strong> GA/Stable</p>
<h3><a class="header" href="#supported-versions-7" id="supported-versions-7">Supported Versions</a></h3>
<table><thead><tr><th>Latest stable release</th><th>Branch</th><th>Min CSI Version</th><th>Max CSI Version</th><th>Container Image</th><th><a href="kubernetes-compatibility.html#minimum-version">Min K8s Version</a></th><th><a href="kubernetes-compatibility.html#maximum-version">Max K8s Version</a></th><th><a href="kubernetes-compatibility.html#recommended-version">Recommended K8s Version</a></th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/node-driver-registrar/releases/tag/v2.5.0">node-driver-registrar v2.5.0</a></td><td><a href="https://github.com/kubernetes-csi/node-driver-registrar/tree/release-2.5">release-2.5</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.5.0">v1.0.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/csi-node-driver-registrar:v2.5.0</td><td>v1.13</td><td>-</td><td></td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/node-driver-registrar/releases/tag/v2.4.0">node-driver-registrar v2.4.0</a></td><td><a href="https://github.com/kubernetes-csi/node-driver-registrar/tree/release-2.4">release-2.4</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.5.0">v1.0.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/csi-node-driver-registrar:v2.4.0</td><td>v1.13</td><td>-</td><td></td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/node-driver-registrar/releases/tag/v2.3.0">node-driver-registrar v2.3.0</a></td><td><a href="https://github.com/kubernetes-csi/node-driver-registrar/tree/release-2.3">release-2.3</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/csi-node-driver-registrar:v2.3.0</td><td>v1.13</td><td>-</td><td></td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/node-driver-registrar/releases/tag/v2.2.0">node-driver-registrar v2.2.0</a></td><td><a href="https://github.com/kubernetes-csi/node-driver-registrar/tree/release-2.2">release-2.2</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/csi-node-driver-registrar:v2.2.0</td><td>v1.13</td><td>-</td><td></td></tr>
</tbody></table>
<h3><a class="header" href="#unsupported-versions-7" id="unsupported-versions-7">Unsupported Versions</a></h3>
<table><thead><tr><th>Latest stable release</th><th>Branch</th><th>Min CSI Version</th><th>Max CSI Version</th><th>Container Image</th><th><a href="kubernetes-compatibility.html#minimum-version">Min K8s Version</a></th><th><a href="kubernetes-compatibility.html#maximum-version">Max K8s Version</a></th><th><a href="kubernetes-compatibility.html#recommended-version">Recommended K8s Version</a></th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/node-driver-registrar/releases/tag/v2.1.0">node-driver-registrar v2.1.0</a></td><td><a href="https://github.com/kubernetes-csi/node-driver-registrar/tree/release-2.1">release-2.1</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/csi-node-driver-registrar:v2.1.0</td><td>v1.13</td><td>-</td><td></td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/node-driver-registrar/releases/tag/v2.0.0">node-driver-registrar v2.0.0</a></td><td><a href="https://github.com/kubernetes-csi/node-driver-registrar/tree/release-2.0">release-2.0</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/csi-node-driver-registrar:v2.0.0</td><td>v1.13</td><td>-</td><td></td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/node-driver-registrar/releases/tag/v1.2.0">node-driver-registrar v1.2.0</a></td><td><a href="https://github.com/kubernetes-csi/node-driver-registrar/tree/release-1.2">release-1.2</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>-</td><td>quay.io/k8scsi/csi-node-driver-registrar:v1.2.0</td><td>v1.13</td><td>-</td><td></td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/driver-registrar/releases/tag/v0.4.2">driver-registrar v0.4.2</a></td><td><a href="https://github.com/kubernetes-csi/driver-registrar/tree/release-0.4">release-0.4</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a></td><td>quay.io/k8scsi/driver-registrar:v0.4.2</td><td>v1.10</td><td>v1.16</td><td></td></tr>
</tbody></table>
<h2><a class="header" href="#description-9" id="description-9">Description</a></h2>
<p>The CSI <code>node-driver-registrar</code> is a sidecar container that fetches driver information (using <code>NodeGetInfo</code>) from a CSI endpoint and registers it with the kubelet on that node using the <a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/pluginmanager/pluginwatcher/README.md">kubelet plugin registration mechanism</a>.</p>
<h2><a class="header" href="#usage-7" id="usage-7">Usage</a></h2>
<p>Kubelet directly issues CSI <code>NodeGetInfo</code>, <code>NodeStageVolume</code>, and <code>NodePublishVolume</code> calls against CSI drivers. It uses the <a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/pluginmanager/pluginwatcher/README.md">kubelet plugin registration mechanism</a> to discover the unix domain socket to talk to the CSI driver. Therefore, all CSI drivers should use this sidecar container to register themselves with kubelet.</p>
<p>For detailed information (binary parameters, etc.), see the README of the relevant branch.</p>
<h2><a class="header" href="#deployment-9" id="deployment-9">Deployment</a></h2>
<p>The CSI <code>node-driver-registrar</code> is deployed per node. See <a href="deploying.html">deployment section</a> for more details.</p>
<h1><a class="header" href="#csi-cluster-driver-registrar" id="csi-cluster-driver-registrar">CSI cluster-driver-registrar</a></h1>
<h2><a class="header" href="#deprecated" id="deprecated">Deprecated</a></h2>
<p>This sidecar container was not updated since Kubernetes 1.13. As of Kubernetes
1.16, this side car container is officially deprecated.</p>
<p>The purpose of this side car container was to automatically register
a <em>CSIDriver</em> object containing information about the driver with Kubernetes.
Without this side car, developers and CSI driver vendors will now have to add
a CSIDriver object in their installation manifest or any tool that installs
their CSI driver.</p>
<p>Please see <a href="csi-driver-object.html">CSIDriver</a> for more information.</p>
<h2><a class="header" href="#status-and-releases-9" id="status-and-releases-9">Status and Releases</a></h2>
<p><strong>Git Repository:</strong> <a href="https://github.com/kubernetes-csi/cluster-driver-registrar">https://github.com/kubernetes-csi/cluster-driver-registrar</a></p>
<p><strong>Status:</strong> Alpha</p>
<table><thead><tr><th>Latest stable release</th><th>Branch</th><th>Compatible with CSI Version</th><th>Container Image</th><th>Min k8s Version</th><th>Max k8s version</th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/cluster-driver-registrar/releases/tag/v1.0.1">cluster-driver-registrar v1.0.1</a></td><td><a href="https://github.com/kubernetes-csi/cluster-driver-registrar/tree/release-1.0">release-1.0</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a></td><td>quay.io/k8scsi/csi-cluster-driver-registrar:v1.0.1</td><td>v1.13</td><td>-</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/driver-registrar/releases/tag/v0.4.2">driver-registrar v0.4.2</a></td><td><a href="https://github.com/kubernetes-csi/driver-registrar/tree/release-0.4">release-0.4</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a></td><td>quay.io/k8scsi/driver-registrar:v0.4.2</td><td>v1.10</td><td>-</td></tr>
</tbody></table>
<h2><a class="header" href="#description-10" id="description-10">Description</a></h2>
<p>The CSI <code>cluster-driver-registrar</code> is a sidecar container that registers a CSI Driver with a Kubernetes cluster by creating a <a href="csi-driver-object.html">CSIDriver Object</a> which enables the driver to customize how Kubernetes interacts with it.</p>
<h2><a class="header" href="#usage-8" id="usage-8">Usage</a></h2>
<p>CSI drivers that use one of the following Kubernetes features should use this sidecar container:</p>
<ul>
<li><a href="skip-attach.html">Skip Attach</a>
<ul>
<li>For drivers that don't support <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md#controllerpublishvolume"><code>ControllerPublishVolume</code></a>, this indicates to Kubernetes to skip the attach operation and eliminates the need to deploy the <code>external-attacher</code> sidecar.</li>
</ul>
</li>
<li><a href="pod-info.html">Pod Info on Mount</a>
<ul>
<li>This causes Kubernetes to pass metadata such as Pod name and namespace to the <code>NodePublishVolume</code> call.</li>
</ul>
</li>
</ul>
<p>If you are not using one of these features, this sidecar container (and the creation of the <a href="csi-driver-object.html">CSIDriver Object</a>) is not required. However, it is still recommended, because the <a href="csi-driver-object.html">CSIDriver Object</a> makes it easier for users to easily discover the CSI drivers installed on their clusters.</p>
<p>For detailed information (binary parameters, etc.), see the README of the relevant branch.</p>
<h2><a class="header" href="#deployment-10" id="deployment-10">Deployment</a></h2>
<p>The CSI <code>cluster-driver-registrar</code> is deployed as a controller. See <a href="deploying.html">deployment section</a> for more details.</p>
<h1><a class="header" href="#csi-external-health-monitor-controller" id="csi-external-health-monitor-controller">CSI external-health-monitor-controller</a></h1>
<h2><a class="header" href="#status-and-releases-10" id="status-and-releases-10">Status and Releases</a></h2>
<p><strong>Git Repository:</strong> <a href="https://github.com/kubernetes-csi/external-health-monitor">https://github.com/kubernetes-csi/external-health-monitor</a></p>
<p><strong>Status:</strong> Alpha </p>
<h3><a class="header" href="#supported-versions-8" id="supported-versions-8">Supported Versions</a></h3>
<table><thead><tr><th>Latest stable release</th><th>Branch</th><th>Min CSI Version</th><th>Max CSI Version</th><th>Container Image</th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/external-health-monitor/releases/tag/v0.4.0">external-health-monitor-controller v0.4.0</a></td><td><a href="https://github.com/kubernetes-csi/external-health-monitor/tree/release-0.4">release-0.4</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.5.0">v1.4.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/csi-external-health-monitor-controller:v0.4.0</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-health-monitor/releases/tag/v0.3.0">external-health-monitor-controller v0.3.0</a></td><td><a href="https://github.com/kubernetes-csi/external-health-monitor/tree/release-0.3">release-0.3</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.3.0">v1.3.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/csi-external-health-monitor-controller:v0.3.0</td></tr>
</tbody></table>
<h3><a class="header" href="#unsupported-versions-8" id="unsupported-versions-8">Unsupported Versions</a></h3>
<table><thead><tr><th>Latest stable release</th><th>Branch</th><th>Min CSI Version</th><th>Max CSI Version</th><th>Container Image</th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/external-health-monitor/releases/tag/v0.2.0">external-health-monitor-controller v0.2.0</a></td><td><a href="https://github.com/kubernetes-csi/external-health-monitor/tree/release-0.2">release-0.2</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.3.0">v1.3.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/csi-external-health-monitor-controller:v0.2.0</td></tr>
</tbody></table>
<h2><a class="header" href="#description-11" id="description-11">Description</a></h2>
<p>The CSI <code>external-health-monitor-controller</code> is a sidecar container that is deployed together with the CSI controller driver, similar to how the CSI <code>external-provisioner</code> sidecar is deployed. It calls the CSI controller RPC <code>ListVolumes</code> or <code>ControllerGetVolume</code> to check the health condition of the CSI volumes and report events on <code>PersistentVolumeClaim</code> if the condition of a volume is <code>abnormal</code>.</p>
<p>The CSI <code>external-health-monitor-controller</code> also watches for node failure events. This component can be enabled by setting the <code>enable-node-watcher</code> flag to <code>true</code>. This will only have effects on local PVs now. When a node failure event is detected, an event will be reported on the PVC to indicate that pods using this PVC are on a failed node.</p>
<h2><a class="header" href="#usage-9" id="usage-9">Usage</a></h2>
<p>CSI drivers that support <code>VOLUME_CONDITION</code> and <code>LIST_VOLUMES</code> or <code>VOLUME_CONDITION</code> and <code>GET_VOLUME</code> controller capabilities should use this sidecar container.</p>
<p>For detailed information (binary parameters, RBAC rules, etc.), see <a href="https://github.com/kubernetes-csi/external-health-monitor/blob/master/README.md">https://github.com/kubernetes-csi/external-health-monitor/blob/master/README.md</a>.</p>
<h2><a class="header" href="#deployment-11" id="deployment-11">Deployment</a></h2>
<p>The CSI <code>external-health-monitor-controller</code> is deployed as a controller. See <a href="https://github.com/kubernetes-csi/external-health-monitor/blob/master/README.md">https://github.com/kubernetes-csi/external-health-monitor/blob/master/README.md</a> for more details.</p>
<h1><a class="header" href="#csi-external-health-monitor-agent" id="csi-external-health-monitor-agent">CSI external-health-monitor-agent</a></h1>
<h2><a class="header" href="#status-and-releases-11" id="status-and-releases-11">Status and Releases</a></h2>
<p><strong>Git Repository:</strong> <a href="https://github.com/kubernetes-csi/external-health-monitor">https://github.com/kubernetes-csi/external-health-monitor</a></p>
<p><strong>Status:</strong> Deprecated</p>
<h3><a class="header" href="#unsupported-versions-9" id="unsupported-versions-9">Unsupported Versions</a></h3>
<table><thead><tr><th>Latest stable release</th><th>Branch</th><th>Min CSI Version</th><th>Max CSI Version</th><th>Container Image</th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/external-health-monitor/releases/tag/v0.2.0">external-health-monitor-agent v0.2.0</a></td><td><a href="https://github.com/kubernetes-csi/external-health-monitor/tree/release-0.2">release-0.2</a></td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v1.3.0">v1.3.0</a></td><td>-</td><td>k8s.gcr.io/sig-storage/csi-external-health-monitor-agent:v0.2.0</td></tr>
</tbody></table>
<h2><a class="header" href="#description-12" id="description-12">Description</a></h2>
<p><em>Note</em>: This sidecar has been deprecated and replaced with the CSIVolumeHealth feature
in Kubernetes.</p>
<p>The CSI <code>external-health-monitor-agent</code> is a sidecar container that is deployed together with the CSI node driver, similar to how the CSI <code>node-driver-registrar</code> sidecar is deployed. It calls the CSI node RPC <code>NodeGetVolumeStats</code> to check the health condition of the CSI volumes and report events on <code>Pod</code> if the condition of a volume is <code>abnormal</code>.</p>
<h2><a class="header" href="#usage-10" id="usage-10">Usage</a></h2>
<p>CSI drivers that support <code>VOLUME_CONDITION</code> and <code>NODE_GET_VOLUME_STATS</code> node capabilities should use this sidecar container.</p>
<p>For detailed information (binary parameters, RBAC rules, etc.), see <a href="https://github.com/kubernetes-csi/external-health-monitor/blob/master/README.md">https://github.com/kubernetes-csi/external-health-monitor/blob/master/README.md</a>.</p>
<h2><a class="header" href="#deployment-12" id="deployment-12">Deployment</a></h2>
<p>The CSI <code>external-health-monitor-agent</code> is deployed as a DaemonSet. See <a href="https://github.com/kubernetes-csi/external-health-monitor/blob/master/README.md">https://github.com/kubernetes-csi/external-health-monitor/blob/master/README.md</a> for more details.</p>
<h1><a class="header" href="#csi-objects" id="csi-objects">CSI objects</a></h1>
<p>The Kubernetes API contains the following CSI specific objects:</p>
<ul>
<li><a href="csi-driver-object.html">CSIDriver Object</a></li>
<li><a href="csi-node-object.html">CSINode Object</a></li>
</ul>
<p>The schema definition for the objects can be found in the <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#-strong-config-and-storage-apis-strong-">Kubernetes API reference</a></p>
<h1><a class="header" href="#csidriver-object" id="csidriver-object">CSIDriver Object</a></h1>
<h2><a class="header" href="#status" id="status">Status</a></h2>
<ul>
<li>Kubernetes 1.12 - 1.13: Alpha</li>
<li>Kubernetes 1.14: Beta</li>
<li>Kubernetes 1.18: GA</li>
</ul>
<h2><a class="header" href="#what-is-the-csidriver-object" id="what-is-the-csidriver-object">What is the CSIDriver object?</a></h2>
<p>The <code>CSIDriver</code> Kubernetes API object serves two purposes:</p>
<ol>
<li>Simplify driver discovery</li>
</ol>
<ul>
<li>If a CSI driver creates a <code>CSIDriver</code> object, Kubernetes users can easily discover the CSI Drivers installed on their cluster (simply by issuing <code>kubectl get CSIDriver</code>)</li>
</ul>
<ol start="2">
<li>Customizing Kubernetes behavior</li>
</ol>
<ul>
<li>Kubernetes has a default set of behaviors when dealing with CSI Drivers (for example, it calls the <code>Attach</code>/<code>Detach</code> operations by default). This object allows CSI drivers to specify how Kubernetes should interact with it.</li>
</ul>
<h2><a class="header" href="#what-fields-does-the-csidriver-object-have" id="what-fields-does-the-csidriver-object-have">What fields does the <code>CSIDriver</code> object have?</a></h2>
<p>Here is an example of a v1 <code>CSIDriver</code> object:</p>
<pre><code class="language-yaml">apiVersion: storage.k8s.io/v1
kind: CSIDriver
metadata:
  name: mycsidriver.example.com
spec:
  attachRequired: true
  podInfoOnMount: true
  fsGroupPolicy: File # added in Kubernetes 1.19, this field is GA as of Kubernetes 1.23
  volumeLifecycleModes: # added in Kubernetes 1.16, this field is beta
    - Persistent
    - Ephemeral
  tokenRequests: # added in Kubernetes 1.20. See status at https://kubernetes-csi.github.io/docs/token-requests.html#status
    - audience: &quot;gcp&quot;
    - audience: &quot;&quot; # empty string means defaulting to the `--api-audiences` of kube-apiserver
      expirationSeconds: 3600
  requiresRepublish: true # added in Kubernetes 1.20. See status at https://kubernetes-csi.github.io/docs/token-requests.html#status
  seLinuxMount: true # Added in Kubernetest 1.25.
</code></pre>
<p>These are the important fields:</p>
<ul>
<li><code>name</code>
<ul>
<li>This should correspond to the full name of the CSI driver.</li>
</ul>
</li>
<li><code>attachRequired</code>
<ul>
<li>Indicates this CSI volume driver requires an attach operation (because it implements the CSI <code>ControllerPublishVolume</code> method), and that Kubernetes should call attach and wait for any attach operation to complete before proceeding to mounting.</li>
<li>If a <code>CSIDriver</code> object does not exist for a given CSI Driver, the default is <code>true</code> -- meaning attach will be called.</li>
<li>If a <code>CSIDriver</code> object exists for a given CSI Driver, but this field is not specified, it also defaults to <code>true</code> -- meaning attach will be called.</li>
<li>For more information see <a href="skip-attach.html">Skip Attach</a>.</li>
</ul>
</li>
<li><code>podInfoOnMount</code>
<ul>
<li>Indicates this CSI volume driver requires additional pod information (like pod name, pod UID, etc.) during mount operations.</li>
<li>If value is not specified or <code>false</code>, pod information will not be passed on mount.</li>
<li>If value is set to <code>true</code>, Kubelet will pass pod information as <code>volume_context</code> in CSI <code>NodePublishVolume</code> calls:
<ul>
<li><code>&quot;csi.storage.k8s.io/pod.name&quot;: pod.Name</code></li>
<li><code>&quot;csi.storage.k8s.io/pod.namespace&quot;: pod.Namespace</code></li>
<li><code>&quot;csi.storage.k8s.io/pod.uid&quot;: string(pod.UID)</code></li>
<li><code>&quot;csi.storage.k8s.io/serviceAccount.name&quot;: pod.Spec.ServiceAccountName</code></li>
</ul>
</li>
<li>For more information see <a href="pod-info.html">Pod Info on Mount</a>.</li>
</ul>
</li>
<li><code>fsGroupPolicy</code>
<ul>
<li>This field was added in Kubernetes 1.19 and cannot be set when using an older Kubernetes release.</li>
<li>This field is beta in Kubernetes 1.20 and GA in Kubernetes 1.23.</li>
<li>Controls if this CSI volume driver supports volume ownership and permission changes when volumes are mounted.</li>
<li>The following modes are supported, and if not specified the default is <code>ReadWriteOnceWithFSType</code>:
<ul>
<li><code>None</code>: Indicates that volumes will be mounted with no modifications, as the CSI volume driver does not support these operations.</li>
<li><code>File</code>: Indicates that the CSI volume driver supports volume ownership and permission change via fsGroup, and Kubernetes may use fsGroup to change permissions and ownership of the volume to match user requested fsGroup in the pod's SecurityPolicy regardless of fstype or access mode.</li>
<li><code>ReadWriteOnceWithFSType</code>: Indicates that volumes will be examined to determine if volume ownership and permissions should be modified to match the pod's security policy.
Changes will only occur if the <code>fsType</code> is defined and the persistent volume's <code>accessModes</code> contains <code>ReadWriteOnce</code>.
This is the default behavior if no other FSGroupPolicy is defined.</li>
</ul>
</li>
<li>For more information see <a href="support-fsgroup.html">CSI Driver fsGroup Support</a>.</li>
</ul>
</li>
<li><code>volumeLifecycleModes</code>
<ul>
<li>This field was added in Kubernetes 1.16 and cannot be set when using an older Kubernetes release.</li>
<li>This field is beta.</li>
<li>It informs Kubernetes about the volume modes that are supported by the driver.
This ensures that the driver <a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-storage/596-csi-inline-volumes/README.md#support-for-inline-csi-volumes">is not used incorrectly</a> by users.
The default is <code>Persistent</code>, which is the normal PVC/PV mechanism. <code>Ephemeral</code> enables
<a href="ephemeral-local-volumes.html">inline ephemeral volumes</a> in addition (when both
are listed) or instead of normal volumes (when it is the only entry in the list).</li>
</ul>
</li>
<li><code>tokenRequests</code>
<ul>
<li>This field was added in Kubernetes 1.20 and cannot be set when using an older Kubernetes release.</li>
<li>This field is enabled by default in Kubernetes 1.21 and cannot be disabled since 1.22.</li>
<li>If this field is specified, Kubelet will plumb down the bound service account tokens of the pod as <code>volume_context</code> in the <code>NodePublishVolume</code>:
<ul>
<li><code>&quot;csi.storage.k8s.io/serviceAccount.tokens&quot;: {&quot;gcp&quot;:{&quot;token&quot;:&quot;&lt;token&gt;&quot;,&quot;expirationTimestamp&quot;:&quot;&lt;expiration timestamp in RFC3339&gt;&quot;}}</code></li>
<li>If CSI driver doesn't find token recorded in the <code>volume_context</code>, it should return error in <code>NodePublishVolume</code> to inform Kubelet to retry.</li>
<li>Audiences should be distinct, otherwise the validation will fail. If the audience is &quot;&quot;, it means the issued token has the same audience as kube-apiserver.</li>
</ul>
</li>
</ul>
</li>
<li><code>requiresRepublish</code>
<ul>
<li>This field was added in Kubernetes 1.20 and cannot be set when using an older Kubernetes release.</li>
<li>This field is enabled by default in Kubernetes 1.21 and cannot be disabled since 1.22.</li>
<li>If this field is <code>true</code>, Kubelet will periodically call <code>NodePublishVolume</code>. This is useful in the following scenarios:
<ul>
<li>If the volume mounted by CSI driver is short-lived.</li>
<li>If CSI driver requires valid service account tokens (enabled by the field <code>tokenRequests</code>) repeatedly.</li>
</ul>
</li>
<li>CSI drivers should only atomically update the contents of the volume. Mount point change will not be seen by a running container.</li>
</ul>
</li>
<li><code>seLinuxMount</code>
<ul>
<li>This field is alpha in Kubernetes 1.25. It must be explicitly enabled by setting feature gates <code>ReadWriteOncePod</code> and <code>SELinuxMountReadWriteOncePod</code>.</li>
<li>The default value of this field is <code>false</code>.</li>
<li>When set to <code>true</code>, corresponding CSI driver announces that all its volumes are <em>independent volumes</em> from Linux kernel point of view and each of them can be mounted with a different SELinux label mount option (<code>-o context=&lt;SELinux label&gt;</code>). 
Examples:
<ul>
<li>A CSI driver that creates block devices formatted with a filesystem, such as <code>xfs</code> or <code>ext4</code>, can set <code>seLinuxMount: true</code>, because each volume has its own block device.</li>
<li>A CSI driver whose volumes are <strong>always</strong> separate exports on a NFS server can set <code>seLinuxMount: true</code>, because each volume has its own NFS export and thus Linux kernel treats them as independent volumes.</li>
<li>A CSI driver that <strong>can</strong> provide two volumes as subdirectories of a common NFS export must set <code>seLinuxMount: false</code>, because these two volumes are treated as a single volume by Linux kernel and must share the same <code>-o context=&lt;SELinux label&gt;</code> option.</li>
</ul>
</li>
<li><a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-storage/1710-selinux-relabeling/README.md#selinux-intro">See corresponding KEP</a> for details.</li>
<li>Always test Pods with various SELinux contexts with various volume configurations before setting this field to <code>true</code>!</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#what-creates-the-csidriver-object" id="what-creates-the-csidriver-object">What creates the CSIDriver object?</a></h2>
<p>To install, a CSI driver's deployment manifest must contain a <code>CSIDriver</code>
object as shown in the example above.</p>
<blockquote>
<p>NOTE: The cluster-driver-registrar side-car which was used to create CSIDriver
objects in Kubernetes 1.13 has been deprecated for Kubernetes 1.16. No
cluster-driver-registrar has been released for Kubernetes 1.14 and later.</p>
</blockquote>
<p><code>CSIDriver</code> instance should exist for whole lifetime of all pods that use
volumes provided by corresponding CSI driver, so <a href="skip-attach.html">Skip Attach</a>
and <a href="pod-info.html">Pod Info on Mount</a> features work correctly.</p>
<h3><a class="header" href="#listing-registered-csi-drivers" id="listing-registered-csi-drivers">Listing registered CSI drivers</a></h3>
<p>Using the <code>CSIDriver</code> object, it is now possible to query Kubernetes to get a list of registered drivers running in the cluster as shown below:</p>
<pre><code>$&gt; kubectl get csidrivers.storage.k8s.io
NAME                      ATTACHREQUIRED   PODINFOONMOUNT   MODES                  AGE
mycsidriver.example.com   true             true             Persistent,Ephemeral   2m46s
</code></pre>
<p>Or get a more detailed view of your registered driver with:</p>
<pre><code>$&gt; kubectl describe csidrivers.storage.k8s.io
Name:         mycsidriver.example.com
Namespace:    
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;
API Version:  storage.k8s.io/v1
Kind:         CSIDriver
Metadata:
  Creation Timestamp:  2022-04-07T05:58:06Z
  Managed Fields:
    API Version:  storage.k8s.io/v1
    Fields Type:  FieldsV1
    fieldsV1:
      f:metadata:
        f:annotations:
          .:
          f:kubectl.kubernetes.io/last-applied-configuration:
      f:spec:
        f:attachRequired:
        f:fsGroupPolicy:
        f:podInfoOnMount:
        f:requiresRepublish:
        f:tokenRequests:
        f:volumeLifecycleModes:
          .:
          v:&quot;Ephemeral&quot;:
          v:&quot;Persistent&quot;:
    Manager:         kubectl-client-side-apply
    Operation:       Update
    Time:            2022-04-07T05:58:06Z
  Resource Version:  896
  UID:               6cc7d513-6d72-4203-87d3-730f83884f89
Spec:
  Attach Required:    true
  Fs Group Policy:    File
  Pod Info On Mount:  true
  Volume Lifecycle Modes:
    Persistent
    Ephemeral
Events:  &lt;none&gt;
</code></pre>
<h2><a class="header" href="#changes-from-alpha-to-beta" id="changes-from-alpha-to-beta">Changes from Alpha to Beta</a></h2>
<h3><a class="header" href="#crd-to-built-in-type" id="crd-to-built-in-type">CRD to Built in Type</a></h3>
<p>During alpha development, the <code>CSIDriver</code> object was also defined as a <a href="https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/#create-a-customresourcedefinition">Custom Resource Definition</a> (CRD). As part of the promotion to beta the object has been moved to the built-in Kubernetes API.</p>
<p>In the move from alpha to beta, the API Group for this object changed from <code>csi.storage.k8s.io/v1alpha1</code> to <code>storage.k8s.io/v1beta1</code>.</p>
<p>There is no automatic update of existing CRDs and their CRs during Kubernetes update to the new build-in type.</p>
<h3><a class="header" href="#enabling-csidriver-on-kubernetes" id="enabling-csidriver-on-kubernetes">Enabling CSIDriver on Kubernetes</a></h3>
<p>In Kubernetes v1.12 and v1.13, because the feature was alpha, it was disabled by default. To enable the use of <code>CSIDriver</code> on these versions, do the following:</p>
<ol>
<li>Ensure the feature gate is enabled via the following Kubernetes feature flag: <code>--feature-gates=CSIDriverRegistry=true</code></li>
<li>Either ensure the <code>CSIDriver</code> CRD is automatically installed via the <a href="https://github.com/kubernetes/kubernetes/tree/release-1.13/cluster/addons/storage-crds">Kubernetes Storage CRD addon</a> OR manually install the <code>CSIDriver</code> CRD on the Kubernetes cluster with the following command:</li>
</ol>
<pre><code>$&gt; kubectl create -f https://raw.githubusercontent.com/kubernetes/csi-api/master/pkg/crd/manifests/csidriver.yaml
</code></pre>
<p>Kubernetes v1.14+, uses the same Kubernetes feature flag, but because the feature is beta, it is enabled by default. And since the API type (as of beta) is built in to the Kubernetes API, installation of the CRD is no longer required.</p>
<h1><a class="header" href="#csinode-object" id="csinode-object">CSINode Object</a></h1>
<h2><a class="header" href="#status-1" id="status-1">Status</a></h2>
<table><thead><tr><th>Status</th><th>Min K8s Version</th><th>Max K8s Version</th></tr></thead><tbody>
<tr><td>Alpha</td><td>1.12</td><td>1.13</td></tr>
<tr><td>Beta</td><td>1.14</td><td>1.16</td></tr>
<tr><td>GA</td><td>1.17</td><td>-</td></tr>
</tbody></table>
<h2><a class="header" href="#what-is-the-csinode-object" id="what-is-the-csinode-object">What is the CSINode object?</a></h2>
<p>CSI drivers generate node specific information. Instead of storing this in the Kubernetes <code>Node</code> API Object, a new CSI specific Kubernetes <code>CSINode</code> object was created.</p>
<p>It serves the following purposes:</p>
<ol>
<li>Mapping Kubernetes node name to CSI Node name,</li>
</ol>
<ul>
<li>The CSI <code>GetNodeInfo</code> call returns the name by which the storage system refers to a node. Kubernetes must use this name in future <code>ControllerPublishVolume</code> calls. Therefore, when a new CSI driver is registered, Kubernetes stores the storage system node ID in the <code>CSINode</code> object for future reference.</li>
</ul>
<ol start="2">
<li>Driver availability</li>
</ol>
<ul>
<li>A way for kubelet to communicate to the kube-controller-manager and kubernetes scheduler whether the driver is available (registered) on the node or not.</li>
</ul>
<ol start="3">
<li>Volume topology</li>
</ol>
<ul>
<li>The CSI <code>GetNodeInfo</code> call returns a set of keys/values labels identifying the topology of that node. Kubernetes uses this information to do topology-aware provisioning (see <a href="https://kubernetes.io/docs/concepts/storage/storage-classes/#volume-binding-mode">PVC Volume Binding Modes</a> for more details). It stores the key/values as labels on the Kubernetes node object. In order to recall which <code>Node</code> label keys belong to a specific CSI driver, the kubelet stores the keys in the <code>CSINode</code> object for future reference.</li>
</ul>
<h2><a class="header" href="#what-fields-does-the-csinode-object-have" id="what-fields-does-the-csinode-object-have">What fields does the CSINode object have?</a></h2>
<p>Here is an example of a v1 <code>CSINode</code> object:</p>
<pre><code class="language-YAML">apiVersion: storage.k8s.io/v1
kind: CSINode
metadata:
  name: node1
spec:
  drivers:
  - name: mycsidriver.example.com
    nodeID: storageNodeID1
    topologyKeys: ['mycsidriver.example.com/regions', &quot;mycsidriver.example.com/zones&quot;]
</code></pre>
<p>What the fields mean:</p>
<ul>
<li><code>drivers</code> - list of CSI drivers running on the node and their properties.</li>
<li><code>name</code> - the CSI driver that this object refers to.</li>
<li><code>nodeID</code> - the assigned identifier for the node as determined by the driver.</li>
<li><code>topologyKeys</code> - A list of topology keys assigned to the node as supported by the driver.</li>
</ul>
<h2><a class="header" href="#what-creates-the-csinode-object" id="what-creates-the-csinode-object">What creates the CSINode object?</a></h2>
<p>CSI drivers do not need to create the <code>CSINode</code> object directly. Kubelet manages the object when a CSI driver registers through the kubelet plugin registration mechanism. The <a href="node-driver-registrar.html">node-driver-registrar</a> sidecar container helps with this registration.</p>
<h2><a class="header" href="#changes-from-alpha-to-beta-1" id="changes-from-alpha-to-beta-1">Changes from Alpha to Beta</a></h2>
<h3><a class="header" href="#crd-to-built-in-type-1" id="crd-to-built-in-type-1">CRD to Built in Type</a></h3>
<p>The alpha object was called <code>CSINodeInfo</code>, whereas the beta object is called
<code>CSINode</code>. The alpha <code>CSINodeInfo</code> object was also defined as a <a href="https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/#create-a-customresourcedefinition">Custom Resource Definition</a> (CRD). As part of the promotion to beta the object has been moved to the built-in Kubernetes API.</p>
<p>In the move from alpha to beta, the API Group for this object changed from <code>csi.storage.k8s.io/v1alpha1</code> to <code>storage.k8s.io/v1beta1</code>.</p>
<p>There is no automatic update of existing CRDs and their CRs during Kubernetes update to the new build-in type.</p>
<h3><a class="header" href="#enabling-csinodeinfo-on-kubernetes" id="enabling-csinodeinfo-on-kubernetes">Enabling CSINodeInfo on Kubernetes</a></h3>
<p>In Kubernetes v1.12 and v1.13, because the feature was alpha, it was disabled by default. To enable the use of <code>CSINodeInfo</code> on these versions, do the following:</p>
<ol>
<li>Ensure the feature gate is enabled with <code>--feature-gates=CSINodeInfo=true</code></li>
<li>Either ensure the <code>CSIDriver</code> CRD is automatically installed via the <a href="https://github.com/kubernetes/kubernetes/tree/release-1.13/cluster/addons/storage-crds">Kubernetes Storage CRD addon</a> OR manually install the <code>CSINodeInfo</code> CRD on the Kubernetes cluster with the following command:</li>
</ol>
<pre><code>$&gt; kubectl create -f https://raw.githubusercontent.com/kubernetes/csi-api/master/pkg/crd/manifests/csinodeinfo.yaml
</code></pre>
<p>Kubernetes v1.14+, uses the same Kubernetes feature flag, but because the feature is beta, it is enabled by default. And since the API type (as of beta) is built in to the Kubernetes API, installation of the CRD is no longer required.</p>
<h1><a class="header" href="#features-15" id="features-15">Features</a></h1>
<p>The Kubernetes implementation of CSI has multiple sub-features. This section describes these sub-features, their status (although support for CSI in Kubernetes is GA/stable, support of sub-features moves independently so sub-features maybe alpha or beta), and how to integrate them in to your CSI Driver.</p>
<h1><a class="header" href="#secrets-and-credentials" id="secrets-and-credentials">Secrets and Credentials</a></h1>
<p>Some drivers may require a secret in order to complete operations.</p>
<h2><a class="header" href="#csi-driver-secrets" id="csi-driver-secrets">CSI Driver Secrets</a></h2>
<p>If a CSI Driver requires secrets for a backend (a service account, for example), and this secret is required at the &quot;per driver&quot; granularity (not different &quot;per CSI operation&quot; or &quot;per volume&quot;), then the secret SHOULD be injected directly in to CSI driver pods via <a href="https://kubernetes.io/docs/tasks/inject-data-application/distribute-credentials-secure/">standard Kubernetes secret distribution mechanisms</a> during deployment.</p>
<h2><a class="header" href="#csi-operation-secrets" id="csi-operation-secrets">CSI Operation Secrets</a></h2>
<p>If a CSI Driver requires secrets &quot;per CSI operation&quot; or &quot;per volume&quot; or &quot;per storage pool&quot;, the CSI spec allows secrets to be passed in for various CSI operations (including <code>CreateVolumeRequest</code>, <code>ControllerPublishVolumeRequest</code>, and more).</p>
<p>Cluster admins can populate such secrets by creating Kubernetes <code>Secret</code> objects and specifying the keys in the <code>StorageClass</code> or <code>SnapshotClass</code> objects.</p>
<p>The CSI sidecar containers facilitate the handling of secrets between Kubernetes and the CSI Driver. For more details see:</p>
<ul>
<li><a href="secrets-and-credentials-storage-class.html">StorageClass Secrets</a></li>
<li><a href="secrets-and-credentials-volume-snapshot-class.html">VolumeSnapshotClass Secrets</a></li>
</ul>
<h3><a class="header" href="#secret-rbac-rules" id="secret-rbac-rules">Secret RBAC Rules</a></h3>
<p>For reducing RBAC permissions as much as possible, secret rules are disabled in each sidecar repository by default.</p>
<p>Please add or update RBAC rules if secret is expected to use.</p>
<p>To set proper secret permission, uncomment related lines defined in <code>rbac.yaml</code> (e.g. <a href="https://github.com/kubernetes-csi/external-provisioner/blob/22bb6401d2484ee3ca18a23d75c3864c774e5f32/deploy/kubernetes/rbac.yaml#L24">external-provisioner/deploy/kubernetes/rbac.yaml</a>)</p>
<h2><a class="header" href="#handling-sensitive-information" id="handling-sensitive-information">Handling Sensitive Information</a></h2>
<p>CSI Drivers that accept secrets SHOULD handle this data carefully. It may contain sensitive information and MUST be treated as such (e.g. not logged).</p>
<p>To make it easier to handle secret fields (e.g. strip them from CSI protos when logging), the CSI spec defines a decorator (<code>csi_secret</code>) on all fields containing sensitive information. Any fields decorated with <code>csi_secret</code> MUST be treated as if they contain sensitive information (e.g. not logged, etc.).</p>
<p>The Kubernetes CSI development team also provides a GO lang package called <code>protosanitizer</code> that CSI driver developers may be used to remove values for all fields in a gRPC messages decorated with <code>csi_secret</code>. The library can be found in <a href="https://github.com/kubernetes-csi/csi-lib-utils/tree/master/protosanitizer">kubernetes-csi/csi-lib-utils/protosanitizer</a>. The Kubernetes CSI <a href="sidecar-containers.html">Sidecar Containers</a> and sample drivers use this library to ensure no sensitive information is logged.</p>
<h1><a class="header" href="#storageclass-secrets" id="storageclass-secrets">StorageClass Secrets</a></h1>
<p>The CSI <a href="external-provisioner.html">external-provisioner</a> sidecar container facilitates the handling of secrets for the following operations:</p>
<ul>
<li><code>CreateVolumeRequest</code></li>
<li><code>DeleteVolumeRequest</code></li>
<li><code>ControllerPublishVolumeRequest</code></li>
<li><code>ControllerUnpublishVolumeRequest</code></li>
<li><code>ControllerExpandVolumeRequest</code></li>
<li><code>NodeStageVolumeRequest</code></li>
<li><code>NodePublishVolumeRequest</code></li>
</ul>
<p>CSI <code>external-provisioner</code> v1.0.1+ supports the following keys in <code>StorageClass.parameters</code>:</p>
<ul>
<li><code>csi.storage.k8s.io/provisioner-secret-name</code></li>
<li><code>csi.storage.k8s.io/provisioner-secret-namespace</code></li>
<li><code>csi.storage.k8s.io/controller-publish-secret-name</code></li>
<li><code>csi.storage.k8s.io/controller-publish-secret-namespace</code></li>
<li><code>csi.storage.k8s.io/node-stage-secret-name</code></li>
<li><code>csi.storage.k8s.io/node-stage-secret-namespace</code></li>
<li><code>csi.storage.k8s.io/node-publish-secret-name</code></li>
<li><code>csi.storage.k8s.io/node-publish-secret-namespace</code></li>
</ul>
<p>CSI <code>external-provisioner</code> v1.2.0+ adds support for the following keys in <code>StorageClass.parameters</code>:</p>
<ul>
<li><code>csi.storage.k8s.io/controller-expand-secret-name</code></li>
<li><code>csi.storage.k8s.io/controller-expand-secret-namespace</code></li>
</ul>
<p>Cluster admins can populate the secret fields for the operations listed above with data from Kubernetes <code>Secret</code> objects by specifying these keys in the <code>StorageClass</code> object.</p>
<h2><a class="header" href="#examples" id="examples">Examples</a></h2>
<h3><a class="header" href="#basic-provisioning-secret" id="basic-provisioning-secret">Basic Provisioning Secret</a></h3>
<p>In this example, the external-provisioner will fetch Kubernetes <code>Secret</code> object <code>fast-storage-provision-key</code> in the namespace <code>pd-ssd-credentials</code> and pass the credentials to the CSI driver named <code>csi-driver.team.example.com</code> in the <code>CreateVolume</code> CSI call.</p>
<pre><code class="language-yaml">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: fast-storage
provisioner: csi-driver.team.example.com
parameters:
  type: pd-ssd
  csi.storage.k8s.io/provisioner-secret-name: fast-storage-provision-key
  csi.storage.k8s.io/provisioner-secret-namespace: pd-ssd-credentials
</code></pre>
<p>All volumes provisioned using this <code>StorageClass</code> use the same secret.</p>
<h3><a class="header" href="#per-volume-secrets" id="per-volume-secrets">Per Volume Secrets</a></h3>
<p>In this example, the external-provisioner will generate the name of the Kubernetes <code>Secret</code> object and namespace for the <code>NodePublishVolume</code> CSI call, based on the PVC namespace and annotations, at volume provision time.</p>
<pre><code class="language-yaml">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: fast-storage
provisioner: csi-driver.team.example.com
parameters:
  type: pd-ssd
  csi.storage.k8s.io/node-publish-secret-name: ${pvc.annotations['team.example.com/key']}
  csi.storage.k8s.io/node-publish-secret-namespace: ${pvc.namespace}
</code></pre>
<p>This StorageClass will result in the creation of a <code>PersistentVolume</code> API object referencing a &quot;node publish secret&quot; in the same namespace as the <code>PersistentVolumeClaim</code> that triggered the provisioning and with a name specified as an annotation on the <code>PersistentVolumeClaim</code>. This could be used to give the creator of the <code>PersistentVolumeClaim</code> the ability to specify a secret containing a decryption key they have control over.</p>
<h3><a class="header" href="#multiple-operation-secrets" id="multiple-operation-secrets">Multiple Operation Secrets</a></h3>
<p>A drivers may support secret keys for multiple operations. In this case, you can provide secrets references for each operation:</p>
<pre><code class="language-yaml">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: fast-storage-all
provisioner: csi-driver.team.example.com
parameters:
  type: pd-ssd
  csi.storage.k8s.io/provisioner-secret-name: ${pvc.name}
  csi.storage.k8s.io/provisioner-secret-namespace: ${pvc.namespace}-fast-storage
  csi.storage.k8s.io/node-publish-secret-name: ${pvc.name}-${pvc.annotations['team.example.com/key']}
  csi.storage.k8s.io/node-publish-secret-namespace: ${pvc.namespace}-fast-storage
  
</code></pre>
<h2><a class="header" href="#operations" id="operations">Operations</a></h2>
<p>Details for each secret supported by the external-provisioner can be found below.</p>
<h3><a class="header" href="#createdelete-volume-secret" id="createdelete-volume-secret">Create/Delete Volume Secret</a></h3>
<p>The CSI <code>external-provisioner</code> (v1.0.1+) looks for the following keys in <code>StorageClass.parameters</code>.</p>
<ul>
<li><code>csi.storage.k8s.io/provisioner-secret-name</code></li>
<li><code>csi.storage.k8s.io/provisioner-secret-namespace</code></li>
</ul>
<p>The values of both of these parameters, together, refer to the name and namespace of a <code>Secret</code> object in the Kubernetes API.</p>
<p>If specified, the CSI <code>external-provisioner</code> will attempt to fetch the secret before provisioning and deletion.</p>
<p>If the secret is retrieved successfully, the provisioner passes it to the CSI driver in the <code>CreateVolumeRequest.secrets</code> or <code>DeleteVolumeRequest.secrets</code> field.</p>
<p>If no such secret exists in the Kubernetes API, or the provisioner is unable to fetch it, the provision operation will fail.</p>
<p>Note, however, that the delete operation will continue even if the secret is not found (because, for example, the entire namespace containing the secret was deleted). In this case, if the driver requires a secret for deletion, then the volume and PV may need to be manually cleaned up.</p>
<p>The values of these parameters may be &quot;templates&quot;. The <code>external-provisioner</code> will automatically resolve templates at volume provision time, as detailed below:</p>
<ul>
<li><code>csi.storage.k8s.io/provisioner-secret-name</code>
<ul>
<li><code>${pv.name}</code>
<ul>
<li>Replaced with name of the <code>PersistentVolume</code> object being provisioned.</li>
</ul>
</li>
<li><code>${pvc.namespace}</code>
<ul>
<li>Replaced with namespace of the <code>PersistentVolumeClaim</code> object that triggered provisioning.</li>
<li>Support added in CSI <code>external-provisioner</code> v1.2.0+</li>
</ul>
</li>
<li><code>${pvc.name}</code>
<ul>
<li>Replaced with the name of the <code>PersistentVolumeClaim</code> object that triggered provisioning.</li>
<li>Support added in CSI <code>external-provisioner</code> v1.2.0+</li>
</ul>
</li>
</ul>
</li>
<li><code>csi.storage.k8s.io/provisioner-secret-namespace</code>
<ul>
<li><code>${pv.name}</code>
<ul>
<li>Replaced with name of the <code>PersistentVolume</code> object being provisioned.</li>
</ul>
</li>
<li><code>${pvc.namespace}</code>
<ul>
<li>Replaced with namespace of the <code>PersistentVolumeClaim</code> object that triggered provisioning.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#controller-publishunpublish-secret" id="controller-publishunpublish-secret">Controller Publish/Unpublish Secret</a></h3>
<p>The CSI <code>external-provisioner</code> (v1.0.1+) looks for the following keys in <code>StorageClass.parameters</code>:</p>
<ul>
<li><code>csi.storage.k8s.io/controller-publish-secret-name</code></li>
<li><code>csi.storage.k8s.io/controller-publish-secret-namespace</code></li>
</ul>
<p>The values of both of these parameters, together, refer to the name and namespace of a <code>Secret</code> object in the Kubernetes API.</p>
<p>If specified, the CSI <code>external-provisioner</code> sets the <code>CSIPersistentVolumeSource.ControllerPublishSecretRef</code> field in the new <code>PersistentVolume</code> object to refer to this secret once provisioning is successful.</p>
<p>The CSI <code>external-attacher</code> then attempts to fetch the secret referenced by the <code>CSIPersistentVolumeSource.ControllerPublishSecretRef</code>, if specified, before an attach or detach operation.</p>
<p>If no such secret exists in the Kubernetes API, or the <code>external-attacher</code> is unable to fetch it, the attach or detach operation fails.</p>
<p>If the secret is retrieved successfully, the <code>external-attacher</code> passes it to the CSI driver in the <code>ControllerPublishVolumeRequest.secrets</code> or <code>ControllerUnpublishVolumeRequest.secrets</code> field.</p>
<p>The values of these parameters may be &quot;templates&quot;. The <code>external-provisioner</code> will automatically resolve templates at volume provision time, as detailed below:</p>
<ul>
<li><code>csi.storage.k8s.io/controller-publish-secret-name</code>
<ul>
<li><code>${pv.name}</code>
<ul>
<li>Replaced with name of the <code>PersistentVolume</code> object being provisioned.</li>
</ul>
</li>
<li><code>${pvc.namespace}</code>
<ul>
<li>Replaced with namespace of the <code>PersistentVolumeClaim</code> object that triggered provisioning.</li>
</ul>
</li>
<li><code>${pvc.name}</code>
<ul>
<li>Replaced with the name of the <code>PersistentVolumeClaim</code> object that triggered provisioning.</li>
</ul>
</li>
<li><code>${pvc.annotations['&lt;ANNOTATION_KEY&gt;']}</code> (e.g. <code>${pvc.annotations['example.com/key']}</code>)
<ul>
<li>Replaced with the value of the specified annotation from the <code>PersistentVolumeClaim</code> object that triggered provisioning</li>
</ul>
</li>
</ul>
</li>
<li><code>csi.storage.k8s.io/controller-publish-secret-namespace</code>
<ul>
<li><code>${pv.name}</code>
<ul>
<li>Replaced with name of the <code>PersistentVolume</code> object being provisioned.</li>
</ul>
</li>
<li><code>${pvc.namespace}</code>
<ul>
<li>Replaced with namespace of the <code>PersistentVolumeClaim</code> object that triggered provisioning.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#node-stage-secret" id="node-stage-secret">Node Stage Secret</a></h3>
<p>The CSI <code>external-provisioner</code> (v1.0.1+) looks for the following keys in <code>StorageClass.parameters</code>:</p>
<ul>
<li><code>csi.storage.k8s.io/node-stage-secret-name</code></li>
<li><code>csi.storage.k8s.io/node-stage-secret-namespace</code></li>
</ul>
<p>The value of both parameters, together, refer to the name and namespace of the <code>Secret</code> object in the Kubernetes API.</p>
<p>If specified, the CSI <code>external-provisioner</code> sets the <code>CSIPersistentVolumeSource.NodeStageSecretRef</code> field in the new <code>PersistentVolume</code> object to refer to this secret once provisioning is successful.</p>
<p>The Kubernetes kubelet then attempts to fetch the secret referenced by the <code>CSIPersistentVolumeSource.NodeStageSecretRef</code> field, if specified, before a mount device operation.</p>
<p>If no such secret exists in the Kubernetes API, or the kubelet is unable to fetch it, the mount device operation fails.</p>
<p>If the secret is retrieved successfully, the kubelet passes it to the CSI driver in the <code>NodeStageVolumeRequest.secrets</code> field.</p>
<p>The values of these parameters may be &quot;templates&quot;. The <code>external-provisioner</code> will automatically resolve templates at volume provision time, as detailed below:</p>
<ul>
<li><code>csi.storage.k8s.io/node-stage-secret-name</code>
<ul>
<li><code>${pv.name}</code>
<ul>
<li>Replaced with name of the <code>PersistentVolume</code> object being provisioned.</li>
</ul>
</li>
<li><code>${pvc.namespace}</code>
<ul>
<li>Replaced with namespace of the <code>PersistentVolumeClaim</code> object that triggered provisioning.</li>
</ul>
</li>
<li><code>${pvc.name}</code>
<ul>
<li>Replaced with the name of the <code>PersistentVolumeClaim</code> object that triggered provisioning.</li>
</ul>
</li>
<li><code>${pvc.annotations['&lt;ANNOTATION_KEY&gt;']}</code> (e.g. <code>${pvc.annotations['example.com/key']}</code>)
<ul>
<li>Replaced with the value of the specified annotation from the <code>PersistentVolumeClaim</code> object that triggered provisioning</li>
</ul>
</li>
</ul>
</li>
<li><code>csi.storage.k8s.io/node-stage-secret-namespace</code>
<ul>
<li><code>${pv.name}</code>
<ul>
<li>Replaced with name of the <code>PersistentVolume</code> object being provisioned.</li>
</ul>
</li>
<li><code>${pvc.namespace}</code>
<ul>
<li>Replaced with namespace of the <code>PersistentVolumeClaim</code> object that triggered provisioning.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#node-publish-secret" id="node-publish-secret">Node Publish Secret</a></h3>
<p>The CSI <code>external-provisioner</code> (v1.0.1+) looks for the following keys in <code>StorageClass.parameters</code>:</p>
<ul>
<li><code>csi.storage.k8s.io/node-publish-secret-name</code></li>
<li><code>csi.storage.k8s.io/node-publish-secret-namespace</code></li>
</ul>
<p>The value of both parameters, together, refer to the name and namespace of the <code>Secret</code> object in the Kubernetes API.</p>
<p>If specified, the CSI <code>external-provisioner</code> sets the <code>CSIPersistentVolumeSource.NodePublishSecretRef</code> field in the new <code>PersistentVolume</code> object to refer to this secret once provisioning is successful.</p>
<p>The Kubernetes kubelet, attempts to fetch the secret referenced by the <code>CSIPersistentVolumeSource.NodePublishSecretRef</code> field, if specified, before a mount operation.</p>
<p>If no such secret exists in the Kubernetes API, or the kubelet is unable to fetch it, the mount operation fails.</p>
<p>If the secret is retrieved successfully, the kubelet passes it to the CSI driver in the <code>NodePublishVolumeRequest.secrets</code> field.</p>
<p>The values of these parameters may be &quot;templates&quot;. The <code>external-provisioner</code> will automatically resolve templates at volume provision time, as detailed below:</p>
<ul>
<li><code>csi.storage.k8s.io/node-publish-secret-name</code>
<ul>
<li><code>${pv.name}</code>
<ul>
<li>Replaced with name of the <code>PersistentVolume</code> object being provisioned.</li>
</ul>
</li>
<li><code>${pvc.namespace}</code>
<ul>
<li>Replaced with namespace of the <code>PersistentVolumeClaim</code> object that triggered provisioning.</li>
</ul>
</li>
<li><code>${pvc.name}</code>
<ul>
<li>Replaced with the name of the <code>PersistentVolumeClaim</code> object that triggered provisioning.</li>
</ul>
</li>
<li><code>${pvc.annotations['&lt;ANNOTATION_KEY&gt;']}</code> (e.g. <code>${pvc.annotations['example.com/key']}</code>)
<ul>
<li>Replaced with the value of the specified annotation from the <code>PersistentVolumeClaim</code> object that triggered provisioning</li>
</ul>
</li>
</ul>
</li>
<li><code>csi.storage.k8s.io/node-publish-secret-namespace</code>
<ul>
<li><code>${pv.name}</code>
<ul>
<li>Replaced with name of the <code>PersistentVolume</code> object being provisioned.</li>
</ul>
</li>
<li><code>${pvc.namespace}</code>
<ul>
<li>Replaced with namespace of the <code>PersistentVolumeClaim</code> object that triggered provisioning.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#controller-expand-volume-resize-secret" id="controller-expand-volume-resize-secret">Controller Expand (Volume Resize) Secret</a></h3>
<p>The CSI <code>external-provisioner</code> (v1.2.0+) looks for the following keys in <code>StorageClass.parameters</code>:</p>
<ul>
<li><code>csi.storage.k8s.io/controller-expand-secret-name</code></li>
<li><code>csi.storage.k8s.io/controller-expand-secret-namespace</code></li>
</ul>
<p>The value of both parameters, together, refer to the name and namespace of the <code>Secret</code> object in the Kubernetes API.</p>
<p>If specified, the CSI <code>external-provisioner</code> sets the <code>CSIPersistentVolumeSource.ControllerExpandSecretRef</code> field in the new <code>PersistentVolume</code> object to refer to this secret once provisioning is successful.</p>
<p>The <code>external-resizer</code> (v0.2.0+), attempts to fetch the secret referenced by the <code>CSIPersistentVolumeSource.ControllerExpandSecretRef</code> field, if specified, before starting a volume resize (expand) operation.</p>
<p>If no such secret exists in the Kubernetes API, or the <code>external-resizer</code> is unable to fetch it, the resize (expand) operation fails.</p>
<p>If the secret is retrieved successfully, the <code>external-resizer</code> passes it to the CSI driver in the <code>ControllerExpandVolumeRequest.secrets</code> field.</p>
<p>The values of these parameters may be &quot;templates&quot;. The <code>external-provisioner</code> will automatically resolve templates at volume provision time, as detailed below:</p>
<ul>
<li><code>csi.storage.k8s.io/controller-expand-secret-name</code>
<ul>
<li><code>${pv.name}</code>
<ul>
<li>Replaced with name of the <code>PersistentVolume</code> object being provisioned.</li>
</ul>
</li>
<li><code>${pvc.namespace}</code>
<ul>
<li>Replaced with namespace of the <code>PersistentVolumeClaim</code> object that triggered provisioning.</li>
</ul>
</li>
<li><code>${pvc.name}</code>
<ul>
<li>Replaced with the name of the <code>PersistentVolumeClaim</code> object that triggered provisioning.</li>
</ul>
</li>
<li><code>${pvc.annotations['&lt;ANNOTATION_KEY&gt;']}</code> (e.g. <code>${pvc.annotations['example.com/key']}</code>)
<ul>
<li>Replaced with the value of the specified annotation from the <code>PersistentVolumeClaim</code> object that triggered provisioning</li>
</ul>
</li>
</ul>
</li>
<li><code>csi.storage.k8s.io/controller-expand-secret-namespace</code>
<ul>
<li><code>${pv.name}</code>
<ul>
<li>Replaced with name of the <code>PersistentVolume</code> object being provisioned.</li>
</ul>
</li>
<li><code>${pvc.namespace}</code>
<ul>
<li>Replaced with namespace of the <code>PersistentVolumeClaim</code> object that triggered provisioning.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#volumesnapshotclass-secrets" id="volumesnapshotclass-secrets">VolumeSnapshotClass Secrets</a></h1>
<p>The CSI <a href="external-snapshotter.html">external-snapshotter</a> sidecar container facilitates the handling of secrets for the following operations:</p>
<ul>
<li><code>CreateSnapshotRequest</code></li>
<li><code>DeleteSnapshotRequest</code></li>
</ul>
<p>CSI <code>external-snapshotter</code> v1.0.1+ supports the following keys in <code>VolumeSnapshotClass.parameters</code>:</p>
<ul>
<li><code>csi.storage.k8s.io/snapshotter-secret-name</code></li>
<li><code>csi.storage.k8s.io/snapshotter-secret-namespace</code></li>
</ul>
<p>Cluster admins can populate the secret fields for the operations listed above with data from Kubernetes <code>Secret</code> objects by specifying these keys in the <code>VolumeSnapshotClass</code> object.</p>
<h2><a class="header" href="#operations-1" id="operations-1">Operations</a></h2>
<p>Details for each secret supported by the external-snapshotter can be found below.</p>
<h3><a class="header" href="#createdelete-volumesnapshot-secret" id="createdelete-volumesnapshot-secret">Create/Delete VolumeSnapshot Secret</a></h3>
<p>CSI <code>external-snapshotter</code> v1.0.1+ looks for the following keys in <code>VolumeSnapshotClass.parameters</code>:</p>
<ul>
<li><code>csi.storage.k8s.io/snapshotter-secret-name</code></li>
<li><code>csi.storage.k8s.io/snapshotter-secret-namespace</code></li>
</ul>
<p>The values of both of these parameters, together, refer to the name and namespace of a <code>Secret</code> object in the Kubernetes API.</p>
<p>If specified, the CSI <code>external-snapshotter</code> will attempt to fetch the secret before creation and deletion.</p>
<p>If the secret is retrieved successfully, the snapshotter passes it to the CSI driver in the <code>CreateSnapshotRequest.secrets</code> or <code>DeleteSnapshotRequest.secrets</code> field.</p>
<p>If no such secret exists in the Kubernetes API, or the snapshotter is unable to fetch it, the create operation will fail.</p>
<p>Note, however, that the delete operation will continue even if the secret is not found (because, for example, the entire namespace containing the secret was deleted). In this case, if the driver requires a secret for deletion, then the volume and PV may need to be manually cleaned up.</p>
<p>The values of these parameters may be &quot;templates&quot;. The <code>external-snapshotter</code> will automatically resolve templates at snapshot create time, as detailed below:</p>
<ul>
<li><code>csi.storage.k8s.io/snapshotter-secret-name</code>
<ul>
<li><code>${volumesnapshotcontent.name}</code>
<ul>
<li>Replaced with name of the <code>VolumeSnapshotContent</code> object being created.</li>
</ul>
</li>
<li><code>${volumesnapshot.namespace}</code>
<ul>
<li>Replaced with namespace of the <code>VolumeSnapshot</code> object that triggered creation.</li>
</ul>
</li>
<li><code>${volumesnapshot.name}</code>
<ul>
<li>Replaced with the name of the <code>VolumeSnapshot</code> object that triggered creation.</li>
</ul>
</li>
</ul>
</li>
<li><code>csi.storage.k8s.io/snapshotter-secret-namespace</code>
<ul>
<li><code>${volumesnapshotcontent.name}</code>
<ul>
<li>Replaced with name of the <code>VolumeSnapshotContent</code> object being created.</li>
</ul>
</li>
<li><code>${volumesnapshot.namespace}</code>
<ul>
<li>Replaced with namespace of the <code>VolumeSnapshot</code> object that triggered creation.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#csi-topology-feature" id="csi-topology-feature">CSI Topology Feature</a></h1>
<h2><a class="header" href="#status-2" id="status-2">Status</a></h2>
<table><thead><tr><th>Status</th><th>Min K8s Version</th><th>Max K8s Version</th><th>external-provisioner Version</th></tr></thead><tbody>
<tr><td>Alpha</td><td>1.12</td><td>1.12</td><td>0.4</td></tr>
<tr><td>Alpha</td><td>1.13</td><td>1.13</td><td>1.0</td></tr>
<tr><td>Beta</td><td>1.14</td><td>1.16</td><td>1.1-1.4</td></tr>
<tr><td>GA</td><td>1.17</td><td>-</td><td>1.5+</td></tr>
</tbody></table>
<h2><a class="header" href="#overview-1" id="overview-1">Overview</a></h2>
<p>Some storage systems expose volumes that are not equally accessible by all nodes in a Kubernetes cluster. Instead volumes may be constrained to some subset of node(s) in the cluster. The cluster may be segmented into, for example, racks or regions and zones or some other grouping, and a given volume may be accessible only from one of those groups.</p>
<p>To enable orchestration systems, like Kubernetes, to work well with storage systems which expose volumes that are not equally accessible by all nodes, the <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md">CSI spec</a> enables:</p>
<ol>
<li>Ability for a CSI Driver to opaquely specify where a particular node exists (e.g. &quot;node A&quot; is in &quot;zone 1&quot;).</li>
<li>Ability for Kubernetes (users or components) to influence where a volume is provisioned (e.g. provision new volume in either &quot;zone 1&quot; or &quot;zone 2&quot;).</li>
<li>Ability for a CSI Driver to opaquely specify where a particular volume exists (e.g. &quot;volume X&quot; is accessible by all nodes in &quot;zone 1&quot; and &quot;zone 2&quot;).</li>
</ol>
<p>Kubernetes and the <a href="external-provisioner.html">external-provisioner</a> use these abilities to make intelligent scheduling and provisioning decisions (that Kubernetes can both influence and act on topology information for each volume),</p>
<h2><a class="header" href="#implementing-topology-in-your-csi-driver" id="implementing-topology-in-your-csi-driver">Implementing Topology in your CSI Driver</a></h2>
<p>To support topology in a CSI driver, the following must be implemented:</p>
<ul>
<li>The <code>PluginCapability</code> must support <code>VOLUME_ACCESSIBILITY_CONSTRAINTS</code>.</li>
<li>The plugin must fill in <code>accessible_topology</code> in <code>NodeGetInfoResponse</code>.
This information will be used to populate the Kubernetes <a href="csi-node-object.html">CSINode object</a> and add the topology labels to the Node object.</li>
<li>During <code>CreateVolume</code>, the topology information will get passed in through <code>CreateVolumeRequest.accessibility_requirements</code>.</li>
</ul>
<p>In the StorageClass object, both <code>volumeBindingMode</code> values of <code>Immediate</code> and
<code>WaitForFirstConsumer</code> are supported.</p>
<ul>
<li>If <code>Immediate</code> is set, then the
external-provisioner will pass in all available topologies in the cluster for
the driver.</li>
<li>If <code>WaitForFirstConsumer</code> is set, then the external-provisioner will wait for
the scheduler to pick a node. The topology of that selected node will then be
set as the first entry in <code>CreateVolumeRequest.accessibility_requirements.preferred</code>.
All remaining topologies are still included in the <code>requisite</code> and <code>preferred</code>
fields to support storage systems that span across multiple topologies.</li>
</ul>
<h2><a class="header" href="#sidecar-deployment" id="sidecar-deployment">Sidecar Deployment</a></h2>
<p>The topology feature requires the
<a href="external-provisioner.html">external-provisioner</a> sidecar with the
Topology feature gate enabled:</p>
<pre><code>--feature-gates=Topology=true
</code></pre>
<h2><a class="header" href="#kubernetes-cluster-setup" id="kubernetes-cluster-setup">Kubernetes Cluster Setup</a></h2>
<h3><a class="header" href="#beta" id="beta">Beta</a></h3>
<p>In the <em>Kubernetes cluster</em> the <code>CSINodeInfo</code> feature must be enabled on both Kubernetes master and nodes (refer to the <a href="csi-node-object.html">CSINode Object</a> section for more info):</p>
<pre><code>--feature-gates=CSINodeInfo=true
</code></pre>
<p>In order to fully function properly, all Kubernetes master and nodes must be on at least
Kubernetes 1.14. If a selected node is on a lower version, topology is ignored and not
passed to the driver during <code>CreateVolume</code>.</p>
<h3><a class="header" href="#alpha" id="alpha">Alpha</a></h3>
<p>The alpha feature in the external-provisioner is not compatible across
Kubernetes versions. In addition, Kubernetes master and node version skew and
upgrades are not supported.</p>
<p>The <code>CSINodeInfo</code>, <code>VolumeScheduling</code>, and <code>KubeletPluginsWatcher</code> feature gates
must be enabled on both Kubernetes master and nodes.</p>
<p>The <a href="csi-node-object.html">CSINodeInfo</a> CRDs also have to be manually installed in the
cluster.</p>
<h2><a class="header" href="#storage-internal-topology" id="storage-internal-topology">Storage Internal Topology</a></h2>
<p>Note that a storage system may also have an &quot;internal topology&quot; different from (independent of) the topology of the cluster where workloads are scheduled. Meaning volumes exposed by the storage system are equally accessible by all nodes in the Kubernetes cluster, but the storage system has some internal topology that may influence, for example, the performance of a volume from a given node.</p>
<p>CSI does not currently expose a first class mechanism to influence such storage system internal topology on provisioning. Therefore, Kubernetes can not programmatically influence such topology. However, a CSI Driver may expose the ability to specify internal storage topology during volume provisioning using an opaque parameter in the <code>CreateVolume</code> CSI call (CSI enables CSI Drivers to expose an arbitrary set of configuration options during dynamic provisioning by allowing opaque parameters to be passed from cluster admins to the storage plugins) -- this would enable cluster admins to be able to control the storage system internal topology during provisioning.</p>
<p># Raw Block Volume Feature</p>
<h2><a class="header" href="#status-3" id="status-3">Status</a></h2>
<table><thead><tr><th>Status</th><th>Min K8s Version</th><th>Max K8s Version</th><th>external-provisioner Version</th><th>external-attacher Version</th></tr></thead><tbody>
<tr><td>Alpha</td><td>1.11</td><td>1.13</td><td>0.4</td><td>0.4</td></tr>
<tr><td>Alpha</td><td>1.13</td><td>1.13</td><td>1.0</td><td>1.0</td></tr>
<tr><td>Beta</td><td>1.14</td><td>1.17</td><td>1.1+</td><td>1.1+</td></tr>
<tr><td>GA</td><td>1.18</td><td>-</td><td>1.1+</td><td>1.1+</td></tr>
</tbody></table>
<h2><a class="header" href="#overview-2" id="overview-2">Overview</a></h2>
<p>This page documents how to implement raw block volume support to a CSI Driver.</p>
<p>A <em>block volume</em> is a volume that will appear as a block device inside the container.
A <em>mounted (file) volume</em> is volume that will be mounted using a specified file system and appear as a directory inside the container.</p>
<p>The <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md">CSI spec</a> supports both block and mounted (file) volumes.</p>
<h2><a class="header" href="#implementing-raw-block-volume-support-in-your-csi-driver" id="implementing-raw-block-volume-support-in-your-csi-driver">Implementing Raw Block Volume Support in Your CSI Driver</a></h2>
<p>CSI doesn't provide a capability query for block volumes, so COs will simply pass through requests for
block volume creation to CSI plugins, and plugins are allowed to fail with the <code>InvalidArgument</code> GRPC
error code if they don't support block volumes. Kubernetes doesn't make any assumptions about which CSI
plugins support blocks and which don't, so users have to know if any given storage class is capable of
creating block volumes.</p>
<p>The difference between a request for a mounted (file) volume and a block volume is the <code>VolumeCapabilities</code>
field of the request. Note that this field is an array and the created volume must support ALL of the
capabilities requested, or else return an error. If the <code>AccessType</code> method of a <code>VolumeCapability</code>
<code>VolumeCapability_Block</code>, then the capability is requesting a raw block volume. Unlike mount volumes, block
volumes don't have any specific capabilities that need to be validated, although access modes still
apply.</p>
<p>Block volumes are much more likely to support multi-node flavors of <code>VolumeCapability_AccessMode_Mode</code>
than mount volumes, because there's no file system state stored on the node side that creates any technical
impediments to multi-attaching block volumes. While there may still be good reasons to prevent
multi-attaching block volumes, and there may be implementations that are not capable of supporting
multi-attach, you should think carefully about what makes sense for your driver.</p>
<p>CSI plugins that support both mount and block volumes must be sure to check the capabilities of all CSI RPC
requests and ensure that the capability of the request matches the capability of the volume, to avoid trying
to do file-system-related things to block volumes and block-related things to file system volumes. The
following RPCs specify capabilities that must be validated:</p>
<ul>
<li><code>CreateVolume()</code> (multiple capabilities)</li>
<li><code>ControllerPublishVolume()</code></li>
<li><code>ValidateVolumeCapabilities()</code> (multiple capabilities)</li>
<li><code>GetCapacity()</code> (see below)</li>
<li><code>NodeStageVolume()</code></li>
<li><code>NodePublishVolume()</code></li>
</ul>
<p>Also, CSI plugins that implement the optional <code>GetCapacity()</code> RPC should note that that RPC includes
capabilities too, and if the capacity for mount volumes is not the same as the capacity for block
volumes, that needs to be handled in the implementation of that RPC.</p>
<p>Q: Can CSI plugins support only block volumes and not mount volumes?
A: Yes! This is just the reverse case of supporting mount volumes only. Plugins may return <code>InvalidArgument</code>
for any creation request with an <code>AccessType</code> of <code>VolumeCapability_Mount</code>.</p>
<h2><a class="header" href="#differences-between-block-and-mount-volumes" id="differences-between-block-and-mount-volumes">Differences Between Block and Mount Volumes</a></h2>
<p>The main difference between block volumes and mount volumes is the expected result of the <code>NodePublish()</code>.
For mount volumes, the CO expects the result to be a mounted directory, at <code>TargetPath</code>. For block volumes,
the CO expects there to be a device file at <code>TargetPath</code>. The device file can be a bind-mounted device from
the hosts <code>/dev</code> file system, or it can be a device node created at that location using <code>mknod()</code>.</p>
<p>It's desirable but not required to expose an unfiltered device node. For example, CSI plugins based on
technologies that implement SCSI protocols should expect that pods consuming the block volumes they create
may want to send SCSI commands to the device. This is something that should &quot;just work&quot; by default (subject
to container capabilities) so CSI plugins should avoid anything that would break this kind of use case. The
only hard requirement is that the device implements block reading/writing however.</p>
<p>For plugins with the <code>RPC_STAGE_UNSTAGE_VOLUME</code> capability, the CO doesn't care exactly what is placed at
the <code>StagingTargetPath</code>, but it's worth noting that some CSI RPCs are allowed to pass the plugin either
a staging path or a publish path, so it's important to think carefully about how <code>NodeStageVolume()</code> is
implemented, knowing that either path could get used by the CO to refer to the volume later on. This is
made more challenging because the CSI spec says that <code>StagingTargetPath</code> is always a directory even for
block volumes.</p>
<h2><a class="header" href="#sidecar-deployment-1" id="sidecar-deployment-1">Sidecar Deployment</a></h2>
<p>The raw block feature requires the
<a href="external-provisioner.html">external-provisioner</a> and
<a href="external-attacher.html">external-attacher</a> sidecars to be deployed.</p>
<h2><a class="header" href="#kubernetes-cluster-setup-1" id="kubernetes-cluster-setup-1">Kubernetes Cluster Setup</a></h2>
<p>The <code>BlockVolume</code> and <code>CSIBlockVolume</code> feature gates need to be enabled on
all Kubernetes masters and nodes.</p>
<pre><code>--feature-gates=BlockVolume=true,CSIBlockVolume=true...
</code></pre>
<ul>
<li>TODO: detail how Kubernetes API raw block fields get mapped to CSI methods/fields.</li>
</ul>
<h1><a class="header" href="#skip-kubernetes-attach-and-detach" id="skip-kubernetes-attach-and-detach">Skip Kubernetes Attach and Detach</a></h1>
<h2><a class="header" href="#status-4" id="status-4">Status</a></h2>
<table><thead><tr><th>Status</th><th>Min K8s Version</th><th>Max K8s Version</th><th>cluster-driver-registrar Version</th></tr></thead><tbody>
<tr><td>Alpha</td><td>1.12</td><td>1.12</td><td>0.4</td></tr>
<tr><td>Alpha</td><td>1.13</td><td>1.13</td><td>1.0</td></tr>
<tr><td>Beta</td><td>1.14</td><td>1.17</td><td>n/a</td></tr>
<tr><td>GA</td><td>1.18</td><td>-</td><td>n/a</td></tr>
</tbody></table>
<h1><a class="header" href="#overview-3" id="overview-3">Overview</a></h1>
<p>Volume drivers, like NFS, for example, have no concept of an attach (<code>ControllerPublishVolume</code>). However, Kubernetes always executes <code>Attach</code> and <code>Detach</code> operations even if the CSI driver does not implement an attach operation (i.e. even if the CSI Driver does not implement a <code>ControllerPublishVolume</code> call).</p>
<p>This was problematic because it meant <em>all</em> CSI drivers had to handle Kubernetes attachment. CSI Drivers that did not implement the <code>PUBLISH_UNPUBLISH_VOLUME</code> controller capability could work around this by deploying an <a href="external-attacher.html">external-attacher</a> and the <code>external-attacher</code> would responds to Kubernetes attach operations and simply do a noop (because the CSI driver did not advertise the <code>PUBLISH_UNPUBLISH_VOLUME</code> controller capability).</p>
<p>Although the workaround works, it adds an unnecessary operation (round-trip) in the preparation of a volume for a container, and requires CSI Drivers to deploy an unnecessary sidecar container (<code>external-attacher</code>).</p>
<h1><a class="header" href="#skip-attach-with-csi-driver-object" id="skip-attach-with-csi-driver-object">Skip Attach with CSI Driver Object</a></h1>
<p>The <a href="csi-driver-object.html">CSIDriver Object</a> enables CSI Drivers to specify how Kubernetes should interact with it.</p>
<p>Specifically the <code>attachRequired</code> field instructs Kubernetes to skip any attach operation altogether.</p>
<p>For example, the existence of the following object would cause Kubernetes to skip attach operations for all CSI Driver <code>testcsidriver.example.com</code> volumes.</p>
<pre><code>apiVersion: storage.k8s.io/v1
kind: CSIDriver
metadata:
  name: testcsidriver.example.com
spec:
  attachRequired: false
</code></pre>
<p>CSIDriver object should be manually included in the driver deployment manifests.</p>
<p>Previously, the <a href="cluster-driver-registrar.html">cluster-driver-registrar</a> sidecar container could be deployed to automatically create the object. Once the flags to this container are configured correctly, it will automatically create a <a href="csi-driver-object.html">CSIDriver Object</a> when it starts with the correct fields set.</p>
<h2><a class="header" href="#alpha-functionality" id="alpha-functionality">Alpha Functionality</a></h2>
<p>In alpha, this feature was enabled via the <a href="csi-driver-object.html">CSIDriver Object</a> CRD.</p>
<pre><code>apiVersion: csi.storage.k8s.io/v1alpha1
kind: CSIDriver
metadata:
....
</code></pre>
<h1><a class="header" href="#pod-info-on-mount" id="pod-info-on-mount">Pod Info on Mount</a></h1>
<h1><a class="header" href="#status-5" id="status-5">Status</a></h1>
<table><thead><tr><th>Status</th><th>Min K8s Version</th><th>Max K8s Version</th><th>cluster-driver-registrar Version</th></tr></thead><tbody>
<tr><td>Alpha</td><td>1.12</td><td>1.12</td><td>0.4</td></tr>
<tr><td>Alpha</td><td>1.13</td><td>1.13</td><td>1.0</td></tr>
<tr><td>Beta</td><td>1.14</td><td>1.17</td><td>n/a</td></tr>
<tr><td>GA</td><td>1.18</td><td>-</td><td>n/a</td></tr>
</tbody></table>
<h1><a class="header" href="#overview-4" id="overview-4">Overview</a></h1>
<p>CSI avoids encoding Kubernetes specific information in to the specification, since it aims to support multiple orchestration systems (beyond just Kubernetes).</p>
<p>This can be problematic because some CSI drivers require information about the workload (e.g. which pod is referencing this volume), and CSI does not provide this information natively to drivers.</p>
<h1><a class="header" href="#pod-info-on-mount-with-csi-driver-object" id="pod-info-on-mount-with-csi-driver-object">Pod Info on Mount with CSI Driver Object</a></h1>
<p>The <a href="csi-driver-object.html">CSIDriver Object</a> enables CSI Drivers to specify how Kubernetes should interact with it.</p>
<p>Specifically the <code>podInfoOnMount</code> field instructs Kubernetes that the CSI driver requires additional pod information (like podName, podUID, etc.) during mount operations.</p>
<p>For example, the existence of the following object would cause Kubernetes to add pod information at mount time to the <code>NodePublishVolumeRequest.volume_context</code> map.</p>
<pre><code>apiVersion: storage.k8s.io/v1
kind: CSIDriver
metadata:
  name: testcsidriver.example.com
spec:
  podInfoOnMount: true
</code></pre>
<p>If the <code>podInfoOnMount</code> field is set to <code>true</code>, during mount, Kubelet will add the following key/values to the <code>volume_context</code> field in the CSI <code>NodePublishVolumeRequest</code>:</p>
<ul>
<li><code>csi.storage.k8s.io/pod.name: {pod.Name}</code></li>
<li><code>csi.storage.k8s.io/pod.namespace: {pod.Namespace}</code></li>
<li><code>csi.storage.k8s.io/pod.uid: {pod.UID}</code></li>
<li><code>csi.storage.k8s.io/serviceAccount.name: {pod.Spec.ServiceAccountName}</code></li>
</ul>
<p>The CSIDriver object should be manually included in the driver manifests.</p>
<p>Previously, the <a href="cluster-driver-registrar.html">cluster-driver-registrar</a> sidecar container could be used to create the object. Once the flags to this container are configured correctly, it will automatically create a <a href="csi-driver-object.html">CSIDriver Object</a> when it starts with the correct fields set.</p>
<h2><a class="header" href="#alpha-functionality-1" id="alpha-functionality-1">Alpha Functionality</a></h2>
<p>In alpha, this feature was enabled by setting the <code>podInfoOnMountVersion</code> field in the <code>CSIDriver</code> Object CRD to <code>v1</code>.</p>
<pre><code>apiVersion: csi.storage.k8s.io/v1alpha1
kind: CSIDriver
metadata:
  name: testcsidriver.example.com
spec:
  podInfoOnMountVersion: v1
</code></pre>
<h1><a class="header" href="#volume-expansion" id="volume-expansion">Volume Expansion</a></h1>
<h2><a class="header" href="#status-6" id="status-6">Status</a></h2>
<table><thead><tr><th>Status</th><th>Min K8s Version</th><th>Max K8s Version</th><th>external-resizer Version</th></tr></thead><tbody>
<tr><td>Alpha</td><td>1.14</td><td>1.15</td><td>0.2</td></tr>
<tr><td>Beta</td><td>1.16</td><td>-</td><td>0.3</td></tr>
</tbody></table>
<h2><a class="header" href="#overview-5" id="overview-5">Overview</a></h2>
<p>A storage provider that allows volume expansion after creation, may choose to implement volume expansion either via a
control-plane CSI RPC call or via node CSI RPC call or both as a two step process.</p>
<h2><a class="header" href="#implementing-volume-expansion-functionality" id="implementing-volume-expansion-functionality">Implementing Volume expansion functionality</a></h2>
<p>To implement volume expansion the CSI driver MUST:</p>
<ol>
<li>Implement <code>VolumeExpansion</code> plugin capability.</li>
<li>Implement <code>EXPAND_VOLUME</code> controller capability or implement <code>EXPAND_VOLUME</code> node capability or both.</li>
</ol>
<p><code>ControllerExpandVolume</code> RPC call can be made when volume is <code>ONLINE</code> or <code>OFFLINE</code> depending on <code>VolumeExpansion</code> plugin
capability. Where <code>ONLINE</code> and <code>OFFLINE</code> means:</p>
<ol>
<li><em>ONLINE</em> : Volume is currently published or available on a node.</li>
<li><em>OFFLINE</em> : Volume is currently not published or available on a node.</li>
</ol>
<p><code>NodeExpandVolume</code> RPC call on the other hand - <em>always</em> requires volume to be published or staged on a node (and hence <code>ONLINE</code>).
For block storage file systems - <code>NodeExpandVolume</code> is typically used for expanding the file system on the node, but it can be also
used to perform other volume expansion related housekeeping operations on the node.</p>
<p>For details, see the <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md">CSI spec</a>.</p>
<h2><a class="header" href="#deploying-volume-expansion-functionality" id="deploying-volume-expansion-functionality">Deploying volume expansion functionality</a></h2>
<p>The Kubernetes CSI development team maintains <a href="external-resizer.html">external-resizer</a> Kubernetes CSI <a href="sidecar-containers.html">Sidecar Containers</a>.
This sidecar container implements the logic for watching the Kubernetes API for Persistent Volume claim edits and issuing <code>ControllerExpandVolume</code> RPC call against a CSI endpoint and updating <code>PersistentVolume</code> object to reflect new size.</p>
<p>This sidecar is needed even if CSI driver does not have <code>EXPAND_VOLUME</code> controller capability, in this case it performs a NO-OP expansion and updates <code>PersistentVolume</code> object. <code>NodeExpandVolume</code> is always called by Kubelet on the node.</p>
<p>For more details, see <a href="external-resizer.html">external-resizer</a>.</p>
<h2><a class="header" href="#enabling-volume-expansion-for-csi-volumes-in-kubernetes" id="enabling-volume-expansion-for-csi-volumes-in-kubernetes">Enabling Volume expansion for CSI volumes in Kubernetes</a></h2>
<p>To expand a volume if permitted by the <a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#expanding-persistent-volumes-claims">storage class</a>, users just need to edit the persistent volume claim object and request more storage.</p>
<p>In Kubernetes 1.14 and 1.15, this feature was in alpha status and required enabling the following feature gate:</p>
<pre><code>--feature-gates=ExpandCSIVolumes=true
</code></pre>
<p>Also in Kubernetes 1.14 and 1.15, online expansion had to be enabled explicitly:</p>
<pre><code>--feature-gates=ExpandInUsePersistentVolumes=true
</code></pre>
<p>external-resizer and kubelet add appropriate events and conditions to persistent volume claim objects indicating progress of volume expansion operations.</p>
<h2><a class="header" href="#kubernetes-pvc-datasource-csi-volumecontentsource" id="kubernetes-pvc-datasource-csi-volumecontentsource">Kubernetes PVC DataSource (CSI VolumeContentSource)</a></h2>
<p>When creating a new PersistentVolumeClaim, the Kubernetes API provides a <code>PersistentVolumeClaim.DataSource</code> parameter.  This parameter is used to specify the CSI <code>CreateVolumeRequest.VolumeContentSource</code> option for CSI Provisioners. The <code>VolumeContentSource</code> parameter instructs the CSI plugin to pre-populate the volume being provisioned with data from the specified source. </p>
<h3><a class="header" href="#external-provisioner-responsibilities" id="external-provisioner-responsibilities">External Provisioner Responsibilities</a></h3>
<p>If a <code>DataSource</code> is specified in the <code>CreateVolume</code> call to the CSI external provisioner, the external provisioner will fetch the specified resource and pass the appropriate object id to the plugin.</p>
<h2><a class="header" href="#supported-datasources" id="supported-datasources">Supported DataSources</a></h2>
<p>Currently there are two types of <code>PersistentVolumeClaim.DataSource</code> objects that are supported:</p>
<ol>
<li><a href="snapshot-restore-feature.html">VolumeSnapshot</a></li>
<li><a href="volume-cloning.html">PersistentVolumeClaim (Cloning)</a></li>
</ol>
<h1><a class="header" href="#volume-cloning" id="volume-cloning">Volume Cloning</a></h1>
<h2><a class="header" href="#status-and-releases-12" id="status-and-releases-12">Status and Releases</a></h2>
<table><thead><tr><th>Status</th><th>Min k8s Version</th><th>Max k8s version</th><th>external-provisioner Version</th></tr></thead><tbody>
<tr><td>Alpha</td><td>1.15</td><td>1.15</td><td>1.3</td></tr>
<tr><td>Beta</td><td>1.16</td><td>1.17</td><td>1.4</td></tr>
<tr><td>GA</td><td>1.18</td><td>-</td><td>1.6</td></tr>
</tbody></table>
<h2><a class="header" href="#overview-6" id="overview-6">Overview</a></h2>
<p>A Clone is defined as a duplicate of an existing Kubernetes Volume.  For more information on cloning in Kubernetes see the concepts doc for <a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#volume-cloning">Volume Cloning</a>.  A storage provider that allows volume cloning as a create feature, may choose to implement volume cloning via a control-plan CSI RPC call.</p>
<p>For details regarding the kubernetes API for volume cloning, please see <a href="https://kubernetes.io/docs/concepts/storage/volume-pvc-datasource/">kubernetes concepts</a>.</p>
<h2><a class="header" href="#implementing-volume-cloning-functionality" id="implementing-volume-cloning-functionality">Implementing Volume cloning functionality</a></h2>
<p>To implement volume cloning the CSI driver MUST:</p>
<ol>
<li>Implement checks for <code>csi.CreateVolumeRequest.VolumeContentSource</code> in the plugin's <code>CreateVolume</code> function implementation.</li>
<li>Implement <code>CLONE_VOLUME</code> controller capability.</li>
</ol>
<p>It is the responsibility of the storage plugin to either implement an expansion after clone if a provision request size is greater than the source, or allow the external-resizer to handle it.  In the case that the plugin does not support resize capability and it does not have the capability to create a clone that is greater in size than the specified source volume, then the provision request should result in a failure.</p>
<h2><a class="header" href="#deploying-volume-clone-functionality" id="deploying-volume-clone-functionality">Deploying volume clone functionality</a></h2>
<p>The Kubernetes CSI development team maintains the <a href="external-provisioner.html">external-provisioner</a> which is responsible for detecting requests for a PVC DataSource and providing that information to the plugin via the <code>csi.CreateVolumeRequest</code>.  It's up to the plugin to check the <code>csi.CreateVolumeRequest</code> for a <code>VolumeContentSource</code> entry in the CreateVolumeRequest object.</p>
<p>There are no additional side-cars or add on components required.</p>
<h2><a class="header" href="#enabling-cloning-for-csi-volumes-in-kubernetes" id="enabling-cloning-for-csi-volumes-in-kubernetes">Enabling Cloning for CSI volumes in Kubernetes</a></h2>
<p>Volume cloning was promoted to Beta in version 1.16 and GA in 1.18, and as such is enabled by defult for kubernetes versions &gt;= 1.16</p>
<p>In Kubernetes 1.15 this feature was alpha status and required enabling the appropriate feature gate:</p>
<pre><code>--feature-gates=VolumePVCDataSource=true
</code></pre>
<h2><a class="header" href="#example-implementation" id="example-implementation">Example implementation</a></h2>
<p>A trivial example implementation can be found in the <a href="https://github.com/kubernetes-csi/csi-driver-host-path">csi-hostpath plugin</a> in its implementation of <code>CreateVolume</code>.</p>
<h1><a class="header" href="#snapshot--restore-feature" id="snapshot--restore-feature">Snapshot &amp; Restore Feature</a></h1>
<h2><a class="header" href="#status-7" id="status-7">Status</a></h2>
<table><thead><tr><th>Status</th><th>Min K8s Version</th><th>Max K8s Version</th><th>snapshot-controller Version</th><th>snapshot-validation-webhook Version</th><th>CSI external-snapshotter sidecar Version</th><th>external-provisioner Version</th></tr></thead><tbody>
<tr><td>Alpha</td><td>1.12</td><td>1.12</td><td></td><td></td><td>0.4.0 &lt;= version &lt; 1.0</td><td>0.4.1 &lt;= version &lt; 1.0</td></tr>
<tr><td>Alpha</td><td>1.13</td><td>1.16</td><td></td><td></td><td>1.0.1 &lt;= version &lt; 2.0</td><td>1.0.1 &lt;= version &lt; 1.5</td></tr>
<tr><td>Beta</td><td>1.17</td><td>-</td><td>2.0+</td><td>3.0+</td><td>2.0+</td><td>1.5+</td></tr>
</tbody></table>
<h2><a class="header" href="#overview-7" id="overview-7">Overview</a></h2>
<p>Many storage systems provide the ability to create a &quot;snapshot&quot; of a persistent volume. A snapshot represents a point-in-time copy of a volume. A snapshot can be used either to provision a new volume (pre-populated with the snapshot data) or to restore the existing volume to a previous state (represented by the snapshot).</p>
<p>Kubernetes CSI currently enables CSI Drivers to expose the following functionality via the Kubernetes API:</p>
<ol>
<li>Creation and deletion of volume snapshots via <a href="https://kubernetes.io/docs/concepts/storage/volume-snapshots/">Kubernetes native API</a>. </li>
<li>Creation of new volumes pre-populated with the data from a snapshot via Kubernetes <a href="https://kubernetes.io/docs/concepts/storage/dynamic-provisioning/">dynamic volume provisioning</a>.</li>
</ol>
<p>Note: Documentation under https://kubernetes.io/docs is for the latest Kubernetes release. Documentation for earlier releases are stored in different location. For example, this is the documentation location for <a href="https://v1-16.docs.kubernetes.io/docs/concepts/storage/volume-snapshots/">v1.16</a>.</p>
<h2><a class="header" href="#implementing-snapshot--restore-functionality-in-your-csi-driver" id="implementing-snapshot--restore-functionality-in-your-csi-driver">Implementing Snapshot &amp; Restore Functionality in Your CSI Driver</a></h2>
<p>To implement the snapshot feature, a CSI driver MUST:</p>
<ul>
<li>Implement the <code>CREATE_DELETE_SNAPSHOT</code> and, optionally, the <code>LIST_SNAPSHOTS</code> controller capabilities</li>
<li>Implement <code>CreateSnapshot</code>, <code>DeleteSnapshot</code>, and, optionally, the <code>ListSnapshots</code>, controller RPCs.</li>
</ul>
<p>For details,  see the <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md">CSI spec</a>.</p>
<h2><a class="header" href="#sidecar-deployment-2" id="sidecar-deployment-2">Sidecar Deployment</a></h2>
<p>The Kubernetes CSI development team maintains the <a href="external-snapshotter.html">external-snapshotter</a> Kubernetes CSI <a href="sidecar-containers.html">Sidecar Containers</a>. This sidecar container implements the logic for watching the Kubernetes API objects and issuing the appropriate CSI snapshot calls against a CSI endpoint. For more details, see <a href="external-snapshotter.html">external-snapshotter documentation</a>.</p>
<h2><a class="header" href="#snapshot-beta" id="snapshot-beta">Snapshot Beta</a></h2>
<h3><a class="header" href="#snapshot-apis" id="snapshot-apis">Snapshot APIs</a></h3>
<p>With the promotion of Volume Snapshot to beta, the feature is now enabled by default on standard Kubernetes deployments instead of being opt-in. This involves a revamp of volume snapshot APIs.</p>
<p>The schema definition for the custom resources (CRs) can be found <a href="https://github.com/kubernetes-csi/external-snapshotter/blob/release-3.0/client/apis/volumesnapshot/v1beta1/types.go">here</a>. The CRDs are no longer automatically deployed by the sidecar. They should be installed by the Kubernetes distributions.</p>
<h4><a class="header" href="#highlights-in-the-snapshot-v1beta1-apis" id="highlights-in-the-snapshot-v1beta1-apis">Highlights in the snapshot v1beta1 APIs</a></h4>
<ul>
<li>DeletionPolicy is a required field in both VolumeSnapshotClass and VolumeSnapshotContent. This way the user has to explicitly specify it, leaving no room for confusion.</li>
<li>VolumeSnapshotSpec has a required Source field. Source may be either a PersistentVolumeClaimName (if dynamically provisioning a snapshot) or VolumeSnapshotContentName (if pre-provisioning a snapshot).</li>
<li>VolumeSnapshotContentSpec has a required Source field. This Source may be either a VolumeHandle (if dynamically provisioning a snapshot) or a SnapshotHandle (if pre-provisioning volume snapshots).</li>
<li>VolumeSnapshot contains a Status to indicate the current state of the volume snapshot. It has a field BoundVolumeSnapshotContentName to indicate the VolumeSnapshot object is bound to a VolumeSnapshotContent.</li>
<li>VolumeSnapshotContent contains a Status to indicate the current state of the volume snapshot content. It has a field SnapshotHandle to indicate that the VolumeSnapshotContent represents a snapshot on the storage system.</li>
</ul>
<h3><a class="header" href="#controller-split" id="controller-split">Controller Split</a></h3>
<ul>
<li>The CSI external-snapshotter sidecar is split into two controllers, a snapshot controller and a CSI external-snapshotter sidecar.</li>
</ul>
<p>The snapshot controller is deployed by the Kubernetes distributions and is responsible for watching the VolumeSnapshot CRD objects and manges the creation and deletion lifecycle of snapshots.</p>
<p>The CSI external-snapshotter sidecar watches Kubernetes VolumeSnapshotContent CRD objects and triggers CreateSnapshot/DeleteSnapshot against a CSI endpoint.</p>
<h3><a class="header" href="#snapshot-validation-webhook-1" id="snapshot-validation-webhook-1">Snapshot Validation Webhook</a></h3>
<p>There is a new validating webhook server which provides tightened validation on snapshot objects. This SHOULD be installed by the Kubernetes distros along with the snapshot-controller, not end users. It SHOULD be installed in all Kubernetes clusters that has the snapshot feature enabled. See <a href="snapshot-validation-webhook.html">Snapshot Validation Webhook</a> for more details on how to use the webhook.</p>
<h3><a class="header" href="#kubernetes-cluster-setup-2" id="kubernetes-cluster-setup-2">Kubernetes Cluster Setup</a></h3>
<p>Volume snapshot is promoted to beta in Kubernetes 1.17 so the <code>VolumeSnapshotDataSource</code> feature gate is enabled by default.</p>
<p>See the Deployment section of <a href="snapshot-controller.html">Snapshot Controller</a> on how to set up the snapshot controller and CRDs.</p>
<p>See the Deployment section of <a href="snapshot-validation-webhook.html">Snapshot Validation Webhook</a> for more details on how to use the webhook.</p>
<h3><a class="header" href="#test-snapshot-feature" id="test-snapshot-feature">Test Snapshot Feature</a></h3>
<p>To test snapshot Beta version, use the following <a href="https://github.com/kubernetes-csi/external-snapshotter/tree/release-3.0/examples/kubernetes">example yaml files</a>.</p>
<p>Create a <em>StorageClass</em>:</p>
<pre><code>kubectl create -f storageclass.yaml
</code></pre>
<p>Create a <em>PVC</em>:</p>
<pre><code>kubectl create -f pvc.yaml
</code></pre>
<p>Create a <em>VolumeSnapshotClass</em>:</p>
<pre><code>kubectl create -f snapshotclass.yaml
</code></pre>
<p>Create a <em>VolumeSnapshot</em>:</p>
<pre><code>kubectl create -f snapshot.yaml
</code></pre>
<p>Create a <em>PVC</em> from a <em>VolumeSnapshot</em>:</p>
<pre><code>kubectl create -f restore.yaml
</code></pre>
<h2><a class="header" href="#snapshot-alpha-1" id="snapshot-alpha-1">Snapshot Alpha</a></h2>
<h3><a class="header" href="#snapshot-apis-1" id="snapshot-apis-1">Snapshot APIs</a></h3>
<p>Similar to the API for managing <a href="https://v1-16.docs.kubernetes.io/docs/concepts/storage/persistent-volumes/">Kubernetes Persistent Volumes</a>, the Kubernetes Volume Snapshots introduce three new API objects for managing snapshots: <code>VolumeSnapshot</code>, <code>VolumeSnapshotContent</code>, and <code>VolumeSnapshotClass</code>. See <a href="https://v1-16.docs.kubernetes.io/docs/concepts/storage/volume-snapshots/">Kubernetes Snapshot documentation</a> for more details.</p>
<p>Unlike the core Kubernetes Persistent Volume objects, these Snapshot objects are defined as <a href="https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/#create-a-customresourcedefinition">Custom Resource Definitions</a> (CRDs). This is because the Kubernetes project is moving away from having resource types pre-defined in the API server. This allows the API server to be reused for projects other than Kubernetes, and consumers (like Kubernetes) simply install the resource types they require as CRDs. Because the Snapshot API types are not built in to Kubernetes, they must be installed prior to use.</p>
<p>The CRDs are <a href="https://github.com/kubernetes-csi/external-snapshotter/blob/release-1.2/cmd/csi-snapshotter/create_crd.go#L29">automatically deployed</a> by the CSI external-snapshotter sidecar. See Alpha section of the sidecar doc <a href="external-snapshotter.html">here</a>.</p>
<p>The schema definition for the custom resources (CRs) can be found <a href="https://github.com/kubernetes-csi/external-snapshotter/blob/release-1.2/pkg/apis/volumesnapshot/v1alpha1/types.go">here</a>.</p>
<p>In addition to these new CRD objects, a new, alpha <code>DataSource</code> field has been added to the <code>PersistentVolumeClaim</code> object. This new field enables dynamic provisioning of new volumes that are automatically pre-populated with data from an existing snapshot.</p>
<h3><a class="header" href="#kubernetes-cluster-setup-3" id="kubernetes-cluster-setup-3">Kubernetes Cluster Setup</a></h3>
<p>Since volume snapshot is an alpha feature in Kubernetes v1.12 to v1.16, you need to enable a new alpha feature gate called <code>VolumeSnapshotDataSource</code> in the Kubernetes master.</p>
<pre><code>--feature-gates=VolumeSnapshotDataSource=true
</code></pre>
<h3><a class="header" href="#test-snapshot-feature-1" id="test-snapshot-feature-1">Test Snapshot Feature</a></h3>
<p>To test snapshot Alpha version, use the following <a href="https://github.com/kubernetes-csi/external-snapshotter/tree/release-1.2/examples/kubernetes">example yaml files</a>.</p>
<p>Create a <em>StorageClass</em>:</p>
<pre><code>kubectl create -f storageclass.yaml
</code></pre>
<p>Create a <em>PVC</em>:</p>
<pre><code>kubectl create -f pvc.yaml
</code></pre>
<p>Create a <em>VolumeSnapshotClass</em>:</p>
<pre><code>kubectl create -f snapshotclass.yaml
</code></pre>
<p>Create a <em>VolumeSnapshot</em>:</p>
<pre><code>kubectl create -f snapshot.yaml
</code></pre>
<p>Create a <em>PVC</em> from a <em>VolumeSnapshot</em>:</p>
<pre><code>kuberctl create -f restore.yaml
</code></pre>
<h4><a class="header" href="#persistentvolumeclaim-not-bound" id="persistentvolumeclaim-not-bound">PersistentVolumeClaim not Bound</a></h4>
<p>If a <code>PersistentVolumeClaim</code> is not bound, the attempt to create a volume snapshot from that <code>PersistentVolumeClaim</code> will fail. No retries will be attempted. An event will be logged to indicate that the <code>PersistentVolumeClaim</code> is not bound.</p>
<p>Note that this could happen if the <code>PersistentVolumeClaim</code> spec and the <code>VolumeSnapshot</code> spec are in the same YAML file. In this case, when the <code>VolumeSnapshot</code> object is created, the <code>PersistentVolumeClaim</code> object is created but volume creation is not complete and therefore the <code>PersistentVolumeClaim</code> is not yet bound. You must wait until the <code>PersistentVolumeClaim</code> is bound and then create the snapshot.</p>
<h2><a class="header" href="#examples-1" id="examples-1">Examples</a></h2>
<p>See the <a href="drivers.html">Drivers</a> for a list of CSI drivers that implement the snapshot feature.</p>
<h1><a class="header" href="#pod-inline-volume-support" id="pod-inline-volume-support">Pod Inline Volume Support</a></h1>
<h2><a class="header" href="#status-8" id="status-8">Status</a></h2>
<h3><a class="header" href="#csi-ephemeral-inline-volumes" id="csi-ephemeral-inline-volumes">CSI Ephemeral Inline Volumes</a></h3>
<table><thead><tr><th>Status</th><th>Min K8s Version</th><th>Max K8s Version</th></tr></thead><tbody>
<tr><td>Alpha</td><td>1.15</td><td>1.15</td></tr>
<tr><td>Beta</td><td>1.16</td><td>1.24</td></tr>
<tr><td>GA</td><td>1.25</td><td></td></tr>
</tbody></table>
<h3><a class="header" href="#generic-ephemeral-inline-volumes" id="generic-ephemeral-inline-volumes">Generic Ephemeral Inline Volumes</a></h3>
<table><thead><tr><th>Status</th><th>Min K8s Version</th><th>Max K8s Version</th></tr></thead><tbody>
<tr><td>Alpha</td><td>1.19</td><td>1.20</td></tr>
<tr><td>Beta</td><td>1.21</td><td>1.22</td></tr>
<tr><td>GA</td><td>1.23</td><td></td></tr>
</tbody></table>
<h2><a class="header" href="#overview-8" id="overview-8">Overview</a></h2>
<p>Traditionally, volumes that are backed by CSI drivers can only be used
with a <code>PersistentVolume</code> and <code>PersistentVolumeClaim</code> object
combination. Two different Kubernetes features allow volumes to follow
the Pod's lifecycle: CSI ephemeral volumes and generic ephemeral
volumes.</p>
<p>In both features, the volumes are specified directly in the pod
specification for ephemeral use cases.  At runtime, nested inline
volumes follow the ephemeral lifecycle of their associated pods where
Kubernetes and the driver handle all phases of volume operations as
pods are created and destroyed.</p>
<p>However, the two features are targeted at different use cases and thus
have different APIs and different implementations.</p>
<blockquote>
<p>See the <a href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-storage/596-csi-inline-volumes">CSI inline
volumes</a>
and <a href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-storage/1698-generic-ephemeral-volumes">generic ephemeral
volumes</a>
enhancement proposals for design details. The user facing
documentation for both features is in the <a href="https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/">Kubernetes
documentation</a>.</p>
</blockquote>
<h2><a class="header" href="#which-feature-should-my-driver-support" id="which-feature-should-my-driver-support">Which feature should my driver support?</a></h2>
<p>CSI ephemeral inline volumes are meant for simple, local volumes. All
parameters that determine the content of the volume can be specified
in the pod spec, and only there. Storage classes are not supported and
all parameters are driver specific.</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: some-pod
spec:
  containers:
    ...
  volumes:
      - name: vol
        csi:
          driver: inline.storage.kubernetes.io
          volumeAttributes:
              foo: bar
</code></pre>
<p>A CSI driver is suitable for CSI ephemeral inline volumes if:</p>
<ul>
<li>it serves a special purpose and needs custom per-volume parameters,
like drivers that provide secrets to a pod</li>
<li>it can create volumes when running on a node</li>
<li>fast volume creation is needed</li>
<li>resource usage on the node is small and/or does not need to be exposed
to Kubernetes</li>
<li>rescheduling of pods onto a different node when storage capacity
turns out to be insufficient is not needed</li>
<li>none of the usual volume features (restoring from snapshot,
cloning volumes, etc.) are needed</li>
<li>ephemeral inline volumes have to be supported on Kubernetes clusters
which do not support generic ephemeral volumes</li>
</ul>
<p>A CSI driver is not suitable for CSI ephemeral inline volumes when:</p>
<ul>
<li>provisioning is not local to the node</li>
<li>ephemeral volume creation requires volumeAttributes that should be restricted
to an administrator, for example parameters that are otherwise set in a
StorageClass or PV. Ephemeral inline volumes allow these attributes to be set
directly in the Pod spec, and so are not restricted to an admin.</li>
</ul>
<p>Generic ephemeral inline volumes make the normal volume API (storage
classes, <code>PersistentVolumeClaim</code>) usable for ephemeral inline
volumes.</p>
<pre><code class="language-yaml">kind: Pod
apiVersion: v1
metadata:
  name: some-pod
spec:
  containers:
     ...
  volumes:
    - name: scratch-volume
      ephemeral:
        volumeClaimTemplate:
          metadata:
            labels:
              type: my-frontend-volume
          spec:
            accessModes: [ &quot;ReadWriteOnce&quot; ]
            storageClassName: &quot;scratch-storage-class&quot;
            resources:
              requests:
                storage: 1Gi
</code></pre>
<p>A CSI driver is suitable for generic ephemeral inline volumes if it
supports dynamic provisioning of volumes. No other changes are needed
in the driver in that case. Such a driver can also support CSI
ephemeral inline volumes if desired.</p>
<h2><a class="header" href="#security-considerations" id="security-considerations">Security Considerations</a></h2>
<p>CSI driver vendors that choose to support ephemeral inline volumes are responsible for secure handling of these volumes, and special consideration needs to be given to what volumeAttributes are supported by the driver. As noted above, a CSI driver is not suitable for CSI ephemeral inline volumes when volume creation requires volumeAttributes that should be restricted to an administrator. These attributes are set directly in the Pod spec, and therefore are not automatically restricted to an administrator when used as an inline volume.</p>
<p>CSI inline volumes are only intended to be used for ephemeral storage, and driver vendors should NOT allow usage of inline volumes for persistent storage unless they also provide a third party pod admission plugin to restrict usage of these volumes.</p>
<p>Cluster administrators who need to restrict the CSI drivers that are
allowed to be used as inline volumes within a Pod spec may do so by:</p>
<ul>
<li>Removing <code>Ephemeral</code> from <code>volumeLifecycleModes</code> in the CSIDriver spec, which prevents the driver from being used as an inline ephemeral volume.</li>
<li>Using an admission webhook to restrict how this driver is used.</li>
</ul>
<h2><a class="header" href="#implementing-csi-ephemeral-inline-support" id="implementing-csi-ephemeral-inline-support">Implementing CSI ephemeral inline support</a></h2>
<p>Drivers must be modified (or implemented specifically) to support CSI inline
ephemeral workflows. When Kubernetes encounters an inline CSI volume embedded
in a pod spec, it treats that volume differently. Mainly, the driver will only
receive <code>NodePublishVolume</code>, during the volume's mount phase, and <code>NodeUnpublishVolume</code> when
the pod is going away and the volume is unmounted.</p>
<p>Due to these requirements, ephemeral volumes will not be created using the <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md#controller-service-rpc">Controller
Service</a>,
but the <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md#node-service-rpc">Node
Service</a>,
instead. When the
<a href="https://github.com/kubernetes/kubernetes/blob/70132b0f130acc0bed193d9ba59dd186f0e634cf/pkg/volume/csi/csi_mounter.go#L329">kubelet</a>
calls <em>NodePublishVolume</em>, it is the responsibility of the CSI driver to create the
volume during that call, then publish the volume to the specified location. When
the <code>kubelet</code> calls <em>NodeUnpublishVolume</em>, it is the responsibility of the CSI
driver to delete the volume.</p>
<p>To support inline, a driver must implement the followings:</p>
<ul>
<li>Identity service</li>
<li>Node service</li>
</ul>
<h3><a class="header" href="#csi-extension-specification" id="csi-extension-specification">CSI Extension Specification</a></h3>
<h4><a class="header" href="#a-hrefhttpsgithubcomcontainer-storage-interfacespecblobmasterspecmdnodepublishvolumenodepublishvolumea" id="a-hrefhttpsgithubcomcontainer-storage-interfacespecblobmasterspecmdnodepublishvolumenodepublishvolumea"><a href="https://github.com/container-storage-interface/spec/blob/master/spec.md#nodepublishvolume">NodePublishVolume</a></a></h4>
<h5><a class="header" href="#arguments" id="arguments">Arguments</a></h5>
<ul>
<li><strong><code>volume_id</code></strong>: Volume ID will be created by the Kubernetes and passed to the
driver by the kubelet.</li>
<li><strong><code>volume_context[&quot;csi.storage.k8s.io/ephemeral&quot;]</code></strong>: This value will be
available and it will be equal to <code>&quot;true&quot;</code>.</li>
</ul>
<h5><a class="header" href="#workflow" id="workflow">Workflow</a></h5>
<p>The driver will receive the appropriate arguments as defined above when an
ephemeral volume is requested. The driver will create and publish the volume
to the specified location as noted in the <em>NodePublishVolume</em> request. Volume
size and any other parameters required will be passed in verbatim from the
inline manifest parameters to the <code>NodePublishVolumeRequest.volume_context</code>.</p>
<p>There is no guarantee that NodePublishVolume will be called again after a
failure, regardless of what the failure is. To avoid leaking resources, a CSI
driver must either always free all resources before returning from
NodePublishVolume on error or implement some kind of garbage collection.</p>
<h4><a class="header" href="#a-hrefhttpsgithubcomcontainer-storage-interfacespecblobmasterspecmdnodeunpublishvolumenodeunpublishvolumea" id="a-hrefhttpsgithubcomcontainer-storage-interfacespecblobmasterspecmdnodeunpublishvolumenodeunpublishvolumea"><a href="https://github.com/container-storage-interface/spec/blob/master/spec.md#nodeunpublishvolume">NodeUnpublishVolume</a></a></h4>
<h5><a class="header" href="#arguments-1" id="arguments-1">Arguments</a></h5>
<p>No changes</p>
<h5><a class="header" href="#workflow-1" id="workflow-1">Workflow</a></h5>
<p>The driver is responsible of deleting the ephemeral volume once it has
unpublished the volume. It MAY delete the volume before finishing the request,
or after the request to unpublish is returned.</p>
<h3><a class="header" href="#read-only-volumes" id="read-only-volumes">Read-Only Volumes</a></h3>
<p>It is possible for a CSI driver to provide volumes to Pods as read-only while allowing them to be writeable on the node for kubelet, the driver, and the container runtime. This allows the CSI driver to dynamically update contents of the volume without exposing issues like <a href="https://github.com/kubernetes/kubernetes/issues/60814">CVE-2017-1002102</a>, since the volume is read-only for the end user. It also allows the <code>fsGroup</code> and SELinux context of files to be applied on the node so the Pod gets the volume with the expected permissions and SELinux label.</p>
<p>To benefit from this behavior, the following can be implemented in the CSI driver:</p>
<ul>
<li>The driver provides an admission plugin that sets <code>ReadOnly: true</code> to all volumeMounts of such volumes. We can't trust that this will be done by every user on every pod.</li>
<li>The driver checks that the <code>readonly</code> flag is set in all NodePublish requests. We can't trust that the admission plugin above is deployed on every cluster.</li>
<li>When both conditions above are satisfied, the driver MAY ignore the <code>readonly</code> flag in <a href="https://github.com/container-storage-interface/spec/blob/5b0d4540158a260cb3347ef1c87ede8600afb9bf/csi.proto#L1375">NodePublish</a> and set up the volume as read-write. Ignoring the <code>readonly</code> flag in NodePublish is considered valid CSI driver behavior for inline ephemeral volumes.</li>
</ul>
<p>The presence of <code>ReadOnly: true</code> in the Pod spec tells kubelet to bind-mount the volume to the container as read-only, while the underlying mount is read-write on the host. This is the same behavior used for projected volumes like Secrets and ConfigMaps.</p>
<h3><a class="header" href="#csidriver" id="csidriver">CSIDriver</a></h3>
<p>Kubernetes only allows using a CSI driver for an inline volume if
its <a href="csi-driver-object.html"><code>CSIDriver</code></a> object explicitly declares
that the driver supports that kind of usage in its
<code>volumeLifecycleModes</code> field. This is a safeguard against accidentally
<a href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-storage/596-csi-inline-volumes#support-for-inline-csi-volumes">using a driver the wrong way</a>.</p>
<h2><a class="header" href="#references" id="references">References</a></h2>
<ul>
<li><a href="https://github.com/kubernetes-csi/csi-driver-host-path/blob/9fdddc2061b9013286e01189b2bf3268276af99b/pkg/hostpath/nodeserver.go#L63-L82">CSI Host Path
driver ephemeral volumes support</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/issues/82507">Issue 82507: Drop VolumeLifecycleModes field from CSIDriver API before
GA</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/issues/75222">Issue 75222: CSI Inline - Update CSIDriver to indicate driver
mode</a></li>
<li><a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#csidriver-v1-storage-k8s-io">CSIDriver support for ephemeral volumes</a></li>
<li><a href="https://github.com/kubernetes-csi/csi-driver-host-path">CSI Hostpath driver</a> - an example driver that supports both modes and determines the mode on a case-by-case basis (for Kubernetes 1.16) or can be deployed with support for just one of the two modes (for Kubernetes 1.15).</li>
<li><a href="https://github.com/kubernetes-csi/csi-driver-image-populator">Image populator plugin</a> - an example CSI driver plugin that uses a container image as a volume.</li>
</ul>
<h1><a class="header" href="#volume-limits" id="volume-limits">Volume Limits</a></h1>
<h2><a class="header" href="#status-9" id="status-9">Status</a></h2>
<table><thead><tr><th>Status</th><th>Min K8s Version</th><th>Max K8s Version</th></tr></thead><tbody>
<tr><td>Alpha</td><td>1.11</td><td>1.11</td></tr>
<tr><td>Beta</td><td>1.12</td><td>1.16</td></tr>
<tr><td>GA</td><td>1.17</td><td>-</td></tr>
</tbody></table>
<h2><a class="header" href="#overview-9" id="overview-9">Overview</a></h2>
<p>Some storage providers may have a restriction on the number of volumes that can be used in a Node. This is common in cloud providers, but other providers might impose restriction as well.</p>
<p>Kubernetes will respect this limit as long the CSI driver advertises it. To support volume limits in a CSI driver, the plugin must fill in <code>max_volumes_per_node</code> in <code>NodeGetInfoResponse</code>.</p>
<p>It is recommended that CSI drivers allow for customization of volume limits. That way cluster administrators can distribute the limits of the same storage backends (e.g. iSCSI) accross different drivers, according to their individual needs.</p>
<h1><a class="header" href="#storage-capacity-tracking" id="storage-capacity-tracking">Storage Capacity Tracking</a></h1>
<h2><a class="header" href="#status-10" id="status-10">Status</a></h2>
<table><thead><tr><th>Status</th><th>Min K8s Version</th><th>Max K8s Version</th></tr></thead><tbody>
<tr><td>Alpha</td><td>1.19</td><td>-</td></tr>
</tbody></table>
<h2><a class="header" href="#overview-10" id="overview-10">Overview</a></h2>
<p>Storage capacity tracking allows the Kubernetes scheduler to make more
informed choices about where to start pods which depend on unbound
volumes with late binding (aka &quot;wait for first consumer&quot;). Without
storage capacity tracking, a node is chosen without knowing whether
those volumes can be made available for the node. Volume creation is
attempted and if that fails, the pod has to be rescheduled,
potentially landing on the same node again. With storage capacity
tracking, the scheduler filters out nodes which do not have enough
capacity.</p>
<blockquote>
<p>For design information, see the <a href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-storage/1472-storage-capacity-tracking">enhancement
proposal</a>.</p>
</blockquote>
<h2><a class="header" href="#usage-11" id="usage-11">Usage</a></h2>
<p>To support rescheduling of a pod, a CSI driver deployment must:</p>
<ul>
<li>return the <code>ResourceExhausted</code> gRPC status code in <code>CreateVolume</code> if
capacity is exhausted</li>
<li>use external-provisioner &gt;= 1.6.0 because older releases did not
properly support rescheduling after a <code>ResourceExhausted</code> error</li>
</ul>
<p>To support storage capacity tracking, a CSI driver deployment must:</p>
<ul>
<li>implement the <code>GetCapacity</code> call</li>
<li>use external-provisioner &gt;= 2.0.0</li>
<li>enable producing of storage capacity objects as explained in the
<a href="https://github.com/kubernetes-csi/external-provisioner/tree/release-2.0#capacity-support">external-provisioner
documentation</a></li>
<li>enable usage of that information by setting the
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#csidriverspec-v1-storage-k8s-io"><code>CSIDriverSpec.StorageCapacity</code></a>
field to <code>True</code></li>
<li>run on a cluster where the storage capacity API is
<a href="https://kubernetes.io/docs/concepts/storage/storage-capacity/#enabling-storage-capacity-tracking">enabled</a></li>
</ul>
<blockquote>
<p>Further information can be found in the <a href="https://kubernetes.io/docs/concepts/storage/storage-capacity/">Kubernetes
documentation</a>.</p>
</blockquote>
<h1><a class="header" href="#volume-health-monitoring-feature" id="volume-health-monitoring-feature">Volume Health Monitoring Feature</a></h1>
<h2><a class="header" href="#status-11" id="status-11">Status</a></h2>
<table><thead><tr><th>Status</th><th>CSI external-health-monitor-controller sidecar Version</th><th>CSI external-health-monitor-agent sidecar Version</th></tr></thead><tbody>
<tr><td>Alpha</td><td>0.1.0</td><td>0.1.0</td></tr>
</tbody></table>
<h2><a class="header" href="#overview-11" id="overview-11">Overview</a></h2>
<p>The External Health Monitor is part of Kubernetes implementation of <a href="https://github.com/container-storage-interface/spec">Container Storage Interface (CSI)</a>. It was introduced as an Alpha feature in Kubernetes v1.19.</p>
<p>The <a href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-storage/1432-volume-health-monitor">External Health Monitor</a> is implemented as two components: <code>External Health Monitor Controller</code> and <code>External Health Monitor Agent</code>.</p>
<ul>
<li>
<p>External Health Monitor Controller:</p>
<ul>
<li>The external health monitor controller will be deployed as a sidecar together with the CSI controller driver, similar to how the external-provisioner sidecar is deployed.</li>
<li>Trigger controller RPC to check the health condition of the CSI volumes.</li>
<li>The external controller sidecar will also watch for node failure events. This component can be enabled by setting the <code>enable-node-watcher</code> flag to <code>true</code>. This will only have effects on local PVs now. When a node failure event is detected, an event will be reported on the PVC to indicate that pods using this PVC are on a failed node.</li>
</ul>
</li>
<li>
<p>External Health Monitor Agent:</p>
<ul>
<li>The external health monitor agent will be deployed as a sidecar together with the CSI node driver on every Kubernetes worker node.</li>
<li>Trigger node RPC to check volume's mounting conditions.</li>
</ul>
</li>
</ul>
<p>The External Health Monitor needs to invoke the following CSI interfaces</p>
<ul>
<li>External Health Monitor Controller:
<ul>
<li>ListVolumes</li>
<li>ControllerGetVolume</li>
</ul>
</li>
<li>External Health Monitor Agent:
<ul>
<li>NodeGetVolumeStats</li>
</ul>
</li>
</ul>
<p>The External Health Monitor Controller calls either <code>ListVolumes</code> or <code>ControllerGetVolume</code> CSI RPC and reports <code>VolumeConditionAbnormal</code> events with messages on PVCs if abnormal volume conditions are detected.</p>
<p>The External Health Monitor Agent calls <code>NodeGetVolumeStats</code> CSI RPC and reports <code>VolumeConditionAbnormal</code> events with messages on Pods if abnormal volume conditions are detected.</p>
<p>See <a href="external-health-monitor-controller.html">external-health-monitor-controller.md</a> for more details on the CSI <code>external-health-monitor-controller</code> sidecar.</p>
<p>See <a href="external-health-monitor-agent.html">external-health-monitor-agent.md</a> for more details on the CSI <code>external-health-monitor-agent</code> sidecar.</p>
<h1><a class="header" href="#token-requests" id="token-requests">Token Requests</a></h1>
<h2><a class="header" href="#status-12" id="status-12">Status</a></h2>
<table><thead><tr><th>Status</th><th>Min K8s Version</th><th>Max K8s Version</th></tr></thead><tbody>
<tr><td>Alpha</td><td>1.20</td><td>1.20</td></tr>
<tr><td>Beta</td><td>1.21</td><td>1.21</td></tr>
<tr><td>GA</td><td>1.22</td><td>-</td></tr>
</tbody></table>
<h2><a class="header" href="#overview-12" id="overview-12">Overview</a></h2>
<p>This feature allows CSI drivers to impersonate the pods that they mount the
volumes for. This improves the security posture in the mounting process where
the volumes are ACLed on the pods service account without handing out
unnecessary permissions to the CSI drivers service account.
This feature is especially important for secret-handling CSI drivers, such as
the secrets-store-csi-driver. Since these tokens can be rotated and short-lived,
this feature also provides a knob for CSI drivers to receive NodePublishVolume
RPC calls periodically with the new token. This knob is also useful when volumes
are short-lived, e.g. certificates.</p>
<blockquote>
<p>See more details at the <a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-storage/1855-csi-driver-service-account-token/README.md">design document</a>.</p>
</blockquote>
<h2><a class="header" href="#usage-12" id="usage-12">Usage</a></h2>
<p>This feature adds two fields in <code>CSIDriver</code> spec:</p>
<pre><code class="language-go">type CSIDriverSpec struct {
    ... // existing fields

    RequiresRepublish *bool
    TokenRequests []TokenRequest
}

type TokenRequest struct {
    Audience string
    ExpirationSeconds *int64
}
</code></pre>
<ul>
<li>
<p><strong><code>TokenRequest.Audience</code></strong>:</p>
<ul>
<li>This is a required field.</li>
<li>Audiences should be distinct, otherwise the validation will fail.</li>
<li>If it is empty string, the audience of the token is the <code>APIAudiences</code> of kube-apiserver.
one of the audiences specified.</li>
<li>See more about audience specification <a href="https://tools.ietf.org/html/rfc7519#section-4.1.3">here</a></li>
</ul>
</li>
<li>
<p><strong><code>TokenRequest.ExpirationSeconds</code></strong>:</p>
<ul>
<li>The field is optional.</li>
<li>It has to be at least 10 minutes (600 seconds) and no more than <code>1 &lt;&lt; 32</code> seconds.</li>
</ul>
</li>
<li>
<p><strong><code>RequiresRepublish</code></strong>:</p>
<ul>
<li>This field is optional.</li>
<li>If this is true, <code>NodePublishVolume</code> will be periodically called. When used
with <code>TokenRequest</code>, the token will be refreshed if it expired.
<code>NodePublishVolume</code> should only change the contents rather than the
mount because container will not be restarted to reflect the mount
change. The period between <code>NodePublishVolume</code> is 0.1s.</li>
</ul>
</li>
</ul>
<p>The token will be bounded to the pod that the CSI driver is mounting volumes for
and will be set in <code>VolumeContext</code>:</p>
<pre><code class="language-go">&quot;csi.storage.k8s.io/serviceAccount.tokens&quot;: {
  &lt;audience&gt;: {
    'token': &lt;token&gt;,
    'expirationTimestamp': &lt;expiration timestamp in RFC3339 format&gt;,
  },
  ...
}
</code></pre>
<p>If CSI driver doesn't find token recorded in the <code>volume_context</code>, it should return error in <code>NodePublishVolume</code> to inform Kubelet to retry.</p>
<h3><a class="header" href="#example" id="example">Example</a></h3>
<p>Here is an example of a <code>CSIDriver</code> object:</p>
<pre><code class="language-yaml">apiVersion: storage.k8s.io/v1
kind: CSIDriver
metadata:
  name: mycsidriver.example.com
spec:
  tokenRequests:
    - audience: &quot;gcp&quot;
    - audience: &quot;&quot;
      expirationSeconds: 3600
  requiresRepublish: true
</code></pre>
<h3><a class="header" href="#feature-gate" id="feature-gate">Feature gate</a></h3>
<p>Kube apiserver must start with the <code>CSIServiceAccountToken</code> feature gate enabled:</p>
<pre><code>--feature-gates=CSIServiceAccountToken=true
</code></pre>
<p>It is enabled by default in Kubernetes 1.21 and cannot be disabled since 1.22.</p>
<h3><a class="header" href="#example-csi-drivers" id="example-csi-drivers">Example CSI Drivers</a></h3>
<ul>
<li><a href="https://github.com/kubernetes-sigs/secrets-store-csi-driver">secrets-store-csi-driver</a>
<ul>
<li>With <a href="https://github.com/GoogleCloudPlatform/secrets-store-csi-driver-provider-gcp">GCP</a>,
the driver will pass the token to GCP provider to exchange for GCP credentials, and then request
secrets from Secret Manager.</li>
<li>With <a href="https://github.com/hashicorp/secrets-store-csi-driver-provider-vault">Vault</a>,
the Vault provider will send the token to Vault which will use the token in
<code>TokenReview</code> request to authenticate.</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#csi-driver-fsgroup-support" id="csi-driver-fsgroup-support">CSI Driver fsGroup Support</a></h1>
<p>There are two features related to supporting <code>fsGroup</code> for the CSI driver: CSI volume fsGroup policy and delegating fsGroup to CSI driver. For more information about using <code>fsGroup</code> in Kubernetes, please refer to the <a href="https://kubernetes.io/docs/tasks/configure-pod-container/security-context/">Kubernetes documentation on Pod security context</a>.</p>
<h2><a class="header" href="#csi-volume-fsgroup-policy" id="csi-volume-fsgroup-policy">CSI Volume fsGroup Policy</a></h2>
<h3><a class="header" href="#status-13" id="status-13">Status</a></h3>
<table><thead><tr><th>Status</th><th>Min K8s Version</th><th>Max K8s Version</th></tr></thead><tbody>
<tr><td>Alpha</td><td>1.19</td><td>1.19</td></tr>
<tr><td>Beta</td><td>1.20</td><td>1.22</td></tr>
<tr><td>GA</td><td>1.23</td><td>-</td></tr>
</tbody></table>
<h3><a class="header" href="#overview-13" id="overview-13">Overview</a></h3>
<p>CSI Drivers can indicate whether or not they support modifying a volume's ownership or permissions when the volume is being mounted. This can be useful if the CSI Driver does not support the operation, or wishes to re-use volumes with constantly changing permissions.</p>
<blockquote>
<p>See the <a href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-storage/1682-csi-driver-skip-permission">design document</a> for further information.</p>
</blockquote>
<h3><a class="header" href="#example-usage" id="example-usage">Example Usage</a></h3>
<p>When creating the CSI Driver object, <code>fsGroupPolicy</code> is defined in the driver's spec. The following shows the hostpath driver with <code>None</code> included, indicating that the volumes should not be modified when mounted:</p>
<pre><code class="language-yaml">apiVersion: storage.k8s.io/v1
kind: CSIDriver
metadata:
  name: hostpath.csi.k8s.io
spec:
  # Supports persistent and ephemeral inline volumes.
  volumeLifecycleModes:
  - Persistent
  - Ephemeral
  # To determine at runtime which mode a volume uses, pod info and its
  # &quot;csi.storage.k8s.io/ephemeral&quot; entry are needed.
  podInfoOnMount: true
  fsGroupPolicy: None
</code></pre>
<h4><a class="header" href="#supported-modes" id="supported-modes">Supported Modes</a></h4>
<ul>
<li>The following modes are supported:
<ul>
<li><code>None</code>: Indicates that volumes will be mounted with no modifications, as the CSI volume driver does not support these operations.</li>
<li><code>File</code>: Indicates that the CSI volume driver supports volume ownership and permission change via fsGroup, and Kubernetes may use fsGroup to change permissions and ownership of the volume to match user requested fsGroup in the pod's SecurityPolicy regardless of fstype or access mode.</li>
<li><code>ReadWriteOnceWithFSType</code>: Indicates that volumes will be examined to determine if volume ownership and permissions should be modified to match the pod's security policy. 
Changes will only occur if the <code>fsType</code> is defined and the persistent volume's <code>accessModes</code> contains <code>ReadWriteOnce</code>. .</li>
</ul>
</li>
</ul>
<p>If undefined, <code>fsGroupPolicy</code> will default to <code>ReadWriteOnceWithFSType</code>, keeping the previous behavior.</p>
<h4><a class="header" href="#feature-gates" id="feature-gates">Feature Gates</a></h4>
<p>To use this field, Kubernetes 1.19 binaries must start with the <code>CSIVolumeFSGroupPolicy</code> feature gate enabled:</p>
<pre><code>--feature-gates=CSIVolumeFSGroupPolicy=true
</code></pre>
<p>This is enabled by default on 1.20 and higher.</p>
<h2><a class="header" href="#delegate-fsgroup-to-csi-driver" id="delegate-fsgroup-to-csi-driver">Delegate fsGroup to CSI Driver</a></h2>
<h3><a class="header" href="#status-14" id="status-14">Status</a></h3>
<table><thead><tr><th>Status</th><th>Min K8s Version</th><th>Max K8s Version</th></tr></thead><tbody>
<tr><td>Alpha</td><td>1.22</td><td>1.22</td></tr>
<tr><td>Beta</td><td>1.23</td><td>-</td></tr>
<tr><td>GA</td><td>-</td><td>-</td></tr>
</tbody></table>
<h3><a class="header" href="#overview-14" id="overview-14">Overview</a></h3>
<p>For most drivers, kubelet applies the <code>fsGroup</code> specified in a Pod spec by recursively changing volume ownership during the mount process. This does not work for certain drivers. For example:</p>
<ul>
<li>A driver requires passing <code>fsGroup</code> to mount options in order for it to take effect.</li>
<li>A driver needs to apply <code>fsGroup</code> at the stage step (<code>NodeStageVolume</code> in CSI; <code>MountDevice</code> in Kubernetes) instead of the mount step (<code>NodePublishVolume</code> in CSI; <code>SetUp/SetUpAt</code> in Kubernetes).</li>
</ul>
<p>This feature provides a mechanism for the driver to apply <code>fsGroup</code> instead of kubelet. Specifically, once the feature is enabled, it passes <code>fsGroup</code> to the CSI driver through <code>NodeStageVolume</code> and <code>NodePublishVolume</code> calls, and the kubelet <code>fsGroup</code> logic is disabled. The driver is expected to apply the <code>fsGroup</code> within one of these calls.</p>
<p>If this feature is enabled in Kubernetes and a volume uses a driver that supports this feature, <code>CSIDriver.spec.fsGroupPolicy</code> and <code>Pod.spec.securityContext.fsGroupChangePolicy</code> are ignored.</p>
<blockquote>
<p>See the <a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-storage/2317-fsgroup-on-mount/README.md">design document</a> and the description of the <code>VolumeCapability.MountVolume.volume_mount_group</code> field in the <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md#createvolume">CSI spec</a> for further information.</p>
</blockquote>
<h3><a class="header" href="#usage-13" id="usage-13">Usage</a></h3>
<p>The CSI driver must implement the <code>VOLUME_MOUNT_GROUP</code> node service capability. The Pod-specified <code>fsGroup</code> will be available in <code>NodeStageVolumeRequest</code> and <code>NodePublishVolumeRequest</code> via <code>VolumeCapability.MountVolume.VolumeMountGroup</code>.</p>
<h4><a class="header" href="#feature-gates-1" id="feature-gates-1">Feature Gates</a></h4>
<p>To use this field, Kubernetes 1.22 binaries must start with the <code>DelegateFSGroupToCSIDriver</code> feature gate enabled:</p>
<pre><code>--feature-gates=DelegateFSGroupToCSIDriver=true
</code></pre>
<p>This is enabled by default on 1.23 and higher.</p>
<h1><a class="header" href="#csi-windows-support" id="csi-windows-support">CSI Windows Support</a></h1>
<h2><a class="header" href="#status-15" id="status-15">Status</a></h2>
<table><thead><tr><th>Status</th><th>Min K8s Version</th><th>Min CSI proxy Version</th><th>Min Node Driver Registrar Version</th></tr></thead><tbody>
<tr><td>GA</td><td>1.19</td><td>1.0.0</td><td>1.3.0</td></tr>
<tr><td>Beta</td><td>1.19</td><td>0.2.0</td><td>1.3.0</td></tr>
<tr><td>Alpha</td><td>1.18</td><td>0.1.0</td><td>1.3.0</td></tr>
</tbody></table>
<h2><a class="header" href="#overview-15" id="overview-15">Overview</a></h2>
<p>CSI drivers (e.g. AzureDisk, GCE PD, etc.) are recommended to be deployed as containers. CSI drivers node plugin typically runs on every worker node in the cluster (as a DaemonSet). Node plugin containers need to run with elevated privileges to perform storage related operations. However, Windows was not supporting privileged containers (Note: privileged containers a.k.a Host process is introduced as alpha feature in Kubernetes 1.22 very recently). To solve this problem, <a href="https://github.com/kubernetes-csi/csi-proxy">CSI Proxy</a> is a binary that runs on the Windows host and executes a set of privileged storage operations on Windows nodes on behalf of containers in a CSI Node plugin daemonset. This enables multiple CSI Node plugins to execute privileged storage operations on Windows nodes without having to ship a custom privileged operation proxy.</p>
<p>Please note that CSI controller level operations/sidecars are not supported on Windows.</p>
<h2><a class="header" href="#how-to-use-the-csi-proxy-for-windows" id="how-to-use-the-csi-proxy-for-windows">How to use the CSI Proxy for Windows?</a></h2>
<p>See how to install CSI Proxy in [csi-proxy.md#Deployment]</p>
<p>For CSI driver authors, import CSI proxy client under github.com/kubernetes-csi/csi-proxy/client. There are six client API groups including disk, filesystem, iscsi, smb, system, volume. See <a href="https://github.com/kubernetes-csi/csi-proxy/tree/master/client/groups">link</a> for details.
As an example, please check how GCE PD Driver import disk, volume and filesystem client API groups <a href="https://github.com/kubernetes-sigs/gcp-compute-persistent-disk-csi-driver/blob/release-1.2/pkg/mount-manager/safe-mounter_windows.go#L28">here</a></p>
<p>The Daemonset specification of a CSI node plugin for Windows can mount the desired named pipes from CSI Proxy based on the version of the API groups that the node-plugin needs to execute.</p>
<p>The following Daemonset YAML shows how to mount various API groups from CSI Proxy into a CSI Node plugin:</p>
<pre><code>kind: DaemonSet
apiVersion: apps/v1
metadata:
  name: csi-storage-node-win
spec:
  selector:
    matchLabels:
      app: csi-driver-win
  template:
    metadata:
      labels:
        app: csi-driver-win
    spec:
      serviceAccountName: csi-node-sa
      nodeSelector:
        kubernetes.io/os: windows
      containers:
        - name: csi-driver-registrar
          image: k8s.gcr.io/sig-storage/csi-node-driver-registrar
          args:
            - &quot;--v=5&quot;
            - &quot;--csi-address=unix://C:\\csi\\csi.sock&quot;
            - &quot;--kubelet-registration-path=C:\\kubelet\\plugins\\plugin.csi\\csi.sock&quot;
          volumeMounts:
            - name: plugin-dir
              mountPath: C:\csi
            - name: registration-dir
              mountPath: C:\registration
        - name: csi-driver
          image: k8s.gcr.io/sig-storage/csi-driver:win-v1
          args:
            - &quot;--v=5&quot;
            - &quot;--endpoint=unix:/csi/csi.sock&quot;
          volumeMounts:
            - name: kubelet-dir
              mountPath: C:\var\lib\kubelet
            - name: plugin-dir
              mountPath: C:\csi
            - name: csi-proxy-disk-pipe
              mountPath: \\.\pipe\csi-proxy-disk-v1
            - name: csi-proxy-volume-pipe
              mountPath: \\.\pipe\csi-proxy-volume-v1
            - name: csi-proxy-filesystem-pipe
              mountPath: \\.\pipe\csi-proxy-filesystem-v1
      volumes:
        - name: csi-proxy-disk-pipe
          hostPath:
            path: \\.\pipe\csi-proxy-disk-v1
            type: &quot;&quot;
        - name: csi-proxy-volume-pipe
          hostPath:
            path: \\.\pipe\csi-proxy-volume-v1
            type: &quot;&quot;
        - name: csi-proxy-filesystem-pipe
          hostPath:
            path: \\.\pipe\csi-proxy-filesystem-v1
            type: &quot;&quot;
        - name: registration-dir
          hostPath:
            path: C:\var\lib\kubelet\plugins_registry\
            type: Directory
        - name: kubelet-dir
          hostPath:
            path: C:\var\lib\kubelet\
            type: Directory
        - name: plugin-dir
          hostPath:
            path: C:\var\lib\kubelet\plugins\csi.org.io\
            type: DirectoryOrCreate
</code></pre>
<h1><a class="header" href="#prevent-unauthorised-volume-mode-conversion" id="prevent-unauthorised-volume-mode-conversion">Prevent unauthorised volume mode conversion</a></h1>
<h2><a class="header" href="#status-16" id="status-16">Status</a></h2>
<table><thead><tr><th>Status</th><th>Min K8s Version</th><th>Max K8s Version</th><th>external-snapshotter Version</th><th>external-provisioner Version</th></tr></thead><tbody>
<tr><td>Alpha</td><td>1.24</td><td>-</td><td>6.0.1+</td><td>3.2.1+</td></tr>
</tbody></table>
<h2><a class="header" href="#overview-16" id="overview-16">Overview</a></h2>
<p>Malicious users can populate the <code>spec.volumeMode</code> field of a <code>PersistentVolumeClaim</code>
with a <a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#volume-mode">Volume Mode</a>
that differs from the original volume's mode to potentially exploit an as-yet-unknown
vulnerability in the host operating system.
This feature allows cluster administrators to prevent unauthorized users from converting
the mode of a volume when a <code>PersistentVolumeClaim</code> is being created from an existing
<code>VolumeSnapshot</code> instance.</p>
<blockquote>
<p>See the <a href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-storage/3141-prevent-volume-mode-conversion">Kubernetes Enhancement Proposal</a> 
for more details on the background, design and discussions.</p>
</blockquote>
<h2><a class="header" href="#usage-14" id="usage-14">Usage</a></h2>
<p>To enable this feature, cluster administrators must:</p>
<ul>
<li>Create <code>VolumeSnapshot</code> APIs with a minimum version of <a href="https://github.com/kubernetes-csi/external-snapshotter/releases/tag/client%2Fv6.0.1"><code>v6.0.1</code></a>.</li>
<li>Use <code>snapshot-controller</code> and <code>snapshot-validation-webhook</code> with a minimum version of <code>v6.0.1</code>.</li>
<li>Use <code>external-provisioner</code> with a minimum version of <a href="https://github.com/kubernetes-csi/external-provisioner/releases/tag/v3.2.1"><code>v3.2.1</code></a>.</li>
<li>Set <code>--prevent-volume-mode-conversion=true</code> flag in <code>snapshot-controller</code>, <code>snapshot-validation-webhook</code> and <code>external-provisioner</code>.</li>
</ul>
<blockquote>
<p>For more information about how to use the feature, visit the <a href="https://kubernetes.io/blog/2022/05/18/prevent-unauthorised-volume-mode-conversion-alpha/">Kubernetes blog</a> page. </p>
</blockquote>
<h1><a class="header" href="#deploying-csi-driver-on-kubernetes" id="deploying-csi-driver-on-kubernetes">Deploying CSI Driver on Kubernetes</a></h1>
<p>This page describes to CSI driver developers how to deploy their driver onto a Kubernetes cluster.</p>
<h2><a class="header" href="#overview-17" id="overview-17">Overview</a></h2>
<p>A CSI driver is typically deployed in Kubernetes as two components:
a controller component and a per-node component.</p>
<h3><a class="header" href="#controller-plugin" id="controller-plugin">Controller Plugin</a></h3>
<p>The controller component can be deployed as a Deployment or StatefulSet on
any node in the cluster. It consists of the CSI driver that implements the
CSI Controller service and one or more
<a href="sidecar-containers.html">sidecar containers</a>. These controller
sidecar containers typically interact with Kubernetes objects and make calls
to the driver's CSI Controller service.</p>
<p>It generally does not need direct access to the host and can perform all its
operations through the Kubernetes API and external control plane services.
Multiple copies of the controller component can be deployed for HA, however
it is recommended to use leader election to ensure there is only one active
controller at a time.</p>
<p>Controller sidecars include the external-provisioner, external-attacher,
external-snapshotter, and external-resizer. Including a sidecar in the
deployment may be optional.  See each sidecar's page for more details.</p>
<h4><a class="header" href="#communication-with-sidecars" id="communication-with-sidecars">Communication with Sidecars</a></h4>
<p><a href="https://docs.google.com/a/greatdanedata.com/drawings/d/1JExJ_98dt0NAsJ7iI0_9loeTn2rbLeEcpOMEvKrF-9w/edit?usp=sharing"><img src="images/sidecar-container.png" alt="sidecar-container" /></a></p>
<p>Sidecar containers manage Kubernetes events and make the appropriate
calls to the CSI driver. The calls are made by sharing a UNIX domain socket
through an emptyDir volume between the sidecars and CSI Driver.</p>
<h4><a class="header" href="#rbac-rules" id="rbac-rules">RBAC Rules</a></h4>
<p>Most controller sidecars interact with Kubernetes objects and therefore need
to set RBAC policies. Each sidecar repository contains example RBAC
configurations.</p>
<h3><a class="header" href="#node-plugin" id="node-plugin">Node Plugin</a></h3>
<p>The node component should be deployed on every node in the cluster through a
DaemonSet. It consists of the CSI driver that implements the CSI Node service and the
<a href="node-driver-registrar">node-driver-registrar</a> sidecar container.</p>
<h4><a class="header" href="#communication-with-kubelet" id="communication-with-kubelet">Communication with Kubelet</a></h4>
<p><a href="https://docs.google.com/a/greatdanedata.com/drawings/d/1NXaVNDh3mSDhog7Q3Y9eELyEF24F8Z-Kk0ujR3pyOes/edit?usp=sharing"><img src="images/kubelet.png" alt="kubelet" /></a></p>
<p>The Kubernetes kubelet runs on every node and is responsible for making the CSI
Node service calls. These calls mount and unmount the storage volume from the
storage system, making it available to the Pod to consume. Kubelet makes calls
to the CSI driver through a UNIX domain socket shared on the host via a HostPath
volume. There is also a second UNIX domain socket that the node-driver-registrar
uses to register the CSI driver to kubelet.</p>
<h4><a class="header" href="#driver-volume-mounts" id="driver-volume-mounts">Driver Volume Mounts</a></h4>
<p>The node plugin needs direct access to the host for making block devices and/or
filesystem mounts available to the Kubernetes kubelet.</p>
<p>The mount point used by the CSI driver must be set to <em>Bidirectional</em> to allow Kubelet
on the host to see mounts created by the CSI driver container. See the example below:</p>
<pre><code class="language-yaml">      containers:
      - name: my-csi-driver
        ...
        volumeMounts:
        - name: socket-dir
          mountPath: /csi
        - name: mountpoint-dir
          mountPath: /var/lib/kubelet/pods
          mountPropagation: &quot;Bidirectional&quot;
      - name: node-driver-registrar
        ...
        volumeMounts:
        - name: registration-dir
          mountPath: /registration
      volumes:
      # This volume is where the socket for kubelet-&gt;driver communication is done
      - name: socket-dir
        hostPath:
          path: /var/lib/kubelet/plugins/&lt;driver-name&gt;
          type: DirectoryOrCreate
      # This volume is where the driver mounts volumes
      - name: mountpoint-dir
        hostPath:
          path: /var/lib/kubelet/pods
          type: Directory
      # This volume is where the node-driver-registrar registers the plugin
      # with kubelet
      - name: registration-dir
        hostPath:
          path: /var/lib/kubelet/plugins_registry
          type: Directory
</code></pre>
<h2><a class="header" href="#deploying" id="deploying">Deploying</a></h2>
<p>Deploying a CSI driver onto Kubernetes is highlighted in detail in <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md#recommended-mechanism-for-deploying-csi-drivers-on-kubernetes"><em>Recommended Mechanism for Deploying CSI Drivers on Kubernetes</em></a>. </p>
<h2><a class="header" href="#enable-privileged-pods" id="enable-privileged-pods">Enable privileged Pods</a></h2>
<p>To use CSI drivers, your Kubernetes cluster must allow privileged pods (i.e. <code>--allow-privileged</code> flag must be set to <code>true</code> for both the API server and the kubelet). This is the default in some environments (e.g. GCE, GKE, <code>kubeadm</code>).</p>
<p>Ensure your API server are started with the privileged flag:</p>
<pre><code class="language-shell">$ ./kube-apiserver ...  --allow-privileged=true ...
</code></pre>
<pre><code class="language-shell">$ ./kubelet ...  --allow-privileged=true ...
</code></pre>
<blockquote>
<p>Note: Starting from Kubernetes 1.13.0, --allow-privileged is true for kubelet. It'll be deprecated in future kubernetes releases.</p>
</blockquote>
<h2><a class="header" href="#enabling-mount-propagation" id="enabling-mount-propagation">Enabling mount propagation</a></h2>
<p>Another feature that CSI depends on is mount propagation.  It allows the sharing of volumes mounted by one container with other containers in the same pod, or even to other pods on the same node.  For mount propagation to work, the Docker daemon for the cluster must allow shared mounts. See the <a href="https://kubernetes.io/docs/concepts/storage/volumes/#mount-propagation">mount propagation docs</a> to find out how to enable this feature for your cluster.  <a href="https://kubernetes.io/docs/concepts/storage/volumes/#configuration">This page</a> explains how to check if shared mounts are enabled and how to configure Docker for shared mounts.</p>
<h3><a class="header" href="#examples-2" id="examples-2">Examples</a></h3>
<ul>
<li>Simple deployment example using a single pod for all components: see the <a href="example.html">hostpath example</a>.</li>
<li>Full deployment example using a <em>DaemonSet</em> for the node plugin and <em>StatefulSet</em> for the controller plugin: TODO</li>
</ul>
<h2><a class="header" href="#more-information" id="more-information">More information</a></h2>
<p>For more information, please read <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md"><em>CSI Volume Plugins in Kubernetes Design Doc</em></a>.</p>
<h1><a class="header" href="#example-1" id="example-1">Example</a></h1>
<p>The <a href="https://github.com/kubernetes-csi/csi-driver-host-path">Hostpath CSI driver</a> is a simple sample driver that provisions a directory on the host. It can be used as an example to get started writing a driver, however it is not meant for production use.
The <a href="https://github.com/kubernetes-csi/csi-driver-host-path#deployment">deployment example</a> shows how to deploy and use that driver in Kubernetes.</p>
<p>The example deployment uses the original RBAC rule files that are maintained together with sidecar apps and deploys into the default namespace. A real production should copy the RBAC files and customize them as explained in the comments of those files.</p>
<p>If you encounter any problems, please check the <a href="troubleshooting.html">Troubleshooting page</a>.</p>
<h1><a class="header" href="#testing" id="testing">Testing</a></h1>
<p>This section describes how CSI developers can test their CSI drivers.</p>
<ul>
<li><a href="unit-testing.html">Unit Testing</a></li>
<li><a href="functional-testing.html">Functional Testing</a></li>
</ul>
<h1><a class="header" href="#unit-testing" id="unit-testing">Unit Testing</a></h1>
<p>The <a href="https://github.com/kubernetes-csi/csi-test/tree/master/pkg/sanity">CSI <code>sanity</code></a> package from <a href="https://github.com/kubernetes-csi/csi-test">csi-test</a> can be used for unit testing your CSI driver.</p>
<p>It contains a set of basic tests that all CSI drivers should pass (for example, <code>NodePublishVolume should fail when no volume id is provided</code>, etc.).</p>
<p>This package can be used in two modes:</p>
<ul>
<li>Via a Golang test framework (<code>sanity</code> package is imported as a dependency)</li>
<li>Via a command line against your driver binary.</li>
</ul>
<p>Read the <a href="https://github.com/kubernetes-csi/csi-test/blob/master/pkg/sanity/README.md">documentation of the <code>sanity</code> package</a> for more details.</p>
<h1><a class="header" href="#functional-testing" id="functional-testing">Functional Testing</a></h1>
<p>Drivers should be functionally &quot;end-to-end&quot; tested while deployed in a Kubernetes cluster. Previously, how to do this and what tests to run was left up to driver authors. Now, a standard set of Kubernetes CSI end-to-end tests can be imported and run by third party CSI drivers. This documentation specifies how to do so.</p>
<p>The CSI community is also looking in to establishing an official &quot;CSI Conformance Suite&quot; to recognize &quot;officially certified CSI drivers&quot;.  This documentation will be updated with more information once that process has been defined.</p>
<h1><a class="header" href="#kubernetes-end-to-end-testing-for-csi-storage-plugins" id="kubernetes-end-to-end-testing-for-csi-storage-plugins">Kubernetes End to End Testing for CSI Storage Plugins</a></h1>
<p>Currently, <a href="https://github.com/kubernetes-csi/csi-test/tree/master/cmd/csi-sanity">csi-sanity</a> exists to help test compliance with the CSI spec, but e2e testing of plugins is needed as well to provide plugin authors and users validation that their plugin is integrated well with specific versions of Kubernetes.</p>
<h2><a class="header" href="#setting-up-end-to-end-tests-for-your-csi-plugin" id="setting-up-end-to-end-tests-for-your-csi-plugin">Setting up End to End tests for your CSI Plugin</a></h2>
<h3><a class="header" href="#prerequisites" id="prerequisites">Prerequisites:</a></h3>
<ul>
<li>A Kubernetes v1.13+ Cluster</li>
<li><a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl">Kubectl</a></li>
</ul>
<p>There are two ways to run end-to-end tests for your CSI Plugin</p>
<ol>
<li>use <a href="https://github.com/kubernetes/kubernetes/tree/master/test/e2e/storage/external">Kubernetes E2E Tests</a>, by providing a DriverDefinition YAML file via a parameter. </li>
</ol>
<ul>
<li><strong>Note</strong>: In some cases you would not be able to use this method, in running e2e tests by just providing a YAML file defining your CSI plugin. For example the <a href="https://github.com/kubernetes-csi/csi-driver-nfs">NFS CSI plugin</a> currently does not support dynamic provisioning, so we would want to skip those and run only pre-provisioned tests. For such cases, you would need to write your own testdriver, which is discussed below. </li>
</ul>
<ol start="2">
<li>import the in-tree storage tests and run them using <code>go test</code>. </li>
</ol>
<p>This doc will cover how to run the E2E tests using the second method.</p>
<h2><a class="header" href="#importing-the-e2e-test-suite-as-a-library" id="importing-the-e2e-test-suite-as-a-library">Importing the E2E test suite as a library</a></h2>
<p>In-tree storage e2e tests could be used to test CSI storage plugins. Your repo should be setup similar to how the <a href="https://github.com/kubernetes-csi/csi-driver-nfs">NFS CSI plugin</a> is setup, where the testfiles are in a <code>test</code> directory and the main test file is in the <code>cmd</code> directory.</p>
<p>To be able to import Kubernetes in-tree storage tests, the CSI plugin would need to use <strong>Kubernetes v1.14+</strong> (add to plugin's GoPkg.toml, since pluggable E2E tests become available in v1.14). CSI plugin authors would also be required to implement a <a href="https://github.com/kubernetes/kubernetes/blob/6644db9914379a4a7b3d3487b41b2010f226e4dc/test/e2e/storage/testsuites/testdriver.go#L31">testdriver</a> for their CSI plugin. The testdriver provides required functionality that would help setup testcases for a particular plugin. </p>
<p>For any testdriver these functions would be required (Since it implements the <a href="https://github.com/kubernetes/kubernetes/blob/6644db9914379a4a7b3d3487b41b2010f226e4dc/test/e2e/storage/testsuites/testdriver.go#L31">TestDriver Interface</a>):</p>
<ul>
<li><code>GetDriverInfo() *testsuites.DriverInfo</code></li>
<li><code>SkipUnsupportedTest(pattern testpatterns.TestPattern)</code></li>
<li><code>PrepareTest(f *framework.Framework) (*testsuites.PerTestConfig, func())</code> </li>
</ul>
<p>The <code>PrepareTest</code> method is where you would write code to setup your CSI plugin, and it would be called before each test case. It is recommended that you don't deploy your plugin in this method, and rather deploy it manually before running your tests.</p>
<p><code>GetDriverInfo</code> will return a <code>DriverInfo</code> object that has all of the plugin's capabilities and required information. This object helps tests find the deployed plugin, and also decides which tests should run (depending on the plugin's capabilities).</p>
<p>Here are examples of the NFS and Hostpath DriverInfo objects:</p>
<pre><code>testsuites.DriverInfo{
			Name:        &quot;csi-nfsplugin&quot;,
			MaxFileSize: testpatterns.FileSizeLarge,
			SupportedFsType: sets.NewString(
				&quot;&quot;, // Default fsType
			),
			Capabilities: map[testsuites.Capability]bool{
				testsuites.CapPersistence: true,
				testsuites.CapExec:        true,
			},
}
</code></pre>
<pre><code>testsuites.DriverInfo{
			Name:        &quot;csi-hostpath&quot;,
			FeatureTag:  &quot;&quot;,
			MaxFileSize: testpatterns.FileSizeMedium,
			SupportedFsType: sets.NewString(
				&quot;&quot;, // Default fsType
			),
			Capabilities: map[testsuites.Capability]bool{
				testsuites.CapPersistence: true,
			},
}
</code></pre>
<p>You would define something similar for your CSI plugin.</p>
<p><code>SkipUnsupportedTest</code> simply skips any tests that you define there.</p>
<p>Depending on your plugin's specs, you would implement other interfaces defined <a href="https://github.com/kubernetes/kubernetes/blob/6644db9914379a4a7b3d3487b41b2010f226e4dc/test/e2e/storage/testsuites/testdriver.go#L61">here</a>. For example the <a href="https://github.com/kubernetes-csi/csi-driver-nfs/blob/193faa0f2aa92a3be0855764a1126ff3cdcd3e77/test/nfs-testdriver.go#L66">NFS testdriver</a> also implements PreprovisionedVolumeTestDriver and PreprovisionedPVTestDriver interfaces, to enable pre-provisioned tests. </p>
<p>After implementing the testdriver for your CSI plugin, you would create a <code>csi-volumes.go</code> file, where the implemented testdriver is used to run in-tree storage testsuites, <a href="https://github.com/kubernetes-csi/csi-driver-nfs/blob/193faa0f2aa92a3be0855764a1126ff3cdcd3e77/test/csi-volumes.go#L37">similar to how the NFS CSI plugin does so</a>. This is where you would define which testsuites you would want to run for your plugin. All available in-tree testsuites can be found <a href="https://github.com/kubernetes/kubernetes/tree/master/test/e2e/storage/testsuites">here</a>.</p>
<p>Finally, importing the <code>test</code> package into your <a href="https://github.com/kubernetes-csi/csi-driver-nfs/blob/193faa0f2aa92a3be0855764a1126ff3cdcd3e77/cmd/tests/nfs-e2e.go#L18">main test file</a> will <a href="https://github.com/kubernetes-csi/csi-driver-nfs/blob/193faa0f2aa92a3be0855764a1126ff3cdcd3e77/test/csi-volumes.go#L37">initialize the testsuites to run the E2E tests</a>.</p>
<p>The NFS plugin creates a binary to run E2E tests, but you could use <code>go test</code> instead to run E2E tests using a command like this:</p>
<pre><code>go test -v &lt;main test file&gt; -ginkgo.v -ginkgo.progress --kubeconfig=&lt;kubeconfig file&gt; -timeout=0
</code></pre>
<h1><a class="header" href="#drivers" id="drivers">Drivers</a></h1>
<p>The following are a set of CSI driver which can be used with Kubernetes:</p>
<blockquote>
<p>NOTE: If you would like your driver to be added to this table, please open a pull request in <a href="https://github.com/kubernetes-csi/docs/pulls">this repo</a> updating this file. Other Features is allowed to be filled in Raw Block, Snapshot, Expansion, Cloning and Topology. If driver did not implement any Other Features, please leave it blank.</p>
</blockquote>
<blockquote>
<p>DISCLAIMER: Information in this table has not been validated by Kubernetes SIG-Storage. Users who want to use these CSI drivers need to contact driver maintainers for driver capabilities.</p>
</blockquote>
<h2><a class="header" href="#production-drivers" id="production-drivers">Production Drivers</a></h2>
<div class="production_drivers" markdown="1">
<table><thead><tr><th>Name</th><th>CSI Driver Name</th><th>Compatible with CSI Version(s)</th><th>Description</th><th>Persistence (Beyond Pod Lifetime)</th><th>Supported Access Modes</th><th>Dynamic Provisioning</th><th>Other Features</th></tr></thead><tbody>
<tr><td><a href="https://github.com/AliyunContainerService/csi-plugin">Alicloud Disk</a></td><td><code>diskplugin.csi.alibabacloud.com</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for Alicloud Disk</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Snapshot</td></tr>
<tr><td><a href="https://github.com/AliyunContainerService/csi-plugin">Alicloud NAS</a></td><td><code>nasplugin.csi.alibabacloud.com</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for Alicloud Network Attached Storage (NAS)</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>No</td><td></td></tr>
<tr><td><a href="https://github.com/AliyunContainerService/csi-plugin">Alicloud OSS</a></td><td><code>ossplugin.csi.alibabacloud.com</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for Alicloud Object Storage Service (OSS)</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>No</td><td></td></tr>
<tr><td><a href="https://github.com/Alluxio/alluxio/tree/master/integration/docker/csi">Alluxio</a></td><td><code>csi.alluxio.com</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for Alluxio File System)</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/huayun-docs/csi-driver-arstor">ArStor CSI</a></td><td><code>arstor.csi.huayun.io</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for Huayun Storage Service (ArStor)</td><td>Persistent and Ephemeral</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Snapshot, Expansion, Cloning</td></tr>
<tr><td><a href="https://github.com/kubernetes-sigs/aws-ebs-csi-driver">AWS Elastic Block Storage</a></td><td><code>ebs.csi.aws.com</code></td><td>v0.3, v1.0</td><td>A Container Storage Interface (CSI) Driver for AWS Elastic Block Storage (EBS)</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Snapshot, Expansion</td></tr>
<tr><td><a href="https://github.com/aws/aws-efs-csi-driver">AWS Elastic File System</a></td><td><code>efs.csi.aws.com</code></td><td>v0.3, v1.0</td><td>A Container Storage Interface (CSI) Driver for AWS Elastic File System (EFS)</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>No</td><td></td></tr>
<tr><td><a href="https://github.com/aws/aws-fsx-csi-driver">AWS FSx for Lustre</a></td><td><code>fsx.csi.aws.com</code></td><td>v0.3, v1.0</td><td>A Container Storage Interface (CSI) Driver for AWS FSx for Lustre (EBS)</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/kubernetes-sigs/blob-csi-driver">Azure Blob</a></td><td><code>blob.csi.azure.com</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for Azure Blob storage</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Expansion</td></tr>
<tr><td><a href="https://github.com/kubernetes-sigs/azuredisk-csi-driver">Azure Disk</a></td><td><code>disk.csi.azure.com</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for Azure Disk</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Snapshot, Expansion, Cloning, Topology</td></tr>
<tr><td><a href="https://github.com/kubernetes-sigs/azurefile-csi-driver">Azure File</a></td><td><code>file.csi.azure.com</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for Azure File</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Expansion</td></tr>
<tr><td><a href="https://github.com/NetApp/beegfs-csi-driver">BeeGFS</a></td><td><code>beegfs.csi.netapp.com</code></td><td>v1.3</td><td>A Container Storage Interface (CSI) Driver for the <a href="https://www.beegfs.io/">BeeGFS</a> Parallel File System</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/bigtera-ce/ceph-csi">Bigtera VirtualStor (block)</a></td><td><code>csi.block.bigtera.com</code></td><td>v0.3, v1.0.0, v1.1.0</td><td>A Container Storage Interface (CSI) Driver for Bigtera VirtualStor block storage</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Snapshot, Expansion</td></tr>
<tr><td><a href="https://github.com/bigtera-ce/ceph-csi">Bigtera VirtualStor (filesystem)</a></td><td><code>csi.fs.bigtera.com</code></td><td>v0.3, v1.0.0, v1.1.0</td><td>A Container Storage Interface (CSI)  Driver for Bigtera VirtualStor filesystem</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Expansion</td></tr>
<tr><td><a href="https://github.com/bizflycloud/csi-bizflycloud">BizFlyCloud Block Storage</a></td><td><code>volume.csi.bizflycloud.vn</code></td><td>v1.2</td><td>A Container Storage Interface (CSI) Driver for BizFly Cloud block storage</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Snapshot, Expansion</td></tr>
<tr><td><a href="https://github.com/ceph/ceph-csi">CephFS</a></td><td><code>cephfs.csi.ceph.com</code></td><td>v0.3, &gt;=v1.0.0</td><td>A Container Storage Interface (CSI) Driver for CephFS</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Expansion, Snapshot, Cloning</td></tr>
<tr><td><a href="https://github.com/ceph/ceph-csi">Ceph RBD</a></td><td><code>rbd.csi.ceph.com</code></td><td>v0.3, &gt;=v1.0.0</td><td>A Container Storage Interface (CSI)  Driver for Ceph RBD</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Snapshot, Expansion, Topology, Cloning,In-tree plugin migration</td></tr>
<tr><td><a href="https://github.com/ciscohyperflex/csi-plugin">Cisco HyperFlex CSI</a></td><td><code>HX-CSI</code></td><td>v1.2</td><td>A Container Storage Interface (CSI) Driver for Cisco HyperFlex</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Raw Block, Expansion, Cloning</td></tr>
<tr><td><a href="https://github.com/cubefs/cubefs-csi">CubeFS</a></td><td><code>csi.cubefs.com</code></td><td>v1.1.0</td><td>A Container Storage Interface (CSI) Driver for CubeFS Storage</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/kubernetes/cloud-provider-openstack/tree/master/pkg/csi/cinder">Cinder</a></td><td><code>cinder.csi.openstack.org</code></td><td>v0.3, v1.0, v1.1.0, v1.2.0, v1.3.0</td><td>A Container Storage Interface (CSI) Driver for OpenStack Cinder</td><td>Persistent and Ephemeral</td><td>Depends on the storage backend used</td><td>Yes, if storage backend supports it</td><td>Raw Block, Snapshot, Expansion, Cloning, Topology</td></tr>
<tr><td><a href="https://github.com/cloudscale-ch/csi-cloudscale">cloudscale.ch</a></td><td><code>csi.cloudscale.ch</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for the <a href="https://www.cloudscale.ch/">cloudscale.ch</a> IaaS platform</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Snapshot</td></tr>
<tr><td><a href="https://github.com/datatom-infinity/infinity-csi">Datatom-InfinityCSI</a></td><td><code>csi-infiblock-plugin</code></td><td>v0.3, v1.0.0, v1.1.0</td><td>A Container Storage Interface (CSI)  Driver for DATATOM Infinity storage</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Snapshot, Expansion, Topology</td></tr>
<tr><td><a href="https://github.com/datatom-infinity/infinity-csi">Datatom-InfinityCSI (filesystem)</a></td><td><code>csi-infifs-plugin</code></td><td>v0.3, v1.0.0, v1.1.0</td><td>A Container Storage Interface (CSI)  Driver for DATATOM Infinity filesystem storage</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Expansion</td></tr>
<tr><td><a href="https://github.com/Datera/datera-csi">Datera</a></td><td><code>dsp.csi.daterainc.io</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for Datera Data Services Platform (DSP)</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Snapshot</td></tr>
<tr><td><a href="https://github.com/DDNStorage/exa-csi-driver">DDN EXAScaler</a></td><td><code>exa.csi.ddn.com</code></td><td>v1.0, v1.1</td><td>A Container Storage Interface (CSI) Driver for DDN EXAScaler filesystems</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Expansion</td></tr>
<tr><td><a href="https://github.com/dell/csi-powermax">Dell EMC PowerMax</a></td><td><code>csi-powermax.dellemc.com</code></td><td>v1.0, v1.1, v1.2, v1.3, v1.4, v1.5</td><td>A Container Storage Interface (CSI) Driver for <a href="https://www.delltechnologies.com/en-us/storage/powermax.htm">Dell EMC PowerMax</a></td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Snapshot, Expansion, Cloning, Topology</td></tr>
<tr><td><a href="https://github.com/dell/csi-powerscale">Dell EMC PowerScale</a></td><td><code>csi-isilon.dellemc.com</code></td><td>v1.0, v1.1, v1.2, v1.3, v1.4, v1.5</td><td>A Container Storage Interface (CSI) Driver for <a href="https://www.delltechnologies.com/en-us/storage/powerscale.htm">Dell EMC PowerScale</a></td><td>Persistent and Ephemeral</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Snapshot, Expansion, Cloning, Topology</td></tr>
<tr><td><a href="https://github.com/dell/csi-powerstore">Dell EMC PowerStore</a></td><td><code>csi-powerstore.dellemc.com</code></td><td>v1.0, v1.1, v1.2, v1.3, v1.4, v1.5</td><td>A Container Storage Interface (CSI) Driver for <a href="https://www.delltechnologies.com/en-us/storage/powerstore-storage-appliance.htm">Dell EMC PowerStore</a></td><td>Persistent and Ephemeral</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Snapshot, Expansion, Cloning, Topology</td></tr>
<tr><td><a href="https://github.com/dell/csi-unity">Dell EMC Unity</a></td><td><code>csi-unity.dellemc.com</code></td><td>v1.0, v1.1, v1.2, v1.3, v1.4, v1.5</td><td>A Container Storage Interface (CSI) Driver for <a href="https://www.delltechnologies.com/en-us/storage/unity.htm">Dell EMC Unity</a></td><td>Persistent and Ephemeral</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Snapshot, Expansion, Cloning, Topology</td></tr>
<tr><td><a href="https://github.com/dell/csi-vxflexos">Dell EMC VxFlexOS</a></td><td><code>csi-vxflexos.dellemc.com</code></td><td>v1.0, v1.1, v1.2, v1.3, v1.4, v1.5</td><td>A Container Storage Interface (CSI) Driver for <a href="https://www.delltechnologies.com/en-us/hyperconverged-infrastructure/vxflex.htm">Dell EMC VxFlexOS</a></td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Snapshot, Expansion, Cloning, Topology</td></tr>
<tr><td><a href="https://github.com/democratic-csi/democratic-csi">democratic-csi</a></td><td><code>org.democratic-csi.[X]</code></td><td>v1.0,v1.1,v1.2,v1.3,v1.4,v1.5</td><td>Generic CSI plugin supporting zfs based solutions (<a href="https://www.freenas.org/">FreeNAS</a> / <a href="https://www.truenas.com/">TrueNAS</a> and <a href="https://zfsonlinux.org/">ZoL</a> solutions such as <a href="https://ubuntu.com/">Ubuntu</a>), <a href="https://www.synology.com/">Synology</a>, and more</td><td>Persistent and Ephemeral</td><td>Read/Write Single Pod (Block Volume) <br/><br/> Read/Write Multiple Pods (File Volume)</td><td>Yes</td><td>Raw Block, Snapshot, Expansion, Cloning</td></tr>
<tr><td><a href="https://diamanti.com/use-cases/io-acceleration/#csi">Diamanti-CSI</a></td><td><code>dcx.csi.diamanti.com</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for Diamanti DCX Platform</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Snapshot, Expansion</td></tr>
<tr><td><a href="https://github.com/digitalocean/csi-digitalocean">DigitalOcean Block Storage</a></td><td><code>dobs.csi.digitalocean.com</code></td><td>v0.3, v1.0</td><td>A Container Storage Interface (CSI) Driver for DigitalOcean Block Storage</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Snapshot, Expansion</td></tr>
<tr><td><a href="https://github.com/enix/dothill-csi">Dothill-CSI</a></td><td><code>dothill.csi.enix.io</code></td><td>v1.3</td><td>Generic CSI plugin supporting <a href="https://www.seagate.com/fr/fr/support/dothill-san/assuredsan-pro-5000-series/">Seagate AssuredSan</a> appliances such as <a href="https://www.hpe.com/us/en/storage/flash-hybrid.html">HPE MSA</a>, <a href="https://www.dell.com/fr-fr/work/shop/productdetailstxn/powervault-me4-series">Dell EMC PowerVault ME4</a> and others ...</td><td>Persistent</td><td>Read/Write Single Node</td><td>Yes</td><td>Snapshot, Expansion</td></tr>
<tr><td><a href="https://ember-csi.io">Ember CSI</a></td><td><code>[x].ember-csi.io</code></td><td>v0.2, v0.3, v1.0</td><td>Multi-vendor CSI plugin supporting over 80 Drivers to provide block and mount storage to Container Orchestration systems.</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Snapshot</td></tr>
<tr><td><a href="https://github.com/Excelero/nvmesh-csi-driver">Excelero NVMesh</a></td><td><code>nvmesh-csi.excelero.com</code></td><td>v1.0, v1.1</td><td>A Container Storage Interface (CSI) Driver for Excelero NVMesh</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Raw Block, Expansion</td></tr>
<tr><td><a href="https://github.com/kubernetes-sigs/gcp-compute-persistent-disk-csi-driver">GCE Persistent Disk</a></td><td><code>pd.csi.storage.gke.io</code></td><td>v0.3, v1.0</td><td>A Container Storage Interface (CSI) Driver for Google Compute Engine Persistent Disk (GCE PD)</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Snapshot, Expansion, Topology</td></tr>
<tr><td><a href="https://github.com/kubernetes-sigs/gcp-filestore-csi-driver">Google Cloud Filestore</a></td><td><code>com.google.csi.filestore</code></td><td>v0.3</td><td>A Container Storage Interface (CSI) Driver for Google Cloud Filestore</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/ofek/csi-gcs">Google Cloud Storage</a></td><td><code>gcs.csi.ofek.dev</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for Google Cloud Storage</td><td>Persistent and Ephemeral</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Expansion</td></tr>
<tr><td><a href="https://github.com/gluster/gluster-csi-driver">GlusterFS</a></td><td><code>org.gluster.glusterfs</code></td><td>v0.3, v1.0</td><td>A Container Storage Interface (CSI) Driver for GlusterFS</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Snapshot</td></tr>
<tr><td><a href="https://github.com/gluster/gluster-csi-driver">Gluster VirtBlock</a></td><td><code>org.gluster.glustervirtblock</code></td><td>v0.3, v1.0</td><td>A Container Storage Interface (CSI) Driver for Gluster Virtual Block volumes</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/hammer-space/csi-plugin">Hammerspace CSI</a></td><td><code>com.hammerspace.csi</code></td><td>v0.3, v1.0</td><td>A Container Storage Interface (CSI) Driver for Hammerspace Storage</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Raw Block, Snapshot</td></tr>
<tr><td><a href="https://documentation.commvault.com/commvault/hedvig/others/pdf/Hedvig_CSI_User_Guide.pdf">Hedvig</a></td><td><code>io.hedvig.csi</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for Hedvig</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Raw Block, Snapshot, Expansion</td></tr>
<tr><td><a href="https://github.com/hetznercloud/csi-driver">Hetzner Cloud Volumes CSI</a></td><td><code>csi.hetzner.cloud</code></td><td>v0.3, v1.0</td><td>A Container Storage Interface (CSI) Driver for Hetzner Cloud Volumes</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Expansion</td></tr>
<tr><td><a href="https://knowledge.hitachivantara.com/Documents/Adapters_and_Drivers/Storage_Adapters_and_Drivers/Containers">Hitachi Vantara</a></td><td><code>hspc.csi.hitachi.com</code></td><td>v1.2</td><td>A Container Storage Interface (CSI) Driver for VSP series Storage</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Snapshot, Expansion, Cloning</td></tr>
<tr><td><a href="https://github.com/hpe-storage/csi-driver">HPE</a></td><td><code>csi.hpe.com</code></td><td>v1.3</td><td>A <a href="https://scod.hpedev.io/csi_driver">multi-platform</a> Container Storage Interface (CSI) driver. Supports <a href="https://hpe.com/storage/alletra">HPE Alletra</a>, <a href="https://hpe.com/storage/nimble">Nimble Storage</a>, <a href="https://hpe.com/storage/primera">Primera</a> and <a href="https://hpe.com/storage/3par">3PAR</a></td><td>Persistent and Ephemeral</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Raw Block, Snapshot, Expansion, Cloning</td></tr>
<tr><td><a href="https://github.com/mapr/mapr-csi">HPE Ezmeral (MapR)</a></td><td><code>com.mapr.csi-kdf</code></td><td>v1.3</td><td>A Container Storage Interface (CSI) Driver for HPE Ezmeral Data Fabric</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Raw Block, Snapshot, Expansion, Cloning</td></tr>
<tr><td><a href="https://github.com/Huawei/eSDK_K8S_Plugin">Huawei Storage CSI</a></td><td><code>csi.huawei.com</code></td><td>v1.0, v1.1, v1.2</td><td>A Container Storage Interface (CSI) Driver for FusionStorage, OceanStor 100D, OceanStor Pacific, OceanStor Dorado V3, OceanStor Dorado V6, OceanStor V3, OceanStor V5</td><td>Persistent</td><td>Read/Write Multiple Pod</td><td>Yes</td><td>Snapshot, Expansion, Cloning</td></tr>
<tr><td><a href="https://github.com/Zetanova/hyperv-csi-driver">HyperV CSI</a></td><td><code>eu.zetanova.csi.hyperv</code></td><td>v1.0, v1.1</td><td>A Container Storage Interface (CSI) driver to manage hyperv hosts</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/ibm/ibm-block-csi-driver">IBM Block Storage</a></td><td><code>block.csi.ibm.com</code></td><td>v1.0,v1.1,v1.2,v1.3,v1.4,v1.5</td><td>A Container Storage Interface (CSI) <a href="https://www.ibm.com/docs/en/stg-block-csi-driver">Driver</a> for IBM Spectrum Virtualize Family, IBM FlashSystem A9000 and A9000R, IBM DS8000 Family 8.x and higher.</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Snapshot, Expansion, Cloning, Topology</td></tr>
<tr><td><a href="https://github.com/IBM/ibm-spectrum-scale-csi">IBM Spectrum Scale</a></td><td><code>spectrumscale.csi.ibm.com</code></td><td>v1.5</td><td>A Container Storage Interface (CSI) <a href="https://www.ibm.com/docs/en/spectrum-scale-csi">Driver</a> for the IBM Spectrum Scale File System</td><td>Persistent</td><td>Read/Write Multiple Pod</td><td>Yes</td><td>Snapshot, Expansion, Cloning</td></tr>
<tr><td><a href="https://github.com/kubernetes-sigs/ibm-vpc-block-csi-driver">IBM Cloud Block Storage VPC CSI Driver</a></td><td><code>vpc.block.csi.ibm.io</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) <a href="https://cloud.ibm.com/docs/containers?topic=containers-vpc-block">Driver</a> for IBM Cloud Kubernetes Service and Red Hat OpenShift on IBM Cloud</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Expansion</td></tr>
<tr><td><a href="https://github.com/Infinidat/infinibox-csi-driver">Infinidat</a></td><td><code>infinibox-csi-driver</code></td><td>v1.0, v1.1</td><td>A Container Storage Interface (CSI) Driver for Infinidat <a href="https://infinidat.com/en/products-technology/infinibox">InfiniBox</a></td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Raw Block, Snapshot, Expansion, Cloning</td></tr>
<tr><td><a href="https://github.com/OpenInspur/instorage-k8s">Inspur InStorage CSI</a></td><td><code>csi-instorage</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for inspur AS/HF/CS/CF Series Primary Storage, inspur AS13000 Series SDS Storage</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Snapshot, Expansion, Cloning</td></tr>
<tr><td><a href="https://github.com/intel/pmem-csi">Intel PMEM-CSI</a></td><td><code>pmem-csi.intel.com</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) driver for <a href="https://pmem.io/">PMEM</a> from Intel</td><td>Persistent and Ephemeral</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block</td></tr>
<tr><td><a href="https://github.com/DDNStorage/intelliflash-csi-block-driver">Intelliflash Block Storage</a></td><td><code>intelliflash-csi-block-driver.intelliflash.com</code></td><td>v1.0, v1.1, v1.2</td><td>A Container Storage Interface (CSI) Driver for Intelliflash  Block Storage</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Snapshot, Expansion, Cloning, Topology</td></tr>
<tr><td><a href="https://github.com/DDNStorage/intelliflash-csi-file-driver">Intelliflash File Storage</a></td><td><code>intelliflash-csi-file-driver.intelliflash.com</code></td><td>v1.0, v1.1, v1.2</td><td>A Container Storage Interface (CSI) Driver for Intelliflash  File Storage</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Snapshot, Expansion, Cloning, Topology</td></tr>
<tr><td><a href="https://github.com/ionir-cloud">ionir </a></td><td><code>ionir</code></td><td>v1.2</td><td>A Container Storage Interface (CSI) Driver for <a href="https://www.ionir.com/">ionir</a> Kubernetes-Native Storage</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Cloning</td></tr>
<tr><td><a href="https://github.com/juicedata/juicefs-csi-driver">JuiceFS</a></td><td><code>csi.juicefs.com</code></td><td>v0.3, v1.0</td><td>A Container Storage Interface (CSI) Driver for JuiceFS File System</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/kadalu/kadalu">kaDalu</a></td><td><code>org.kadalu.gluster</code></td><td>v0.3</td><td>A CSI Driver (and operator) for GlusterFS</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/kaixiangtech/csi-driver-flexblock">KaiXiangTech MegaBric</a></td><td><code>flexblock.csi.kaixiangtech.com</code></td><td>v1.5.0</td><td>A Container Storage Interface (CSI) plugin for KaiXiangTech MegaBric Storage</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Raw Block, Expansion, Cloning</td></tr>
<tr><td><a href="https://github.com/KioxiaAmerica/kumoscale-csi">KumoScale Block Storage</a></td><td><code>kumoscale.kioxia.com</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for KumoScale Block Storage</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Snapshot, Expansion, Topology</td></tr>
<tr><td><a href="https://github.com/linode/linode-blockstorage-csi-driver">Linode Block Storage</a></td><td><code>linodebs.csi.linode.com</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for Linode Block Storage</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/piraeusdatastore/linstor-csi">LINSTOR</a></td><td><code>linstor.csi.linbit.com</code></td><td>v1.2</td><td>A Container Storage Interface (CSI) Driver for <a href="https://www.linbit.com/en/linstor/">LINSTOR</a> volumes</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Snapshot, Expansion, Cloning, Topology</td></tr>
<tr><td><a href="https://github.com/longhorn/longhorn">Longhorn</a></td><td><code>driver.longhorn.io</code></td><td>v1.5</td><td>A Container Storage Interface (CSI) Driver for <a href="https://longhorn.io/">Longhorn</a> volumes</td><td>Persistent</td><td>Read/Write Single Node</td><td>Yes</td><td>Raw Block</td></tr>
<tr><td><a href="https://github.com/macrosan-csi/macrosan-csi-driver">MacroSAN</a></td><td><code>csi-macrosan</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for MacroSAN Block Storage</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/kubernetes/cloud-provider-openstack/tree/master/pkg/csi/manila">Manila</a></td><td><code>manila.csi.openstack.org</code></td><td>v1.1, v1.2</td><td>A Container Storage Interface (CSI) Driver for OpenStack Shared File System Service (Manila)</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Snapshot, Topology</td></tr>
<tr><td><a href="https://github.com/moosefs/moosefs-csi">MooseFS</a></td><td><code>com.tuxera.csi.moosefs</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for <a href="https://moosefs.com/">MooseFS</a> clusters.</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/NetApp/trident">NetApp</a></td><td><code>csi.trident.netapp.io</code></td><td>v1.0, v1.1, v1.2, v1.3, v1.4, v1.5</td><td>A Container Storage Interface (CSI) Driver for NetApp's <a href="https://docs.netapp.com/us-en/trident/index.html">Trident</a> container storage orchestrator</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Raw Block, Snapshot, Expansion, Cloning, Topology</td></tr>
<tr><td><a href="https://github.com/Nexenta/nexentastor-csi-driver">NexentaStor File Storage</a></td><td><code>nexentastor-csi-driver.nexenta.com</code></td><td>v1.0, v1.1, v1.2</td><td>A Container Storage Interface (CSI) Driver for NexentaStor  File Storage</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Snapshot, Expansion, Cloning, Topology</td></tr>
<tr><td><a href="https://github.com/Nexenta/nexentastor-csi-driver-block">NexentaStor Block Storage</a></td><td><code>nexentastor-block-csi-driver.nexenta.com</code></td><td>v1.0, v1.1, v1.2</td><td>A Container Storage Interface (CSI) Driver for NexentaStor over iSCSI protocol</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Snapshot, Expansion, Cloning, Topology, Raw block</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/csi-driver-nfs">NFS</a></td><td><code>nfs.csi.k8s.io</code></td><td>v1.0</td><td>This driver allows Kubernetes to access NFS server on Linux node.</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/nutanix/csi-plugin">Nutanix</a></td><td><code>csi.nutanix.com</code></td><td>v0.3, v1.0, v1.2</td><td>A Container Storage Interface (CSI) Driver for Nutanix</td><td>Persistent</td><td>&quot;Read/Write Single Pod&quot; with Nutanix Volumes and &quot;Read/Write Multiple Pods&quot; with Nutanix Files</td><td>Yes</td><td>Raw Block, Snapshot, Expansion, Cloning</td></tr>
<tr><td><a href="https://github.com/openebs/csi">OpenEBS</a></td><td><code>cstor.csi.openebs.io</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for  <a href="https://www.openebs.io/">OpenEBS</a></td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Expansion, Snapshot, Cloning</td></tr>
<tr><td><a href="https://github.com/open-e/JovianDSS-KubernetesCSI">Open-E</a></td><td><code>com.open-e.joviandss.csi</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for Open-E JovianDSS Storage</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Snapshot, Cloning</td></tr>
<tr><td><a href="https://github.com/alibaba/open-local">Open-Local</a></td><td><code>local.csi.alibaba.com</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for Local Storage</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Expansion, Snapshot</td></tr>
<tr><td><a href="https://github.com/oracle/oci-cloud-controller-manager/blob/master/container-storage-interface.md">Oracle Cloud Infrastructure(OCI) Block Storage</a></td><td><code>blockvolume.csi.oraclecloud.com</code></td><td>v1.1</td><td>A Container Storage Interface (CSI) Driver for Oracle Cloud Infrastructure (OCI) Block Storage</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Topology</td></tr>
<tr><td><a href="https://github.com/openshift/ovirt-csi-driver">oVirt</a></td><td><code>csi.ovirt.org</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for <a href="https://ovirt.org">oVirt</a></td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Block, File Storage</td></tr>
<tr><td><a href="https://github.com/libopenstorage/openstorage/tree/master/csi">Portworx</a></td><td><code>pxd.portworx.com</code></td><td>v1.4</td><td>A Container Storage Interface (CSI) Driver for <a href="https://docs.portworx.com/portworx-install-with-kubernetes/storage-operations/csi/">Portworx</a></td><td>Persistent and Ephemeral</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Snapshot, Expansion, Raw Block, Cloning</td></tr>
<tr><td><a href="https://github.com/purestorage/pso-csi">Pure Storage CSI</a></td><td><code>pure-csi</code></td><td>v1.0, v1.1, v1.2, v1.3</td><td>A Container Storage Interface (CSI) Driver for Pure Storage's <a href="https://purestorage.com/containers">Pure Service Orchestrator</a></td><td>Persistent and Ephemeral</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Snapshot, Cloning, Raw Block, Topology, Expansion</td></tr>
<tr><td><a href="https://github.com/yunify/qingcloud-csi">QingCloud CSI</a></td><td><code>disk.csi.qingcloud.com</code></td><td>v1.1</td><td>A Container Storage Interface (CSI) Driver for QingCloud Block Storage</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Snapshot, Expansion, Cloning</td></tr>
<tr><td><a href="https://github.com/yunify/qingstor-csi">QingStor CSI</a></td><td><code>neonsan.csi.qingstor.com</code></td><td>v0.3, v1.1</td><td>A Container Storage Interface (CSI) Driver for NeonSAN storage system</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Raw Block, Snapshot, Expansion, Cloning</td></tr>
<tr><td><a href="https://github.com/quobyte/quobyte-csi">Quobyte</a></td><td><code>quobyte-csi</code></td><td>v1.3.0</td><td>A Container Storage Interface (CSI) Driver for Quobyte</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Expansion, Snapshots</td></tr>
<tr><td><a href="https://get.robin.io/">ROBIN</a></td><td><code>robin</code></td><td>v0.3, v1.0</td><td>A Container Storage Interface (CSI) Driver for <a href="https://docs.robin.io">ROBIN</a></td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Raw Block, Snapshot, Expansion, Cloning</td></tr>
<tr><td><a href="https://github.com/sandstone-storage/sandstone-csi-driver">SandStone</a></td><td><code>csi-sandstone-plugin</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for SandStone USP</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Raw Block, Snapshot, Expansion, Cloning</td></tr>
<tr><td><a href="https://github.com/evan37717/sangfor-eds-csi">Sangfor-EDS-File-Storage</a></td><td><code>eds.csi.file.sangfor.com</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for Sangfor Distributed File Storage(EDS)</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/eds-wzc/sangfor-eds-csi">Sangfor-EDS-Block-Storage</a></td><td><code>eds.csi.block.sangfor.com</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for Sangfor Block Storage(EDS)</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/scaleway/scaleway-csi">Scaleway CSI</a></td><td><code>csi.scaleway.com</code></td><td>v1.2.0</td><td>Container Storage Interface (CSI) Driver for <a href="https://www.scaleway.com/block-storage/">Scaleway Block Storage</a></td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Snapshot, Expansion, Topology</td></tr>
<tr><td><a href="https://github.com/Seagate/seagate-exos-x-csi">Seagate Exos X</a></td><td><code>csi-exos-x.seagate.com</code></td><td>v1.3</td><td>CSI driver for <a href="https://www.seagate.com/products/storage/data-storage-systems/raid/">Seagate Exos X</a> and OEM systems</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Snapshot, Expansion, Cloning</td></tr>
<tr><td><a href="https://github.com/seaweedfs/seaweedfs-csi-driver">SeaweedFS</a></td><td><code>seaweedfs-csi-driver</code></td><td>v1.0</td><td>A Container Storage Interface (CSI Driver for <a href="https://github.com/chrislusf/seaweedfs">SeaweedFS</a>)</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/kubernetes-sigs/secrets-store-csi-driver">Secrets Store CSI Driver</a></td><td><code>secrets-store.csi.k8s.io</code></td><td>v0.0.10</td><td>A Container Storage Interface (CSI) Driver for mounting secrets, keys, and certs stored in enterprise-grade external secrets stores as volumes.</td><td>Ephemeral</td><td>N/A</td><td>N/A</td><td></td></tr>
<tr><td><a href="http://www.smartx.com/?locale=en">SmartX</a></td><td><code>csi-smtx-plugin</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for SmartX ZBS Storage</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Snapshot, Expansion</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/csi-driver-smb">SMB</a></td><td><code>smb.csi.k8s.io</code></td><td>v1.0</td><td>This driver allows Kubernetes to access SMB Server on both Linux and Windows nodes</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/sodafoundation/nbp/tree/master/csi">SODA</a></td><td><code>csi-soda-plugin</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for <a href="https://sodafoundation.io/">SODA</a></td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Snapshot</td></tr>
<tr><td><a href="https://github.com/spdk/spdk-csi">SPDK-CSI</a></td><td><code>csi.spdk.io</code></td><td>v1.1</td><td>A Container Storage Interface (CSI) Driver for <a href="https://spdk.io/">SPDK</a></td><td>Persistent and Ephemeral</td><td>Read/Write Single Pod</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://docs.storageos.com/docs/platforms/kubernetes/install/">StorageOS</a></td><td><code>storageos</code></td><td>v0.3, v1.0</td><td>A Container Storage Interface (CSI) Driver for <a href="https://storageos.com/">StorageOS</a></td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://docs.storidge.com/kubernetes_storage/overview.html">Storidge</a></td><td><code>csi.cio.storidge.com</code></td><td>v0.3, v1.0</td><td>A Container Storage Interface (CSI) Driver for <a href="https://storidge.com/">Storidge CIO</a></td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Snapshot, Expansion</td></tr>
<tr><td><a href="https://kb.storpool.com/storpool_integrations/github/kubernetes.html">StorPool</a></td><td><code>csi-driver.storpool.com</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for <a href="https://storpool.com/">StorPool</a></td><td>Persistent and Ephemeral</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Expansion</td></tr>
<tr><td><a href="https://github.com/SynologyOpenSource/synology-csi">Synology</a></td><td><code>csi.san.synology.com</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for Synology NAS</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Snapshot, Expansion, Cloning</td></tr>
<tr><td><a href="https://github.com/TencentCloud/kubernetes-csi-tencentcloud">Tencent Cloud Block Storage</a></td><td><code>com.tencent.cloud.csi.cbs</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for Tencent Cloud Block Storage</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Snapshot</td></tr>
<tr><td><a href="https://github.com/TencentCloud/kubernetes-csi-tencentcloud">Tencent Cloud File Storage</a></td><td><code>com.tencent.cloud.csi.cfs</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for Tencent Cloud File Storage</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/TencentCloud/kubernetes-csi-tencentcloud">Tencent Cloud Object Storage</a></td><td><code>com.tencent.cloud.csi.cosfs</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for Tencent Cloud Object Storage</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>No</td><td></td></tr>
<tr><td><a href="https://github.com/cybozu-go/topolvm">TopoLVM</a></td><td><code>topolvm.cybozu.com</code></td><td>v1.1</td><td>A Container Storage Interface (CSI) Driver for LVM</td><td>Persistent and Ephemeral</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Expansion, Topology Aware</td></tr>
<tr><td><a href="https://github.com/hpe-storage/truenas-csp">TrueNAS</a></td><td><code>csi.hpe.com</code></td><td>v1.3</td><td>A community supported <a href="https://github.com/hpe-storage/container-storage-provider">Container Storage Provider</a> (CSP) that leverages the HPE CSI Driver for Kubernetes. Works with TrueNAS CORE, TrueNAS SCALE and FreeNAS using iSCSI only</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Raw Block, Snapshot, Expansion, Cloning</td></tr>
<tr><td><a href="https://github.com/vast-data/vast-csi">VAST Data</a></td><td><code>csi.vastdata.com</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for VAST Data</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://xsky-storage.github.io/xsky-csi-driver/csi-block.html">XSKY-EBS</a></td><td><code>csi.block.xsky.com</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for XSKY Distributed Block Storage (X-EBS)</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td>Raw Block, Snapshot, Expansion, Cloning</td></tr>
<tr><td><a href="https://xsky-storage.github.io/xsky-csi-driver/csi-fs.html">XSKY-FS</a></td><td><code>csi.fs.xsky.com</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for XEDPXEUSXUDSXGFSX3000X5000</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Snapshot, Expansion</td></tr>
<tr><td><a href="https://github.com/kubevault/csi-driver">Vault</a></td><td><code>secrets.csi.kubevault.com</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for mounting HashiCorp Vault secrets as volumes.</td><td>Ephemeral</td><td>N/A</td><td>N/A</td><td></td></tr>
<tr><td><a href="https://virtual-disk-array.readthedocs.io/en/latest/Introduction.html">VDA</a></td><td><code>csi.vda.io</code></td><td>v1.0</td><td>An open source block storage system base on SPDK</td><td>Persistent</td><td>Read/Write Single Pod</td><td>N/A</td><td></td></tr>
<tr><td><a href="https://www.veritas.com/solution/virtualization/containers.html">Veritas InfoScale Volumes</a></td><td><code>org.veritas.infoscale</code></td><td>v1.2</td><td>A Container Storage Interface (CSI) Driver for Veritas InfoScale volumes</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Snapshot, Expansion, Cloning</td></tr>
<tr><td><a href="https://github.com/kubernetes-sigs/vsphere-csi-driver">vSphere</a></td><td><code>csi.vsphere.vmware.com</code></td><td>v1.4</td><td>A Container Storage Interface (CSI) Driver for VMware vSphere</td><td>Persistent</td><td>Read/Write Single Pod (Block Volume) <br/><br/> Read/Write Multiple Pods (File Volume)</td><td>Yes</td><td>Raw Block,<br/><br/>Expansion (Block Volume),<br/><br/>Topology Aware (Block Volume),<br/><br/>Snapshot (Block Volume)</td></tr>
<tr><td><a href="https://github.com/vultr/vultr-csi">Vultr Block Storage</a></td><td><code>block.csi.vultr.com</code></td><td>v1.2</td><td>A Container Storage Interface (CSI) Driver for Vultr Block Storage</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/weka/csi-wekafs">WekaIO</a></td><td><code>csi.weka.io</code></td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for mounting WekaIO WekaFS filesystem as volumes</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/flant/yandex-csi-driver">Yandex.Cloud</a></td><td><code>yandex.csi.flant.com</code></td><td>v1.2</td><td>A Container Storage Interface (CSI) plugin for Yandex.Cloud Compute Disks</td><td>Persistent</td><td>Read/Write Single Pod</td><td>Yes</td><td></td></tr>
<tr><td><a href="http://www.yanrongyun.com/">YanRongYun</a></td><td>?</td><td>v1.0</td><td>A Container Storage Interface (CSI) Driver for YanRong YRCloudFile Storage</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td></td></tr>
<tr><td><a href="https://github.com/zadarastorage/zadara-csi">Zadara-CSI</a></td><td><code>csi.zadara.com</code></td><td>v1.0, v1.1</td><td>A Container Storage Interface (CSI) plugin for Zadara VPSA Storage Array &amp; VPSA All-Flash</td><td>Persistent</td><td>Read/Write Multiple Pods</td><td>Yes</td><td>Raw Block, Snapshot, Expansion, Cloning</td></tr>
</tbody></table>
</div>
<h2><a class="header" href="#sample-drivers" id="sample-drivers">Sample Drivers</a></h2>
<table><thead><tr><th>Name</th><th>Status</th><th>More Information</th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/csi-driver-flex">Flexvolume</a></td><td>Sample</td><td></td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/csi-driver-host-path">HostPath</a></td><td>v1.2.0</td><td>Only use for a single node tests. See the <a href="example.html">Example</a> page for Kubernetes-specific instructions.</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/csi-driver-image-populator">ImagePopulator</a></td><td>Prototype</td><td>Driver that lets you use a container image as an ephemeral volume.</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/csi-test/tree/master/mock/service">In-memory Sample Mock Driver</a></td><td>v0.3.0</td><td>The sample mock driver used for <a href="https://github.com/kubernetes-csi/csi-test/tree/master/cmd/csi-sanity">csi-sanity</a></td></tr>
<tr><td><a href="https://github.com/jparklab/synology-csi">Synology NAS</a></td><td>v1.0.0</td><td>An unofficial (and unsupported) Container Storage Interface Driver for Synology NAS.</td></tr>
<tr><td><a href="https://github.com/thecodeteam/csi-vfs">VFS Driver</a></td><td>Released</td><td>A CSI plugin that provides a virtual file system.</td></tr>
</tbody></table>
<h1><a class="header" href="#api-reference" id="api-reference">API Reference</a></h1>
<p>The following is the list of CSI APIs:</p>
<ul>
<li><a href="api/volume-snapshot.html">Volume Snapshot</a></li>
</ul>
<h1><a class="header" href="#volume-snapshot" id="volume-snapshot">Volume Snapshot</a></h1>
<p>Packages:</p>
<ul>
<li>
<a href="api/volume-snapshot.html#snapshot.storage.k8s.io%2fv1">snapshot.storage.k8s.io/v1</a>
</li>
</ul>
<h2 id="snapshot.storage.k8s.io/v1">snapshot.storage.k8s.io/v1</h2>
Resource Types:
<ul><li>
<a href="api/volume-snapshot.html#snapshot.storage.k8s.io/v1.VolumeSnapshot">VolumeSnapshot</a>
</li><li>
<a href="api/volume-snapshot.html#snapshot.storage.k8s.io/v1.VolumeSnapshotClass">VolumeSnapshotClass</a>
</li><li>
<a href="api/volume-snapshot.html#snapshot.storage.k8s.io/v1.VolumeSnapshotContent">VolumeSnapshotContent</a>
</li></ul>
<h3 id="snapshot.storage.k8s.io/v1.VolumeSnapshot">VolumeSnapshot
</h3>
<div>
<p>VolumeSnapshot is a user&rsquo;s request for either creating a point-in-time
snapshot of a persistent volume, or binding to a pre-existing snapshot.</p>
</div>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code><br/>
string</td>
<td>
<code>
snapshot.storage.k8s.io/v1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code><br/>
string
</td>
<td><code>VolumeSnapshot</code></td>
</tr>
<tr>
<td>
<code>metadata</code><br/>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Standard object&rsquo;s metadata.
More info: <a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata">https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata</a></p>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code><br/>
<em>
<a href="api/volume-snapshot.html#snapshot.storage.k8s.io/v1.VolumeSnapshotSpec">
VolumeSnapshotSpec
</a>
</em>
</td>
<td>
<p>spec defines the desired characteristics of a snapshot requested by a user.
More info: <a href="https://kubernetes.io/docs/concepts/storage/volume-snapshots#volumesnapshots">https://kubernetes.io/docs/concepts/storage/volume-snapshots#volumesnapshots</a>
Required.</p>
<br/>
<br/>
<table>
<tr>
<td>
<code>source</code><br/>
<em>
<a href="api/volume-snapshot.html#snapshot.storage.k8s.io/v1.VolumeSnapshotSource">
VolumeSnapshotSource
</a>
</em>
</td>
<td>
<p>source specifies where a snapshot will be created from.
This field is immutable after creation.
Required.</p>
</td>
</tr>
<tr>
<td>
<code>volumeSnapshotClassName</code><br/>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>VolumeSnapshotClassName is the name of the VolumeSnapshotClass
requested by the VolumeSnapshot.
VolumeSnapshotClassName may be left nil to indicate that the default
SnapshotClass should be used.
A given cluster may have multiple default Volume SnapshotClasses: one
default per CSI Driver. If a VolumeSnapshot does not specify a SnapshotClass,
VolumeSnapshotSource will be checked to figure out what the associated
CSI Driver is, and the default VolumeSnapshotClass associated with that
CSI Driver will be used. If more than one VolumeSnapshotClass exist for
a given CSI Driver and more than one have been marked as default,
CreateSnapshot will fail and generate an event.
Empty string is not allowed for this field.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code><br/>
<em>
<a href="api/volume-snapshot.html#snapshot.storage.k8s.io/v1.VolumeSnapshotStatus">
VolumeSnapshotStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>status represents the current information of a snapshot.
Consumers must verify binding between VolumeSnapshot and
VolumeSnapshotContent objects is successful (by validating that both
VolumeSnapshot and VolumeSnapshotContent point at each other) before
using this object.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="snapshot.storage.k8s.io/v1.VolumeSnapshotClass">VolumeSnapshotClass
</h3>
<div>
<p>VolumeSnapshotClass specifies parameters that a underlying storage system uses when
creating a volume snapshot. A specific VolumeSnapshotClass is used by specifying its
name in a VolumeSnapshot object.
VolumeSnapshotClasses are non-namespaced</p>
</div>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code><br/>
string</td>
<td>
<code>
snapshot.storage.k8s.io/v1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code><br/>
string
</td>
<td><code>VolumeSnapshotClass</code></td>
</tr>
<tr>
<td>
<code>metadata</code><br/>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Standard object&rsquo;s metadata.
More info: <a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata">https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata</a></p>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>driver</code><br/>
<em>
string
</em>
</td>
<td>
<p>driver is the name of the storage driver that handles this VolumeSnapshotClass.
Required.</p>
</td>
</tr>
<tr>
<td>
<code>parameters</code><br/>
<em>
map[string]string
</em>
</td>
<td>
<em>(Optional)</em>
<p>parameters is a key-value map with storage driver specific parameters for creating snapshots.
These values are opaque to Kubernetes.</p>
</td>
</tr>
<tr>
<td>
<code>deletionPolicy</code><br/>
<em>
<a href="api/volume-snapshot.html#snapshot.storage.k8s.io/v1.DeletionPolicy">
DeletionPolicy
</a>
</em>
</td>
<td>
<p>deletionPolicy determines whether a VolumeSnapshotContent created through
the VolumeSnapshotClass should be deleted when its bound VolumeSnapshot is deleted.
Supported values are &ldquo;Retain&rdquo; and &ldquo;Delete&rdquo;.
&ldquo;Retain&rdquo; means that the VolumeSnapshotContent and its physical snapshot on underlying storage system are kept.
&ldquo;Delete&rdquo; means that the VolumeSnapshotContent and its physical snapshot on underlying storage system are deleted.
Required.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="snapshot.storage.k8s.io/v1.VolumeSnapshotContent">VolumeSnapshotContent
</h3>
<div>
<p>VolumeSnapshotContent represents the actual &ldquo;on-disk&rdquo; snapshot object in the
underlying storage system</p>
</div>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code><br/>
string</td>
<td>
<code>
snapshot.storage.k8s.io/v1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code><br/>
string
</td>
<td><code>VolumeSnapshotContent</code></td>
</tr>
<tr>
<td>
<code>metadata</code><br/>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Standard object&rsquo;s metadata.
More info: <a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata">https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata</a></p>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code><br/>
<em>
<a href="api/volume-snapshot.html#snapshot.storage.k8s.io/v1.VolumeSnapshotContentSpec">
VolumeSnapshotContentSpec
</a>
</em>
</td>
<td>
<p>spec defines properties of a VolumeSnapshotContent created by the underlying storage system.
Required.</p>
<br/>
<br/>
<table>
<tr>
<td>
<code>volumeSnapshotRef</code><br/>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#objectreference-v1-core">
Kubernetes core/v1.ObjectReference
</a>
</em>
</td>
<td>
<p>volumeSnapshotRef specifies the VolumeSnapshot object to which this
VolumeSnapshotContent object is bound.
VolumeSnapshot.Spec.VolumeSnapshotContentName field must reference to
this VolumeSnapshotContent&rsquo;s name for the bidirectional binding to be valid.
For a pre-existing VolumeSnapshotContent object, name and namespace of the
VolumeSnapshot object MUST be provided for binding to happen.
This field is immutable after creation.
Required.</p>
</td>
</tr>
<tr>
<td>
<code>deletionPolicy</code><br/>
<em>
<a href="api/volume-snapshot.html#snapshot.storage.k8s.io/v1.DeletionPolicy">
DeletionPolicy
</a>
</em>
</td>
<td>
<p>deletionPolicy determines whether this VolumeSnapshotContent and its physical snapshot on
the underlying storage system should be deleted when its bound VolumeSnapshot is deleted.
Supported values are &ldquo;Retain&rdquo; and &ldquo;Delete&rdquo;.
&ldquo;Retain&rdquo; means that the VolumeSnapshotContent and its physical snapshot on underlying storage system are kept.
&ldquo;Delete&rdquo; means that the VolumeSnapshotContent and its physical snapshot on underlying storage system are deleted.
For dynamically provisioned snapshots, this field will automatically be filled in by the
CSI snapshotter sidecar with the &ldquo;DeletionPolicy&rdquo; field defined in the corresponding
VolumeSnapshotClass.
For pre-existing snapshots, users MUST specify this field when creating the
VolumeSnapshotContent object.
Required.</p>
</td>
</tr>
<tr>
<td>
<code>driver</code><br/>
<em>
string
</em>
</td>
<td>
<p>driver is the name of the CSI driver used to create the physical snapshot on
the underlying storage system.
This MUST be the same as the name returned by the CSI GetPluginName() call for
that driver.
Required.</p>
</td>
</tr>
<tr>
<td>
<code>volumeSnapshotClassName</code><br/>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>name of the VolumeSnapshotClass from which this snapshot was (or will be)
created.
Note that after provisioning, the VolumeSnapshotClass may be deleted or
recreated with different set of values, and as such, should not be referenced
post-snapshot creation.</p>
</td>
</tr>
<tr>
<td>
<code>source</code><br/>
<em>
<a href="api/volume-snapshot.html#snapshot.storage.k8s.io/v1.VolumeSnapshotContentSource">
VolumeSnapshotContentSource
</a>
</em>
</td>
<td>
<p>source specifies whether the snapshot is (or should be) dynamically provisioned
or already exists, and just requires a Kubernetes object representation.
This field is immutable after creation.
Required.</p>
</td>
</tr>
<tr>
<td>
<code>sourceVolumeMode</code><br/>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#persistentvolumemode-v1-core">
Kubernetes core/v1.PersistentVolumeMode
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>SourceVolumeMode is the mode of the volume whose snapshot is taken.
Can be either Filesystem or Block.
If not specified, it indicates the source volume&rsquo;s mode is unknown.
This field is immutable.
This field is an alpha field.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code><br/>
<em>
<a href="api/volume-snapshot.html#snapshot.storage.k8s.io/v1.VolumeSnapshotContentStatus">
VolumeSnapshotContentStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>status represents the current information of a snapshot.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="snapshot.storage.k8s.io/v1.DeletionPolicy">DeletionPolicy
(<code>string</code> alias)</h3>
<p>
(<em>Appears on:</em><a href="api/volume-snapshot.html#snapshot.storage.k8s.io/v1.VolumeSnapshotClass">VolumeSnapshotClass</a>, <a href="api/volume-snapshot.html#snapshot.storage.k8s.io/v1.VolumeSnapshotContentSpec">VolumeSnapshotContentSpec</a>)
</p>
<div>
<p>DeletionPolicy describes a policy for end-of-life maintenance of volume snapshot contents</p>
</div>
<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr><td><p>&#34;Delete&#34;</p></td>
<td><p>volumeSnapshotContentDelete means the snapshot will be deleted from the
underlying storage system on release from its volume snapshot.</p>
</td>
</tr><tr><td><p>&#34;Retain&#34;</p></td>
<td><p>volumeSnapshotContentRetain means the snapshot will be left in its current
state on release from its volume snapshot.</p>
</td>
</tr></tbody>
</table>
<h3 id="snapshot.storage.k8s.io/v1.VolumeSnapshotContentSource">VolumeSnapshotContentSource
</h3>
<p>
(<em>Appears on:</em><a href="api/volume-snapshot.html#snapshot.storage.k8s.io/v1.VolumeSnapshotContentSpec">VolumeSnapshotContentSpec</a>)
</p>
<div>
<p>VolumeSnapshotContentSource represents the CSI source of a snapshot.
Exactly one of its members must be set.
Members in VolumeSnapshotContentSource are immutable.</p>
</div>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>volumeHandle</code><br/>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>volumeHandle specifies the CSI &ldquo;volume_id&rdquo; of the volume from which a snapshot
should be dynamically taken from.
This field is immutable.</p>
</td>
</tr>
<tr>
<td>
<code>snapshotHandle</code><br/>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>snapshotHandle specifies the CSI &ldquo;snapshot_id&rdquo; of a pre-existing snapshot on
the underlying storage system for which a Kubernetes object representation
was (or should be) created.
This field is immutable.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="snapshot.storage.k8s.io/v1.VolumeSnapshotContentSpec">VolumeSnapshotContentSpec
</h3>
<p>
(<em>Appears on:</em><a href="api/volume-snapshot.html#snapshot.storage.k8s.io/v1.VolumeSnapshotContent">VolumeSnapshotContent</a>)
</p>
<div>
<p>VolumeSnapshotContentSpec is the specification of a VolumeSnapshotContent</p>
</div>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>volumeSnapshotRef</code><br/>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#objectreference-v1-core">
Kubernetes core/v1.ObjectReference
</a>
</em>
</td>
<td>
<p>volumeSnapshotRef specifies the VolumeSnapshot object to which this
VolumeSnapshotContent object is bound.
VolumeSnapshot.Spec.VolumeSnapshotContentName field must reference to
this VolumeSnapshotContent&rsquo;s name for the bidirectional binding to be valid.
For a pre-existing VolumeSnapshotContent object, name and namespace of the
VolumeSnapshot object MUST be provided for binding to happen.
This field is immutable after creation.
Required.</p>
</td>
</tr>
<tr>
<td>
<code>deletionPolicy</code><br/>
<em>
<a href="api/volume-snapshot.html#snapshot.storage.k8s.io/v1.DeletionPolicy">
DeletionPolicy
</a>
</em>
</td>
<td>
<p>deletionPolicy determines whether this VolumeSnapshotContent and its physical snapshot on
the underlying storage system should be deleted when its bound VolumeSnapshot is deleted.
Supported values are &ldquo;Retain&rdquo; and &ldquo;Delete&rdquo;.
&ldquo;Retain&rdquo; means that the VolumeSnapshotContent and its physical snapshot on underlying storage system are kept.
&ldquo;Delete&rdquo; means that the VolumeSnapshotContent and its physical snapshot on underlying storage system are deleted.
For dynamically provisioned snapshots, this field will automatically be filled in by the
CSI snapshotter sidecar with the &ldquo;DeletionPolicy&rdquo; field defined in the corresponding
VolumeSnapshotClass.
For pre-existing snapshots, users MUST specify this field when creating the
VolumeSnapshotContent object.
Required.</p>
</td>
</tr>
<tr>
<td>
<code>driver</code><br/>
<em>
string
</em>
</td>
<td>
<p>driver is the name of the CSI driver used to create the physical snapshot on
the underlying storage system.
This MUST be the same as the name returned by the CSI GetPluginName() call for
that driver.
Required.</p>
</td>
</tr>
<tr>
<td>
<code>volumeSnapshotClassName</code><br/>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>name of the VolumeSnapshotClass from which this snapshot was (or will be)
created.
Note that after provisioning, the VolumeSnapshotClass may be deleted or
recreated with different set of values, and as such, should not be referenced
post-snapshot creation.</p>
</td>
</tr>
<tr>
<td>
<code>source</code><br/>
<em>
<a href="api/volume-snapshot.html#snapshot.storage.k8s.io/v1.VolumeSnapshotContentSource">
VolumeSnapshotContentSource
</a>
</em>
</td>
<td>
<p>source specifies whether the snapshot is (or should be) dynamically provisioned
or already exists, and just requires a Kubernetes object representation.
This field is immutable after creation.
Required.</p>
</td>
</tr>
<tr>
<td>
<code>sourceVolumeMode</code><br/>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#persistentvolumemode-v1-core">
Kubernetes core/v1.PersistentVolumeMode
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>SourceVolumeMode is the mode of the volume whose snapshot is taken.
Can be either Filesystem or Block.
If not specified, it indicates the source volume&rsquo;s mode is unknown.
This field is immutable.
This field is an alpha field.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="snapshot.storage.k8s.io/v1.VolumeSnapshotContentStatus">VolumeSnapshotContentStatus
</h3>
<p>
(<em>Appears on:</em><a href="api/volume-snapshot.html#snapshot.storage.k8s.io/v1.VolumeSnapshotContent">VolumeSnapshotContent</a>)
</p>
<div>
<p>VolumeSnapshotContentStatus is the status of a VolumeSnapshotContent object
Note that CreationTime, RestoreSize, ReadyToUse, and Error are in both
VolumeSnapshotStatus and VolumeSnapshotContentStatus. Fields in VolumeSnapshotStatus
are updated based on fields in VolumeSnapshotContentStatus. They are eventual
consistency. These fields are duplicate in both objects due to the following reasons:
- Fields in VolumeSnapshotContentStatus can be used for filtering when importing a
volumesnapshot.
- VolumsnapshotStatus is used by end users because they cannot see VolumeSnapshotContent.
- CSI snapshotter sidecar is light weight as it only watches VolumeSnapshotContent
object, not VolumeSnapshot object.</p>
</div>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>snapshotHandle</code><br/>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>snapshotHandle is the CSI &ldquo;snapshot_id&rdquo; of a snapshot on the underlying storage system.
If not specified, it indicates that dynamic snapshot creation has either failed
or it is still in progress.</p>
</td>
</tr>
<tr>
<td>
<code>creationTime</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>creationTime is the timestamp when the point-in-time snapshot is taken
by the underlying storage system.
In dynamic snapshot creation case, this field will be filled in by the
CSI snapshotter sidecar with the &ldquo;creation_time&rdquo; value returned from CSI
&ldquo;CreateSnapshot&rdquo; gRPC call.
For a pre-existing snapshot, this field will be filled with the &ldquo;creation_time&rdquo;
value returned from the CSI &ldquo;ListSnapshots&rdquo; gRPC call if the driver supports it.
If not specified, it indicates the creation time is unknown.
The format of this field is a Unix nanoseconds time encoded as an int64.
On Unix, the command <code>date +%s%N</code> returns the current time in nanoseconds
since 1970-01-01 00:00:00 UTC.</p>
</td>
</tr>
<tr>
<td>
<code>restoreSize</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>restoreSize represents the complete size of the snapshot in bytes.
In dynamic snapshot creation case, this field will be filled in by the
CSI snapshotter sidecar with the &ldquo;size_bytes&rdquo; value returned from CSI
&ldquo;CreateSnapshot&rdquo; gRPC call.
For a pre-existing snapshot, this field will be filled with the &ldquo;size_bytes&rdquo;
value returned from the CSI &ldquo;ListSnapshots&rdquo; gRPC call if the driver supports it.
When restoring a volume from this snapshot, the size of the volume MUST NOT
be smaller than the restoreSize if it is specified, otherwise the restoration will fail.
If not specified, it indicates that the size is unknown.</p>
</td>
</tr>
<tr>
<td>
<code>readyToUse</code><br/>
<em>
bool
</em>
</td>
<td>
<p>readyToUse indicates if a snapshot is ready to be used to restore a volume.
In dynamic snapshot creation case, this field will be filled in by the
CSI snapshotter sidecar with the &ldquo;ready_to_use&rdquo; value returned from CSI
&ldquo;CreateSnapshot&rdquo; gRPC call.
For a pre-existing snapshot, this field will be filled with the &ldquo;ready_to_use&rdquo;
value returned from the CSI &ldquo;ListSnapshots&rdquo; gRPC call if the driver supports it,
otherwise, this field will be set to &ldquo;True&rdquo;.
If not specified, it means the readiness of a snapshot is unknown.</p>
</td>
</tr>
<tr>
<td>
<code>error</code><br/>
<em>
<a href="api/volume-snapshot.html#snapshot.storage.k8s.io/v1.VolumeSnapshotError">
VolumeSnapshotError
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>error is the last observed error during snapshot creation, if any.
Upon success after retry, this error field will be cleared.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="snapshot.storage.k8s.io/v1.VolumeSnapshotError">VolumeSnapshotError
</h3>
<p>
(<em>Appears on:</em><a href="api/volume-snapshot.html#snapshot.storage.k8s.io/v1.VolumeSnapshotContentStatus">VolumeSnapshotContentStatus</a>, <a href="api/volume-snapshot.html#snapshot.storage.k8s.io/v1.VolumeSnapshotStatus">VolumeSnapshotStatus</a>)
</p>
<div>
<p>VolumeSnapshotError describes an error encountered during snapshot creation.</p>
</div>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>time</code><br/>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#time-v1-meta">
Kubernetes meta/v1.Time
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>time is the timestamp when the error was encountered.</p>
</td>
</tr>
<tr>
<td>
<code>message</code><br/>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>message is a string detailing the encountered error during snapshot
creation if specified.
NOTE: message may be logged, and it should not contain sensitive
information.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="snapshot.storage.k8s.io/v1.VolumeSnapshotSource">VolumeSnapshotSource
</h3>
<p>
(<em>Appears on:</em><a href="api/volume-snapshot.html#snapshot.storage.k8s.io/v1.VolumeSnapshotSpec">VolumeSnapshotSpec</a>)
</p>
<div>
<p>VolumeSnapshotSource specifies whether the underlying snapshot should be
dynamically taken upon creation or if a pre-existing VolumeSnapshotContent
object should be used.
Exactly one of its members must be set.
Members in VolumeSnapshotSource are immutable.</p>
</div>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>persistentVolumeClaimName</code><br/>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>persistentVolumeClaimName specifies the name of the PersistentVolumeClaim
object representing the volume from which a snapshot should be created.
This PVC is assumed to be in the same namespace as the VolumeSnapshot
object.
This field should be set if the snapshot does not exists, and needs to be
created.
This field is immutable.</p>
</td>
</tr>
<tr>
<td>
<code>volumeSnapshotContentName</code><br/>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>volumeSnapshotContentName specifies the name of a pre-existing VolumeSnapshotContent
object representing an existing volume snapshot.
This field should be set if the snapshot already exists and only needs a representation in Kubernetes.
This field is immutable.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="snapshot.storage.k8s.io/v1.VolumeSnapshotSpec">VolumeSnapshotSpec
</h3>
<p>
(<em>Appears on:</em><a href="api/volume-snapshot.html#snapshot.storage.k8s.io/v1.VolumeSnapshot">VolumeSnapshot</a>)
</p>
<div>
<p>VolumeSnapshotSpec describes the common attributes of a volume snapshot.</p>
</div>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>source</code><br/>
<em>
<a href="api/volume-snapshot.html#snapshot.storage.k8s.io/v1.VolumeSnapshotSource">
VolumeSnapshotSource
</a>
</em>
</td>
<td>
<p>source specifies where a snapshot will be created from.
This field is immutable after creation.
Required.</p>
</td>
</tr>
<tr>
<td>
<code>volumeSnapshotClassName</code><br/>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>VolumeSnapshotClassName is the name of the VolumeSnapshotClass
requested by the VolumeSnapshot.
VolumeSnapshotClassName may be left nil to indicate that the default
SnapshotClass should be used.
A given cluster may have multiple default Volume SnapshotClasses: one
default per CSI Driver. If a VolumeSnapshot does not specify a SnapshotClass,
VolumeSnapshotSource will be checked to figure out what the associated
CSI Driver is, and the default VolumeSnapshotClass associated with that
CSI Driver will be used. If more than one VolumeSnapshotClass exist for
a given CSI Driver and more than one have been marked as default,
CreateSnapshot will fail and generate an event.
Empty string is not allowed for this field.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="snapshot.storage.k8s.io/v1.VolumeSnapshotStatus">VolumeSnapshotStatus
</h3>
<p>
(<em>Appears on:</em><a href="api/volume-snapshot.html#snapshot.storage.k8s.io/v1.VolumeSnapshot">VolumeSnapshot</a>)
</p>
<div>
<p>VolumeSnapshotStatus is the status of the VolumeSnapshot
Note that CreationTime, RestoreSize, ReadyToUse, and Error are in both
VolumeSnapshotStatus and VolumeSnapshotContentStatus. Fields in VolumeSnapshotStatus
are updated based on fields in VolumeSnapshotContentStatus. They are eventual
consistency. These fields are duplicate in both objects due to the following reasons:
- Fields in VolumeSnapshotContentStatus can be used for filtering when importing a
volumesnapshot.
- VolumsnapshotStatus is used by end users because they cannot see VolumeSnapshotContent.
- CSI snapshotter sidecar is light weight as it only watches VolumeSnapshotContent
object, not VolumeSnapshot object.</p>
</div>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>boundVolumeSnapshotContentName</code><br/>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>boundVolumeSnapshotContentName is the name of the VolumeSnapshotContent
object to which this VolumeSnapshot object intends to bind to.
If not specified, it indicates that the VolumeSnapshot object has not been
successfully bound to a VolumeSnapshotContent object yet.
NOTE: To avoid possible security issues, consumers must verify binding between
VolumeSnapshot and VolumeSnapshotContent objects is successful (by validating that
both VolumeSnapshot and VolumeSnapshotContent point at each other) before using
this object.</p>
</td>
</tr>
<tr>
<td>
<code>creationTime</code><br/>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#time-v1-meta">
Kubernetes meta/v1.Time
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>creationTime is the timestamp when the point-in-time snapshot is taken
by the underlying storage system.
In dynamic snapshot creation case, this field will be filled in by the
snapshot controller with the &ldquo;creation_time&rdquo; value returned from CSI
&ldquo;CreateSnapshot&rdquo; gRPC call.
For a pre-existing snapshot, this field will be filled with the &ldquo;creation_time&rdquo;
value returned from the CSI &ldquo;ListSnapshots&rdquo; gRPC call if the driver supports it.
If not specified, it may indicate that the creation time of the snapshot is unknown.</p>
</td>
</tr>
<tr>
<td>
<code>readyToUse</code><br/>
<em>
bool
</em>
</td>
<td>
<em>(Optional)</em>
<p>readyToUse indicates if the snapshot is ready to be used to restore a volume.
In dynamic snapshot creation case, this field will be filled in by the
snapshot controller with the &ldquo;ready_to_use&rdquo; value returned from CSI
&ldquo;CreateSnapshot&rdquo; gRPC call.
For a pre-existing snapshot, this field will be filled with the &ldquo;ready_to_use&rdquo;
value returned from the CSI &ldquo;ListSnapshots&rdquo; gRPC call if the driver supports it,
otherwise, this field will be set to &ldquo;True&rdquo;.
If not specified, it means the readiness of a snapshot is unknown.</p>
</td>
</tr>
<tr>
<td>
<code>restoreSize</code><br/>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#quantity-resource-api">
k8s.io/apimachinery/pkg/api/resource.Quantity
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>restoreSize represents the minimum size of volume required to create a volume
from this snapshot.
In dynamic snapshot creation case, this field will be filled in by the
snapshot controller with the &ldquo;size_bytes&rdquo; value returned from CSI
&ldquo;CreateSnapshot&rdquo; gRPC call.
For a pre-existing snapshot, this field will be filled with the &ldquo;size_bytes&rdquo;
value returned from the CSI &ldquo;ListSnapshots&rdquo; gRPC call if the driver supports it.
When restoring a volume from this snapshot, the size of the volume MUST NOT
be smaller than the restoreSize if it is specified, otherwise the restoration will fail.
If not specified, it indicates that the size is unknown.</p>
</td>
</tr>
<tr>
<td>
<code>error</code><br/>
<em>
<a href="api/volume-snapshot.html#snapshot.storage.k8s.io/v1.VolumeSnapshotError">
VolumeSnapshotError
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>error is the last observed error during snapshot creation, if any.
This field could be helpful to upper level controllers(i.e., application controller)
to decide whether they should continue on waiting for the snapshot to be created
based on the type of error reported.
The snapshot controller will keep retrying when an error occurs during the
snapshot creation. Upon success, this error field will be cleared.</p>
</td>
</tr>
</tbody>
</table>
<hr/>
<p><em>
Generated with <code>gen-crd-api-reference-docs</code>
on git commit <code>b20011c8</code>.
</em></p><h1><a class="header" href="#troubleshooting" id="troubleshooting">Troubleshooting</a></h1>
<h1><a class="header" href="#known-issues" id="known-issues">Known Issues</a></h1>
<ul>
<li>[<a href="https://github.com/kubernetes/minikube/issues/3378">minikube-3378</a>]: Volume mount causes minikube VM to become corrupted</li>
</ul>
<h1><a class="header" href="#common-errors" id="common-errors">Common Errors</a></h1>
<h3><a class="header" href="#node-plugin-pod-does-not-start-with-runcontainererror-status" id="node-plugin-pod-does-not-start-with-runcontainererror-status">Node plugin pod does not start with <em>RunContainerError</em> status</a></h3>
<p><code>kubectl describe pod your-nodeplugin-pod</code> shows:</p>
<pre><code>failed to start container &quot;your-driver&quot;: Error response from daemon:
linux mounts: Path /var/lib/kubelet/pods is mounted on / but it is not a shared mount
</code></pre>
<p>Your Docker host is not configured to allow shared mounts. Take a look at <a href="https://kubernetes.io/docs/concepts/storage/volumes/#configuration">this page</a> for instructions to enable them.</p>
<h3><a class="header" href="#external-attacher-cant-find-volumeattachments" id="external-attacher-cant-find-volumeattachments">External attacher can't find <em>VolumeAttachments</em></a></h3>
<p>If you have a Kubernetes 1.9 cluster, not being able to list <em>VolumeAttachment</em>
and the following error are due to the lack of the
<code>storage.k8s.io/v1alpha1=true</code> runtime configuration:</p>
<pre><code>$ kubectl logs csi-pod external-attacher
...
I0306 16:34:50.976069       1 reflector.go:240] Listing and watching *v1alpha1.VolumeAttachment from github.com/kubernetes-csi/external-attacher/vendor/k8s.io/client-go/informers/factory.go:86

E0306 16:34:50.992034       1 reflector.go:205] github.com/kubernetes-csi/external-attacher/vendor/k8s.io/client-go/informers/factory.go:86: Failed to list *v1alpha1.VolumeAttachment: the server could not find the requested resource
...
</code></pre>
<p>Please see the <a href="Kubernetes-1.9.html">Kubernetes 1.9</a> page.</p>
<h3><a class="header" href="#problems-with-the-external-components" id="problems-with-the-external-components">Problems with the external components</a></h3>
<p>The external components images are under active development. It can
happen that they become incompatible with each other. If the
issues above have been ruled out, <a href="https://github.com/kubernetes/community/tree/master/sig-storage">contact the sig-storage
team</a> and/or
<a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-testing/e2e-tests.md#local-clusters">run the e2e test</a>:</p>
<pre><code>go run hack/e2e.go -- --provider=local --test --test_args=&quot;--ginkgo.focus=Feature:CSI&quot;
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="custom.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
