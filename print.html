<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Kubernetes CSI Developer Documentation</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="This site documents how to develop and deploy a Container Storage Interface (CSI) driver on Kubernetes.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><a href="developing.html"><strong aria-hidden="true">2.</strong> Developing a CSI Driver for Kubernetes</a></li><li><ol class="section"><li><a href="sidecar-containers.html"><strong aria-hidden="true">2.1.</strong> Sidecar Containers</a></li><li><ol class="section"><li><a href="external-provisioner.html"><strong aria-hidden="true">2.1.1.</strong> external-provisioner</a></li><li><a href="external-attacher.html"><strong aria-hidden="true">2.1.2.</strong> external-attacher</a></li><li><a href="external-snapshotter.html"><strong aria-hidden="true">2.1.3.</strong> external-snapshotter</a></li><li><a href="node-driver-registrar.html"><strong aria-hidden="true">2.1.4.</strong> node-driver-registrar</a></li><li><a href="cluster-driver-registrar.html"><strong aria-hidden="true">2.1.5.</strong> cluster-driver-registrar</a></li><li><a href="livenessprobe.html"><strong aria-hidden="true">2.1.6.</strong> livenessprobe</a></li></ol></li><li><a href="csi-objects.html"><strong aria-hidden="true">2.2.</strong> CSI objects</a></li><li><ol class="section"><li><a href="csi-driver-object.html"><strong aria-hidden="true">2.2.1.</strong> CSIDriver Object</a></li><li><a href="csi-node-object.html"><strong aria-hidden="true">2.2.2.</strong> CSINode Object</a></li></ol></li><li><a href="features.html"><strong aria-hidden="true">2.3.</strong> Features</a></li><li><ol class="section"><li><a href="secrets-and-credentials.html"><strong aria-hidden="true">2.3.1.</strong> Secrets &amp; Credentials</a></li><li><a href="snapshot-restore-feature.html"><strong aria-hidden="true">2.3.2.</strong> Volume Snapshot &amp; Restore</a></li><li><a href="topology.html"><strong aria-hidden="true">2.3.3.</strong> Topology</a></li><li><a href="raw-block.html"><strong aria-hidden="true">2.3.4.</strong> Raw Block Volume</a></li><li><a href="skip-attach.html"><strong aria-hidden="true">2.3.5.</strong> Skip Attach</a></li><li><a href="pod-info.html"><strong aria-hidden="true">2.3.6.</strong> Pod Info on Mount</a></li><li><a href="ephemeral-local-volumes.html"><strong aria-hidden="true">2.3.7.</strong> Ephemeral Local Volumes</a></li></ol></li></ol></li><li><a href="deploying.html"><strong aria-hidden="true">3.</strong> Deploying a CSI Driver on Kubernetes</a></li><li><ol class="section"><li><a href="example.html"><strong aria-hidden="true">3.1.</strong> Example</a></li></ol></li><li><a href="testing-drivers.html"><strong aria-hidden="true">4.</strong> Driver Testing</a></li><li><ol class="section"><li><a href="unit-testing.html"><strong aria-hidden="true">4.1.</strong> Unit Testing</a></li><li><a href="functional-testing.html"><strong aria-hidden="true">4.2.</strong> Functional Testing</a></li></ol></li><li><a href="drivers.html"><strong aria-hidden="true">5.</strong> Drivers</a></li><li><a href="troubleshooting.html"><strong aria-hidden="true">6.</strong> Troubleshooting</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Kubernetes CSI Developer Documentation</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#introduction" id="introduction"><h1>Introduction</h1></a>
<a class="header" href="#kubernetes-container-storage-interface-csi-documentation" id="kubernetes-container-storage-interface-csi-documentation"><h2>Kubernetes Container Storage Interface (CSI) Documentation</h2></a>
<p>This site documents how to develop, deploy, and test a <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md">Container Storage Interface</a> (CSI) driver on Kubernetes.</p>
<p>The <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md">Container Storage Interface</a> (CSI) is a standard for exposing arbitrary block and file storage storage systems to containerized workloads on Container Orchestration Systems (COs) like Kubernetes. Using CSI third-party storage providers can write and deploy plugins exposing new storage systems in Kubernetes without ever having to touch the core Kubernetes code.</p>
<p>The target audience for this site is third-party developers interested in developing CSI drivers for Kubernetes.</p>
<p>Kubernetes users interested in how to deploy or manage an existing CSI driver on Kubernetes should look at the documentation provided by the author of the CSI driver.</p>
<p>Kubernetes users interested in how to use a CSI driver should look at <a href="https://kubernetes.io/docs/concepts/storage/volumes/#csi">kubernetes.io documentation</a>.</p>
<a class="header" href="#kubernetes-releases" id="kubernetes-releases"><h2>Kubernetes Releases</h2></a>
<table><thead><tr><th> Kubernetes </th><th> CSI Spec Compatibility </th><th> Status </th></tr></thead><tbody>
<tr><td> v1.9       </td><td> <a href="https://github.com/container-storage-interface/spec/releases/tag/v0.1.0">v0.1.0</a>     </td><td> Alpha  </td></tr>
<tr><td> v1.10      </td><td> <a href="https://github.com/container-storage-interface/spec/releases/tag/v0.2.0">v0.2.0</a>     </td><td> Beta   </td></tr>
<tr><td> v1.11      </td><td> <a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a>     </td><td> Beta   </td></tr>
<tr><td> v1.13      </td><td> <a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a>, <a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a> </td><td> GA     </td></tr>
</tbody></table>
<a class="header" href="#development-and-deployment" id="development-and-deployment"><h1>Development and Deployment</h1></a>
<a class="header" href="#minimum-requirements-for-developing-and-deploying-a-csi-driver-for-kubernetes" id="minimum-requirements-for-developing-and-deploying-a-csi-driver-for-kubernetes"><h2>Minimum Requirements (for Developing and Deploying a CSI driver for Kubernetes)</h2></a>
<p>Kubernetes is as minimally prescriptive about packaging and deployment of a CSI Volume Driver as possible.</p>
<p>The only requirements are around how Kubernetes (master and node) components find and communicate with a CSI driver.</p>
<p>Specifically, the following is dictated by Kubernetes regarding CSI:</p>
<ul>
<li>Kubelet to CSI Driver Communication
<ul>
<li>Kubelet directly issues CSI calls (like <code>NodeStageVolume</code>, <code>NodePublishVolume</code>, etc.) to CSI drivers via a Unix Domain Socket to mount and unmount volumes.</li>
<li>Kubelet discovers CSI drivers (and the Unix Domain Socket to use to interact with a CSI driver) via the <a href="https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/#device-plugin-registration">kubelet plugin registration mechanism</a>.</li>
<li>Therefore, all CSI drivers deployed on Kubernetes MUST register themselves using the kubelet plugin registration mechanism on each supported node.</li>
</ul>
</li>
<li>Master to CSI Driver Communication
<ul>
<li>Kubernetes master components do not communicate directly (via a Unix Domain Socket or otherwise) with CSI drivers.</li>
<li>Kubernetes master components interact only with the Kubernetes API.</li>
<li>Therefore, CSI drivers that require operations that depend on the Kubernetes API (like volume create, volume attach, volume snapshot, etc.) MUST watch the Kubernetes API and trigger the appropriate CSI operations against it.</li>
</ul>
</li>
</ul>
<p>Because these requirements are minimally prescriptive, CSI driver developers are free to implement and deploy their drivers as they see fit.</p>
<p><em>That said, to ease development and deployment, the mechanism described below is recommended.</em></p>
<a class="header" href="#recommended-mechanism-for-developing-and-deploying-a-csi-driver-for-kubernetes" id="recommended-mechanism-for-developing-and-deploying-a-csi-driver-for-kubernetes"><h2>Recommended Mechanism (for Developing and Deploying a CSI driver for Kubernetes)</h2></a>
<p>The Kubernetes development team has established a &quot;Recommended Mechanism&quot; for developing, deploying, and testing CSI Drivers on Kubernetes.
It aims to reduce boilerplate code and  simplify the overall process for CSI Driver developers.</p>
<p>This &quot;Recommended Mechanism&quot; makes use of the following components:</p>
<ul>
<li>Kubernetes CSI <a href="sidecar-containers.html">Sidecar Containers</a></li>
<li>Kubernetes CSI <a href="csi-objects.html">objects</a></li>
<li>CSI <a href="testing-drivers.html">Driver Testing</a> tools</li>
</ul>
<p>To implement a CSI driver using this mechanism, a CSI driver developer should:</p>
<ol>
<li>Create a containerized application implementing the <em>Identity</em>, <em>Node</em>, and optionally the <em>Controller</em> services described in the <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md#rpc-interface">CSI specification</a>  (the CSI driver container).
<ul>
<li>See <a href="developing.html">Developing CSI Driver</a> for more information.</li>
</ul>
</li>
<li>Unit test it using csi-sanity.
<ul>
<li>See <a href="unit-testing.html">Driver - Unit Testing</a> for more information.</li>
</ul>
</li>
<li>Define Kubernetes API YAML files that deploy the CSI driver container along with appropriate sidecar containers.
<ul>
<li>See <a href="deploying.html">Deploying in Kubernetes</a> for more information.</li>
</ul>
</li>
<li>Deploy the driver on a Kubernetes cluster and run end-to-end functional tests on it.
<ul>
<li>See <a href="functional-testing.html">Driver - Functional Testing</a></li>
</ul>
</li>
</ol>
<a class="header" href="#reference-links" id="reference-links"><h2>Reference Links</h2></a>
<ul>
<li><a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md">Design Doc</a></li>
</ul>
<a class="header" href="#developing-csi-driver-for-kubernetes" id="developing-csi-driver-for-kubernetes"><h1>Developing CSI Driver for Kubernetes</h1></a>
<p>The first step to creating a CSI driver is writing an application implementing the <a href="https://grpc.io/docs/">gRPC</a> services described in the <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md#rpc-interface">CSI specification</a></p>
<p>At a minimum, CSI drivers must implement the following CSI services:</p>
<ul>
<li>CSI <code>Identity</code> service
<ul>
<li>Enables callers (Kubernetes components and CSI sidecar containers) to identify the driver and what optional functionality it supports.</li>
</ul>
</li>
<li>CSI <code>Node</code> service
<ul>
<li>Only <code>NodePublishVolume</code>, <code>NodeUnpublishVolume</code>, and <code>NodeGetCapabilities</code> are required.</li>
<li>Required methods enable callers to make a volume available at a specified path and discover what optional  functionality the driver supports.</li>
</ul>
</li>
</ul>
<p>All CSI services may be implemented in the same CSI driver application. The CSI driver application should be containerized to make it easy to deploy on Kubernetes. Once containerized, the CSI driver can be paired with CSI <a href="sidecar-containers.html">Sidecar Containers</a> and deployed in node and/or controller mode as appropriate.</p>
<a class="header" href="#capabilities" id="capabilities"><h2>Capabilities</h2></a>
<p>If your driver supports additional features, CSI &quot;capabilities&quot; can be used to advertise the optional methods/services it supports, for example:</p>
<ul>
<li><code>CONTROLLER_SERVICE</code> (<code>PluginCapability</code>)
<ul>
<li>The entire CSI <code>Controller</code> service is optional. This capability indicates the driver implement one or more of the methods in the CSI <code>Controller</code> service.</li>
</ul>
</li>
<li><code>VOLUME_ACCESSIBILITY_CONSTRAINTS</code> (<code>PluginCapability</code>)
<ul>
<li>This capability indicates the volumes for this driver may not be equally accessible from all nodes in the cluster, and that the driver will return additional topology related information that Kubernetes can use to schedule workloads more intelligently or influence where a volume will be provisioned.</li>
</ul>
</li>
<li><code>VolumeExpansion</code> (<code>PluginCapability</code>)
<ul>
<li>This capability indicates the driver supports resizing (expanding) volumes after creation.</li>
</ul>
</li>
<li><code>CREATE_DELETE_VOLUME</code> (<code>ControllerServiceCapability</code>)
<ul>
<li>This capability indicates the driver supports dynamic volume provisioning and deleting.</li>
</ul>
</li>
<li><code>PUBLISH_UNPUBLISH_VOLUME</code> (<code>ControllerServiceCapability</code>)
<ul>
<li>This capability indicates the driver implements <code>ControllerPublishVolume</code> and <code>ControllerUnpublishVolume</code> -- operations that correspond to the Kubernetes volume attach/detach operations. This may, for example, result in a &quot;volume attach&quot; operation against the Google Cloud control plane to attach the specified volume to the specified node for the Google Cloud PD CSI Driver.</li>
</ul>
</li>
<li><code>CREATE_DELETE_SNAPSHOT</code> (<code>ControllerServiceCapability</code>)
<ul>
<li>This capability indicates the driver supports provisioning volume snapshots and the ability to provision new volumes using those snapshots.</li>
</ul>
</li>
<li><code>CLONE_VOLUME</code> (<code>ControllerServiceCapability</code>)
<ul>
<li>This capability indicates the driver supports cloning of volumes.</li>
</ul>
</li>
<li><code>STAGE_UNSTAGE_VOLUME</code> (<code>NodeServiceCapability</code>)
<ul>
<li>This capability indicates the driver implements <code>NodeStageVolume</code> and <code>NodeUnstageVolume</code> -- operations that correspond to the Kubernetes volume device mount/unmount operations. This may, for example, be used to create a global (per node) volume mount of a block storage device.</li>
</ul>
</li>
</ul>
<p>This is an partial list, please see the <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md">CSI spec</a> for a complete list of capabilities.
Also see the <a href="features.html">Features</a> section to understand how a feature integrates with Kubernetes.</p>
<a class="header" href="#kubernetes-csi-sidecar-containers" id="kubernetes-csi-sidecar-containers"><h1>Kubernetes CSI Sidecar Containers</h1></a>
<p>Kubernetes CSI Sidecar Containers are a set of standard containers that aim to simplify the development and deployment of CSI Drivers on Kubernetes.</p>
<p>These containers contain common logic to watch the Kubernetes API, trigger appropriate operations against the “CSI volume driver” container, and update the Kubernetes API as appropriate.</p>
<p>The containers are intended to be bundled with third-party CSI driver containers and deployed together as pods.</p>
<p>The containers are developed and maintained by the Kubernetes Storage community.</p>
<p>Use of the containers is strictly optional, but highly recommended.</p>
<p>Benefits of these sidecar containers include:</p>
<ul>
<li>Reduction of &quot;boilerplate&quot; code.
<ul>
<li>CSI Driver developers do not have to worry about complicated, &quot;Kubernetes specific&quot; code.</li>
</ul>
</li>
<li>Separation of concerns.
<ul>
<li>Code that interacts with the Kubernetes API is isolated from (and in a different container then) the code that implements the CSI interface.</li>
</ul>
</li>
</ul>
<p>The Kubernetes development team maintains the following Kubernetes CSI Sidecar Containers:</p>
<ul>
<li><a href="external-provisioner.html">external-provisioner</a></li>
<li><a href="external-attacher.html">external-attacher</a></li>
<li><a href="external-snapshotter.html">external-snapshotter</a></li>
<li><a href="node-driver-registrar.html">node-driver-registrar</a></li>
<li><a href="cluster-driver-registrar.html">cluster-driver-registrar</a></li>
<li><a href="livenessprobe.html">livenessprobe</a></li>
</ul>
<a class="header" href="#csi-external-provisioner" id="csi-external-provisioner"><h1>CSI external-provisioner</h1></a>
<a class="header" href="#status-and-releases" id="status-and-releases"><h2>Status and Releases</h2></a>
<p><strong>Git Repository:</strong> https://github.com/kubernetes-csi/external-provisioner</p>
<p><strong>Status:</strong> GA/Stable</p>
<table><thead><tr><th>Latests stable release </th><th> Branch </th><th> Compatible with CSI Version </th><th> Container Image </th><th> Min k8s Version </th><th> Max k8s version</th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/external-provisioner/releases/tag/v1.0.1">external-provisioner v1.0.1</a> </td><td> <a href="https://github.com/kubernetes-csi/external-provisioner/tree/release-1.0">release-1.0</a> </td><td> <a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a> </td><td> quay.io/k8scsi/csi-provisioner:v1.0.1 </td><td> v1.13 </td><td> -</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-provisioner/releases/tag/v0.4.2">external-provisioner v0.4.2</a> </td><td> <a href="https://github.com/kubernetes-csi/external-provisioner/tree/release-0.4">release-0.4</a> </td><td> <a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a> </td><td> quay.io/k8scsi/csi-provisioner:v0.4.2 </td><td> v1.10 </td><td> -</td></tr>
</tbody></table>
<a class="header" href="#description" id="description"><h2>Description</h2></a>
<p>The CSI <code>external-provisioner</code> is a sidecar container that watches the Kubernetes API server for <code>PersistentVolumeClaim</code> objects.</p>
<p>It calls <code>CreateVolume</code> against the specified CSI endpoint to provision a new volume.</p>
<p>Volume provisioning is triggered by the creation of a new Kubernetes <code>PersistentVolumeClaim</code> object, if the PVC references a Kubernetes <code>StorageClass</code>, and the name in the <code>provisioner</code> field of the storage class matches the name returned by the specified CSI endpoint in the <code>GetPluginInfo</code> call.</p>
<p>Once a new volume is successfully provisioned, the sidecar container creates a Kubernetes <code>PersistentVolume</code> object to represent the volume.</p>
<p>The deletion of a <code>PersistentVolumeClaim</code> object bound to a <code>PersistentVolume</code> corresponding to this driver with a <code>delete</code> reclaim policy causes the sidecar container to trigger a <code>DeleteVolume</code> operation against the specified CSI endpoint to delete the volume. Once the volume is successfully deleted, the sidecar container also deletes the <code>PersistentVolume</code> object representing the volume.</p>
<p>The CSI <code>external-provisioner</code> also supports the <code>Snapshot</code> DataSource. If a <code>Snapshot</code> CRD is specified as a data source on a PVC object, the sidecar container fetches the information about the snapshot by fetching the <code>SnapshotContent</code> object and populates the data source field in the resulting <code>CreateVolume</code> call to indicate to the storage system that the new volume should be populated using the specified snapshot.</p>
<a class="header" href="#storageclass-parameters" id="storageclass-parameters"><h3>StorageClass Parameters</h3></a>
<p>When provisioning a new volume, the CSI <code>external-provisioner</code> sets the <code>map&lt;string, string&gt; parameters</code> field in the CSI <code>CreateVolumeRequest</code> call to the key/values specified in the <code>StorageClass</code> it is handling.</p>
<p>The CSI <code>external-provisioner</code> (v1.0.1+) also reserves the parameter keys prefixed with <code>csi.storage.k8s.io/</code>. Any keys prefixed with <code>csi.storage.k8s.io/</code> are not passed to the CSI driver as an opaque <code>parameter</code>.</p>
<p>The following reserved <code>StorageClass</code> parameter keys trigger behavior in the CSI <code>external-provisioner</code>:</p>
<ul>
<li><code>csi.storage.k8s.io/provisioner-secret-name</code></li>
<li><code>csi.storage.k8s.io/provisioner-secret-namespace</code></li>
<li><code>csi.storage.k8s.io/controller-publish-secret-name</code></li>
<li><code>csi.storage.k8s.io/controller-publish-secret-namespace</code></li>
<li><code>csi.storage.k8s.io/node-stage-secret-name</code></li>
<li><code>csi.storage.k8s.io/node-stage-secret-namespace</code></li>
<li><code>csi.storage.k8s.io/node-publish-secret-name</code></li>
<li><code>csi.storage.k8s.io/node-publish-secret-namespace</code></li>
<li><code>csi.storage.k8s.io/fstype</code></li>
</ul>
<p>If the PVC <code>VolumeMode</code> is set to <code>Filesystem</code>, and the value of <code>csi.storage.k8s.io/fstype</code> is specified, it is used to populate the <code>FsType</code> in <code>CreateVolumeRequest.VolumeCapabilities[x].AccessType</code> and the <code>AccessType</code> is set to <code>Mount</code>.</p>
<p>For more information on how secrets are handled see <a href="secrets-and-credentials.html">Secrets &amp; Credentials</a>.</p>
<p>Example <code>StorageClass</code>:</p>
<pre><code>apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: gold-example-storage
provisioner: exampledriver.example.com
parameters:
  disk-type: ssd
  csi.storage.k8s.io/fstype: ext4
  csi.storage.k8s.io/provisioner-secret-name: mysecret
  csi.storage.k8s.io/provisioner-secret-namespace: mynamespace
</code></pre>
<a class="header" href="#usage" id="usage"><h2>Usage</h2></a>
<p>CSI drivers that support dynamic volume provisioning should use this sidecar container, and advertise the CSI <code>CREATE_DELETE_VOLUME</code> controller capability.</p>
<p>For detailed information (binary parameters, RBAC rules, etc.), see https://github.com/kubernetes-csi/external-provisioner/blob/master/README.md.</p>
<a class="header" href="#deployment" id="deployment"><h2>Deployment</h2></a>
<p>The CSI <code>external-provisioner</code> is deployed as a controller. See <a href="deploying.html">deployment section</a> for more details.</p>
<a class="header" href="#csi-external-attacher" id="csi-external-attacher"><h1>CSI external-attacher</h1></a>
<a class="header" href="#status-and-releases-1" id="status-and-releases-1"><h2>Status and Releases</h2></a>
<p><strong>Git Repository:</strong> https://github.com/kubernetes-csi/external-attacher</p>
<p><strong>Status:</strong> GA/Stable</p>
<table><thead><tr><th>Latests stable release </th><th> Branch </th><th> Compatible with CSI Version </th><th> Container Image </th><th> Min k8s Version </th><th> Max k8s version</th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/external-attacher/releases/tag/v1.0.1">external-attacher v1.0.1</a> </td><td> <a href="https://github.com/kubernetes-csi/external-attacher/tree/release-1.0">release-1.0</a> </td><td> <a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a> </td><td> quay.io/k8scsi/csi-attacher:v1.0.1 </td><td> v1.13 </td><td> -</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-attacher/releases/tag/v0.4.2">external-attacher v0.4.2</a> </td><td> <a href="https://github.com/kubernetes-csi/external-attacher/tree/release-0.4">release-0.4</a> </td><td> <a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a> </td><td> quay.io/k8scsi/csi-attacher:v0.4.2 </td><td> v1.10 </td><td> -</td></tr>
</tbody></table>
<a class="header" href="#description-1" id="description-1"><h2>Description</h2></a>
<p>The CSI <code>external-attacher</code> is a sidecar container that watches the Kubernetes API server for <code>VolumeAttachment</code> objects and triggers <code>Controller[Publish|Unpublish]Volume</code> operations against a CSI endpoint.</p>
<a class="header" href="#usage-1" id="usage-1"><h2>Usage</h2></a>
<p>CSI drivers that require integrating with the Kubernetes volume attach/detach hooks should use this sidecar container, and advertise the CSI <code>PUBLISH_UNPUBLISH_VOLUME</code> controller capability.</p>
<p>For detailed information (binary parameters, RBAC rules, etc.), see https://github.com/kubernetes-csi/external-attacher/blob/master/README.md.</p>
<a class="header" href="#deployment-1" id="deployment-1"><h2>Deployment</h2></a>
<p>The CSI <code>external-attacher</code> is deployed as a controller. See <a href="deploying.html">deployment section</a> for more details.</p>
<a class="header" href="#csi-external-snapshotter" id="csi-external-snapshotter"><h1>CSI external-snapshotter</h1></a>
<a class="header" href="#status-and-releases-2" id="status-and-releases-2"><h2>Status and Releases</h2></a>
<p><strong>Git Repository:</strong> https://github.com/kubernetes-csi/external-snapshotter</p>
<p><strong>Status:</strong> Alpha</p>
<table><thead><tr><th>Latests stable release </th><th> Branch </th><th> Compatible with CSI Version </th><th> Container Image </th><th> Min k8s Version </th><th> Max k8s version</th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/external-snapshotter/releases/tag/v1.0.1">external-snapshotter v1.0.1</a> </td><td> <a href="https://github.com/kubernetes-csi/external-snapshotter/tree/release-1.0">release-1.0</a> </td><td> <a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a> </td><td> quay.io/k8scsi/csi-snapshotter:v1.0.1 </td><td> v1.13 </td><td> -</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/external-snapshotter/releases/tag/v0.4.1">external-snapshotter v0.4.1</a> </td><td> <a href="https://github.com/kubernetes-csi/external-snapshotter/tree/release-0.4">release-0.4</a> </td><td> <a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a> </td><td> quay.io/k8scsi/csi-snapshotter:v0.4.1 </td><td> v1.10 </td><td> -</td></tr>
</tbody></table>
<a class="header" href="#description-2" id="description-2"><h2>Description</h2></a>
<p>The CSI <code>external-snapshotter</code> is a sidecar container that watches the Kubernetes API server for <code>VolumeSnapshot</code> and <code>VolumeSnapshotContent</code> CRD objects.</p>
<p>The creation of a new <code>VolumeSnapshot</code> object referencing a <code>SnapshotClass</code> CRD object corresponding to this driver causes the sidecar container to trigger a <code>CreateSnapshot</code> operation against the specified CSI endpoint to provision a new snapshot. When a new snapshot is successfully provisioned, the sidecar container creates a Kubernetes <code>VolumeSnapshotContent</code> object to represent the new snapshot.</p>
<p>The deletion of a <code>VolumeSnapshot</code> object bound to a <code>VolumeSnapshotContent</code> corresponding to this driver with a <code>delete</code> reclaim policy causes the sidecar container to trigger a <code>DeleteSnapshot</code> operation against the specified CSI endpoint to delete the snapshot. Once the snapshot is successfully deleted, the sidecar container also deletes the <code>VolumeSnapshotContent</code> object representing the snapshot.</p>
<p>For detailed information about volume snapshot and restore functionality, see <a href="snapshot-restore-feature.html">Volume Snapshot &amp; Restore</a>.</p>
<a class="header" href="#usage-2" id="usage-2"><h2>Usage</h2></a>
<p>CSI drivers that support provisioning volume snapshots and the ability to provision new volumes using those snapshots should use this sidecar container, and advertise the CSI <code>CREATE_DELETE_SNAPSHOT</code> controller capability.</p>
<p>For detailed information (binary parameters, RBAC rules, etc.), see https://github.com/kubernetes-csi/external-snapshotter/blob/master/README.md.</p>
<a class="header" href="#deployment-2" id="deployment-2"><h2>Deployment</h2></a>
<p>The CSI <code>external-snapshotter</code> is deployed as a controller. See <a href="deploying.html">deployment section</a> for more details.</p>
<p>For an example deployment, see <a href="https://github.com/kubernetes-csi/external-snapshotter/tree/master/deploy/kubernetes/setup-csi-snapshotter.yaml">this example</a> which deploys <code>external-snapshotter</code> and <code>external-provisioner</code> with the Hostpath CSI driver.</p>
<a class="header" href="#csi-node-driver-registrar" id="csi-node-driver-registrar"><h1>CSI node-driver-registrar</h1></a>
<a class="header" href="#status-and-releases-3" id="status-and-releases-3"><h2>Status and Releases</h2></a>
<p><strong>Git Repository:</strong> https://github.com/kubernetes-csi/node-driver-registrar</p>
<p><strong>Status:</strong> GA/Stable</p>
<table><thead><tr><th>Latests stable release </th><th> Branch </th><th> Compatible with CSI Version </th><th> Container Image </th><th> Min k8s Version </th><th> Max k8s version</th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/node-driver-registrar/releases/tag/v1.0.2">node-driver-registrar v1.0.2</a> </td><td> <a href="https://github.com/kubernetes-csi/node-driver-registrar/tree/release-1.0">release-1.0</a> </td><td> <a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a> </td><td> quay.io/k8scsi/csi-node-driver-registrar:v1.0.2 </td><td> v1.13 </td><td> -</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/driver-registrar/releases/tag/v0.4.2">driver-registrar v0.4.2</a> </td><td> <a href="https://github.com/kubernetes-csi/driver-registrar/tree/release-0.4">release-0.4</a> </td><td> <a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a> </td><td> quay.io/k8scsi/driver-registrar:v0.4.2 </td><td> v1.10 </td><td> -</td></tr>
</tbody></table>
<a class="header" href="#description-3" id="description-3"><h2>Description</h2></a>
<p>The CSI <code>node-driver-registrar</code> is a sidecar container that fetches driver information (using <code>NodeGetInfo</code>) from a CSI endpoint and registers it with the kubelet on that node using the <a href="https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/#device-plugin-registration">kubelet plugin registration mechanism</a>.</p>
<a class="header" href="#usage-3" id="usage-3"><h2>Usage</h2></a>
<p>Kubelet directly issues CSI <code>NodeGetInfo</code>, <code>NodeStageVolume</code>, and <code>NodePublishVolume</code> calls against CSI drivers. It uses the <a href="https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/#device-plugin-registration">kubelet plugin registration mechanism</a> to discover the unix domain socket to talk to the CSI driver. Therefore, all CSI drivers should use this sidecar container to register themselves with kubelet.</p>
<p>For detailed information (binary parameters, etc.), see the README of the relevant branch.</p>
<a class="header" href="#deployment-3" id="deployment-3"><h2>Deployment</h2></a>
<p>The CSI <code>node-driver-registrar</code> is deployed per node. See <a href="deploying.html">deployment section</a> for more details.</p>
<a class="header" href="#csi-cluster-driver-registrar" id="csi-cluster-driver-registrar"><h1>CSI cluster-driver-registrar</h1></a>
<a class="header" href="#status-and-releases-4" id="status-and-releases-4"><h2>Status and Releases</h2></a>
<p><strong>Git Repository:</strong> https://github.com/kubernetes-csi/cluster-driver-registrar</p>
<p><strong>Status:</strong> Alpha</p>
<table><thead><tr><th>Latests stable release </th><th> Branch </th><th> Compatible with CSI Version </th><th> Container Image </th><th> Min k8s Version </th><th> Max k8s version</th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/cluster-driver-registrar/releases/tag/v1.0.1">cluster-driver-registrar v1.0.1</a> </td><td> <a href="https://github.com/kubernetes-csi/cluster-driver-registrar/tree/release-1.0">release-1.0</a> </td><td>  <a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a> </td><td> quay.io/k8scsi/csi-cluster-driver-registrar:v1.0.1 </td><td> v1.13 </td><td> -</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/driver-registrar/releases/tag/v0.4.2">driver-registrar v0.4.2</a> </td><td> <a href="https://github.com/kubernetes-csi/driver-registrar/tree/release-0.4">release-0.4</a> </td><td> <a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a> </td><td> quay.io/k8scsi/driver-registrar:v0.4.2 </td><td> v1.10 </td><td> -</td></tr>
</tbody></table>
<a class="header" href="#description-4" id="description-4"><h2>Description</h2></a>
<p>The CSI <code>cluster-driver-registrar</code> is a sidecar container that registers a CSI Driver with a Kubernetes cluster by creating a <a href="csi-driver-object.html">CSIDriver Object</a> which enables the driver to customize how Kubernetes interacts with it.</p>
<a class="header" href="#usage-4" id="usage-4"><h2>Usage</h2></a>
<p>CSI drivers that use one of the following Kubernetes features should use this sidecar container:</p>
<ul>
<li><a href="skip-attach.html">Skip Attach</a>
<ul>
<li>For drivers that don't support <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md#controllerpublishvolume"><code>ControllerPublishVolume</code></a>, this indicates to Kubernetes to skip the attach operation and eliminates the need to deploy the <code>external-attacher</code> sidecar.</li>
</ul>
</li>
<li><a href="pod-info.html">Pod Info on Mount</a>
<ul>
<li>This causes Kubernetes to pass metadata such as Pod name and namespace to the <code>NodePublishVolume</code> call.</li>
</ul>
</li>
</ul>
<p>If you are not using one of these features, this sidecar container (and the creation of the <a href="csi-driver-object.html">CSIDriver Object</a>) is not required. However, it is still recommended, because the <a href="csi-driver-object.html">CSIDriver Object</a> makes it easier for users to easily discover the CSI drivers installed on their clusters.</p>
<p>For detailed information (binary parameters, etc.), see the README of the relevant branch.</p>
<a class="header" href="#deployment-4" id="deployment-4"><h2>Deployment</h2></a>
<p>The CSI <code>cluster-driver-registrar</code> is deployed as a controller. See <a href="deploying.html">deployment section</a> for more details.</p>
<a class="header" href="#csi-livenessprobe" id="csi-livenessprobe"><h1>CSI livenessprobe</h1></a>
<a class="header" href="#status-and-releases-5" id="status-and-releases-5"><h2>Status and Releases</h2></a>
<p><strong>Git Repository:</strong> https://github.com/kubernetes-csi/livenessprobe</p>
<p><strong>Status:</strong> GA/Stable</p>
<table><thead><tr><th>Latests stable release </th><th> Branch </th><th> Compatible with CSI Version </th><th> Container Image </th><th> Min k8s Version </th><th> Max k8s version</th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/livenessprobe/releases/tag/v1.0.2">livenessprobe v1.0.2</a> </td><td> <a href="https://github.com/kubernetes-csi/livenessprobe/tree/release-1.0">release-1.0</a> </td><td> <a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0">v1.0.0</a> </td><td> quay.io/k8scsi/livenessprobe:v1.0.2 </td><td> v1.13 </td><td> -</td></tr>
<tr><td>Unsupported. </td><td> No 0.x branch. </td><td> <a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0">v0.3.0</a> </td><td> quay.io/k8scsi/livenessprobe:v0.4.1 </td><td> v1.10 </td><td> -</td></tr>
</tbody></table>
<a class="header" href="#description-5" id="description-5"><h2>Description</h2></a>
<p>The CSI <code>livenessprobe</code> is a sidecar container that monitors the health of the CSI driver and reports it to Kubernetes via the <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/">Liveness Probe mechanism</a>. This enables Kubernetes to automatically detect issues with the driver and restart the pod to try and fix the issue.</p>
<a class="header" href="#usage-5" id="usage-5"><h2>Usage</h2></a>
<p>All CSI drivers should use the liveness probe to improve the availability of the driver while deployed on Kubernetes.</p>
<p>For detailed information (binary parameters, RBAC rules, etc.), see https://github.com/kubernetes-csi/livenessprobe/blob/master/README.md.</p>
<a class="header" href="#deployment-5" id="deployment-5"><h2>Deployment</h2></a>
<p>The CSI <code>livenessprobe</code> is deployed as part of controller and node deployments. See <a href="deploying.html">deployment section</a> for more details.</p>
<a class="header" href="#csi-objects" id="csi-objects"><h1>CSI objects</h1></a>
<p><strong>Status:</strong> Beta</p>
<p>The Kubernetes API contains the following CSI specific objects:</p>
<ul>
<li><a href="csi-driver-object.html">CSIDriver Object</a></li>
<li><a href="csi-node-object.html">CSINode Object</a></li>
</ul>
<p>Both are part of <code>storage.k8s.io/v1beta1</code> API group.</p>
<p>The schema definition for the objects can be found here: https://github.com/kubernetes/kubernetes/blob/master/pkg/apis/storage/types.go</p>
<a class="header" href="#csidriver-object" id="csidriver-object"><h1>CSIDriver Object</h1></a>
<a class="header" href="#status" id="status"><h2>Status</h2></a>
<ul>
<li>Kubernetes 1.12 - 1.13: Alpha</li>
<li>Kubernetes 1.14: Beta</li>
</ul>
<a class="header" href="#what-is-the-csidriver-object" id="what-is-the-csidriver-object"><h2>What is the CSIDriver object?</h2></a>
<p>The <code>CSIDriver</code> Kubernetes API object serves two purposes:</p>
<ol>
<li>Simplify driver discovery</li>
</ol>
<ul>
<li>If a CSI driver creates a <code>CSIDriver</code> object, Kubernetes users can easily discover the CSI Drivers installed on their cluster (simply by issuing <code>kubectl get CSIDriver</code>)</li>
</ul>
<ol start="2">
<li>Customizing Kubernetes behavior</li>
</ol>
<ul>
<li>Kubernetes has a default set of behaviors when dealing with CSI Drivers (for example, it calls the <code>Attach</code>/<code>Detach</code> operations by default). This object allows CSI drivers to specify how Kubernetes should interact with it.</li>
</ul>
<a class="header" href="#what-fields-does-the-csidriver-object-have" id="what-fields-does-the-csidriver-object-have"><h2>What fields does the <code>CSIDriver</code> object have?</h2></a>
<p>Here is an example of a v1beta1 <code>CSIDriver</code> object:</p>
<pre><code class="language-YAML">apiVersion: storage.k8s.io/v1beta1
kind: CSIDriver
metadata:
  name: mycsidriver.example.com
spec:
  attachRequired: true
  podInfoOnMount: true
</code></pre>
<p>There are three important fields:</p>
<ul>
<li><code>name</code>
<ul>
<li>This should correspond to the full name of the CSI driver.</li>
</ul>
</li>
<li><code>attachRequired</code>
<ul>
<li>Indicates this CSI volume driver requires an attach operation (because it implements the CSI <code>ControllerPublishVolume</code> method), and that Kubernetes should call attach and wait for any attach operation to complete before proceeding to mounting.</li>
<li>If a <code>CSIDriver</code> object does not exist for a given CSI Driver, the default is <code>true</code> -- meaning attach will be called.</li>
<li>If a <code>CSIDriver</code> object exists for a given CSI Driver, but this field is not specified, it also defaults to <code>true</code> -- meaning attach will be called.</li>
<li>For more information see <a href="skip-attach.html">Skip Attach</a>.</li>
</ul>
</li>
<li><code>podInfoOnMount</code>
<ul>
<li>Indicates this CSI volume driver requires additional pod information (like pod name, pod UID, etc.) during mount operations.</li>
<li>If value is not specified or <code>false</code>, pod information will not be passed on mount.</li>
<li>If value is set to <code>true</code>, Kubelet will pass pod information as <code>volume_context</code> in CSI <code>NodePublishVolume</code> calls:
<ul>
<li><code>&quot;csi.storage.k8s.io/pod.name&quot;: pod.Name</code></li>
<li><code>&quot;csi.storage.k8s.io/pod.namespace&quot;: pod.Namespace</code></li>
<li><code>&quot;csi.storage.k8s.io/pod.uid&quot;: string(pod.UID)</code></li>
</ul>
</li>
<li>For more information see <a href="pod-info.html">Pod Info on Mount</a>.</li>
</ul>
</li>
</ul>
<a class="header" href="#what-creates-the-csidriver-object" id="what-creates-the-csidriver-object"><h2>What creates the CSIDriver object?</h2></a>
<p>CSI drivers do not need to create the <code>CSIDriver</code> object directly. Instead they may use the <a href="cluster-driver-registrar.html">cluster-driver-registrar</a> sidecar container (customizing it as needed with startup parameters). When deployed with a CSI driver, this sidecar will automatically creates a <code>CSIDriver</code> object to represent the driver.</p>
<a class="header" href="#listing-registered-csi-drivers" id="listing-registered-csi-drivers"><h3>Listing registered CSI drivers</h3></a>
<p>Using the <code>CSIDriver</code> object, it is now possible to query Kubernetes to get a list of registered drivers running in the cluster as shown below:</p>
<pre><code>$&gt; kubectl get csidrivers.storage.k8s.io
NAME           AGE
csi-hostpath   2m
</code></pre>
<p>Or get a more detailed view of your registered driver with:</p>
<pre><code>$&gt; kubectl describe csidrivers.storage.k8s.io
Name:         csi-hostpath
Namespace:
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;
API Version:  storage.k8s.io/v1beta1
Kind:         CSIDriver
Metadata:
  Creation Timestamp:  2018-10-04T21:15:30Z
  Generation:          1
  Resource Version:    390
  Self Link:           /apis/storage.k8s.io/v1beta1/csidrivers/csi-hostpath
  UID:                 9f854aa6-c81a-11e8-bdce-000c29e88ff1
Spec:
  Attach Required:            true
  Pod Info On Mount:          false
Events:                       &lt;none&gt;
</code></pre>
<a class="header" href="#changes-from-alpha-to-beta" id="changes-from-alpha-to-beta"><h2>Changes from Alpha to Beta</h2></a>
<a class="header" href="#crd-to-built-in-type" id="crd-to-built-in-type"><h3>CRD to Built in Type</h3></a>
<p>During alpha development, the <code>CSIDriver</code> object was also defined as a <a href="https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/#create-a-customresourcedefinition">Custom Resource Definition</a> (CRD). As part of the promotion to beta the object has been moved to the built-in Kubernetes API.</p>
<p>In the move from alpha to beta, the API Group for this object changed from <code>csi.storage.k8s.io/v1alpha1</code> to <code>storage.k8s.io/v1beta1</code>.</p>
<p>There is no automatic update of existing CRDs and their CRs during Kubernetes update to the new build-in type.</p>
<a class="header" href="#enabling-csidriver-on-kubernetes" id="enabling-csidriver-on-kubernetes"><h3>Enabling CSIDriver on Kubernetes</h3></a>
<p>In Kubernetes v1.12 and v1.13, because the feature was alpha, it was disabled by default. To enable the use of <code>CSIDriver</code> on these versions, do the following:</p>
<ol>
<li>Ensure the feature gate is enabled via the following Kubernetes feature flag: <code>--feature-gates=CSIDriverRegistry=true</code></li>
<li>Either ensure the <code>CSIDriver</code> CRD is automatically installed via the <a href="https://github.com/kubernetes/kubernetes/tree/master/cluster/addons/storage-crds">Kubernetes Storage CRD addon</a> OR manually install the <code>CSIDriver</code> CRD on the Kubernetes cluster with the following command:</li>
</ol>
<pre><code>$&gt; kubectl create -f https://raw.githubusercontent.com/kubernetes/csi-api/master/pkg/crd/manifests/csidriver.yaml
</code></pre>
<p>Kubernetes v1.14+, uses the same Kubernetes feature flag, but because the feature is beta, it is enabled by default. And since the API type (as of beta) is built in to the Kubernetes API, installation of the CRD is no longer required.</p>
<a class="header" href="#csinode-object" id="csinode-object"><h1>CSINode Object</h1></a>
<a class="header" href="#status-1" id="status-1"><h2>Status</h2></a>
<ul>
<li>Kubernetes 1.12 - 1.13: Alpha</li>
<li>Kubernetes 1.14: Beta</li>
</ul>
<a class="header" href="#what-is-the-csinode-object" id="what-is-the-csinode-object"><h2>What is the CSINode object?</h2></a>
<p>CSI drivers generate node specific information. Instead of storing this in the Kubernetes <code>Node</code> API Object, a new CSI specific Kubernetes <code>CSINode</code> object was created.</p>
<p>It serves the following purposes:</p>
<ol>
<li>Mapping Kubernetes node name to CSI Node name,</li>
</ol>
<ul>
<li>The CSI <code>GetNodeInfo</code> call returns the name by which the storage system refers to a node. Kubernetes must use this name in future <code>ControllerPublishVolume</code> calls. Therefore, when a new CSI driver is registered, Kubernetes stores the storage system node ID in the <code>CSINode</code> object for future reference.</li>
</ul>
<ol start="2">
<li>Driver availability</li>
</ol>
<ul>
<li>A way for kubelet to communicate to the kube-controller-manager and kubernetes scheduler whether the driver is available (registered) on the node or not.</li>
</ul>
<ol start="3">
<li>Volume topology</li>
</ol>
<ul>
<li>The CSI <code>GetNodeInfo</code> call returns a set of keys/values labels identifying the topology of that node. Kubernetes uses this information to to do topology-aware provisioning (see <a href="https://kubernetes.io/docs/concepts/storage/storage-classes/#volume-binding-mode">PVC Volume Binding Modes</a> for more details). It stores the key/values as labels on the Kubernetes node object. In order to recall which <code>Node</code> label keys belong to a specific CSI driver, the kubelet stores the keys in the <code>CSINode</code> object for future reference.</li>
</ul>
<a class="header" href="#what-fields-does-the-csinode-object-have" id="what-fields-does-the-csinode-object-have"><h2>What fields does the CSINode object have?</h2></a>
<p>Here is an example of a v1beta1 <code>CSINode</code> object:</p>
<pre><code class="language-YAML">apiVersion: storage.k8s.io/v1beta1
kind: CSINodeInfo
metadata:
  name: node1
spec:
  drivers:
  - name: mycsidriver.example.com
    nodeID: storageNodeID1
    topologyKeys: ['mycsidriver.example.com/regions', &quot;mycsidriver.example.com/zones&quot;]
</code></pre>
<p>What the fields mean:</p>
<ul>
<li><code>drivers</code> - list of CSI drivers running on the node and their properties.</li>
<li><code>name</code> - the CSI driver that this object refers to.</li>
<li><code>nodeID</code> - the assigned identifier for the node as determined by the driver.</li>
<li><code>topologyKeys</code> - A list of topology keys assigned to the node as supported by the driver.</li>
</ul>
<a class="header" href="#what-creates-the-csinode-object" id="what-creates-the-csinode-object"><h2>What creates the CSINode object?</h2></a>
<p>CSI drivers do not need to create the <code>CSINode</code> object directly. Instead they should use the <a href="node-driver-registrar.html">node-driver-registrar</a> sidecar container. This sidecar container will interact with kubelet via the kubelet plugin registration mechanism to automatically populate the <code>CSINode</code> object on behalf of the the CSI driver.</p>
<a class="header" href="#changes-from-alpha-to-beta-1" id="changes-from-alpha-to-beta-1"><h2>Changes from Alpha to Beta</h2></a>
<a class="header" href="#crd-to-built-in-type-1" id="crd-to-built-in-type-1"><h3>CRD to Built in Type</h3></a>
<p>The alpha object was called <code>CSINodeInfo</code>, whereas the beta object is called
CSINode<code>. The alpha</code>CSINodeInfo` object was also defined as a <a href="https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/#create-a-customresourcedefinition">Custom Resource Definition</a> (CRD). As part of the promotion to beta the object has been moved to the built-in Kubernetes API.</p>
<p>In the move from alpha to beta, the API Group for this object changed from <code>csi.storage.k8s.io/v1alpha1</code> to <code>storage.k8s.io/v1beta1</code>.</p>
<p>There is no automatic update of existing CRDs and their CRs during Kubernetes update to the new build-in type.</p>
<a class="header" href="#enabling-csinodeinfo-on-kubernetes" id="enabling-csinodeinfo-on-kubernetes"><h3>Enabling CSINodeInfo on Kubernetes</h3></a>
<p>In Kubernetes v1.12 and v1.13, because the feature was alpha, it was disabled by default. To enable the use of <code>CSINodeInfo</code> on these versions, do the following:</p>
<ol>
<li>Ensure the feature gate is enabled with <code>--feature-gates=CSINodeInfo=true</code></li>
<li>Either ensure the <code>CSIDriver</code> CRD is automatically installed via the <a href="https://github.com/kubernetes/kubernetes/tree/release-1.13/cluster/addons/storage-crds">Kubernetes Storage CRD addon</a> OR manually install the <code>CSINodeInfo</code> CRD on the Kubernetes cluster with the following command:</li>
</ol>
<pre><code>$&gt; kubectl create -f https://raw.githubusercontent.com/kubernetes/csi-api/master/pkg/crd/manifests/csinodeinfo.yaml
</code></pre>
<p>Kubernetes v1.14+, uses the same Kubernetes feature flag, but because the feature is beta, it is enabled by default. And since the API type (as of beta) is built in to the Kubernetes API, installation of the CRD is no longer required.</p>
<a class="header" href="#features" id="features"><h1>Features</h1></a>
<p>The Kubernetes implementation of CSI has multiple sub-features. This section describes these sub-features, their status (although support for CSI in Kubernetes is GA/stable, support of sub-features moves independently so sub-features maybe alpha or beta), and how to integrate them in to your CSI Driver.</p>
<a class="header" href="#secrets-and-credentials" id="secrets-and-credentials"><h1>Secrets and Credentials</h1></a>
<a class="header" href="#csi-driver-secrets" id="csi-driver-secrets"><h2>CSI Driver Secrets</h2></a>
<p>Some drivers may require a secret in order to issue operations against a backend (a service account, for example).
If this secret is required at the &quot;per driver&quot; granularity (and not different &quot;per CSI operation&quot; or &quot;per volume&quot;), the secret may be injected in to CSI driver pods via <a href="https://kubernetes.io/docs/tasks/inject-data-application/distribute-credentials-secure/">standard Kubernetes secret distribution mechanisms</a>.</p>
<a class="header" href="#csi-operation-secrets" id="csi-operation-secrets"><h2>CSI Operation Secrets</h2></a>
<p>The CSI spec also accepts secrets in each of the following protos:</p>
<ul>
<li><code>CreateVolumeRequest</code></li>
<li><code>DeleteVolumeRequest</code></li>
<li><code>ControllerPublishVolumeRequest</code></li>
<li><code>ControllerUnpublishVolumeRequest</code></li>
<li><code>CreateSnapshotRequest</code></li>
<li><code>DeleteSnapshotRequest</code></li>
<li><code>ControllerExpandVolumeRequest</code></li>
<li><code>NodeStageVolumeRequest</code></li>
<li><code>NodePublishVolumeRequest</code></li>
</ul>
<p>These enable CSI drivers to accept/require &quot;per CSI operation&quot; or &quot;per volume&quot; secrets (a volume encryption key, for example).</p>
<p>The CSI <a href="external-provisioner.html">external-provisioner</a> enables Kubernetes cluster admins to populate the secret fields for these protos with data from Kubernetes <code>Secret</code> objects. For example:</p>
<pre><code class="language-yaml">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: fast-storage
provisioner: csi-driver.team.example.com
parameters:
  type: pd-ssd
  csi.storage.k8s.io/provisioner-secret-name: fast-storage-provision-key
  csi.storage.k8s.io/provisioner-secret-namespace: pd-ssd-credentials
</code></pre>
<a class="header" href="#createdelete-volume-secret" id="createdelete-volume-secret"><h3>Create/Delete Volume Secret</h3></a>
<p>The CSI <code>external-provisioner</code> (v1.0.1+) looks for the following keys in <code>StorageClass.parameters</code>:</p>
<ul>
<li><code>csi.storage.k8s.io/provisioner-secret-name</code></li>
<li><code>csi.storage.k8s.io/provisioner-secret-namespace</code></li>
</ul>
<p>The value of both parameters refers to the name and namespace of the <code>Secret</code> object in the Kubernetes API.</p>
<p>The value of both parameters may be a literal or a template containing the following variable that are automatically replaced by the <code>external-provisioner</code> at provision time:</p>
<pre><code>* `${pv.name}`
  * Automatically replaced with the name of the `PersistentVolume` object being provisioned at provision.
</code></pre>
<p>If specified, the CSI <code>external-provisioner</code> will attempt to fetch the secret before provisioning and deletion.</p>
<p>If no such secret exists in the Kubernetes API, or the provisioner is unable to fetch it, the provision or delete operation fails.</p>
<p>If the secret is retrieved successfully, the provisioner passes it to the CSI driver in the <code>CreateVolumeRequest.secrets</code> or <code>DeleteVolumeRequest.secrets</code> field.</p>
<a class="header" href="#controller-publishunpublish-secret" id="controller-publishunpublish-secret"><h3>Controller Publish/Unpublish Secret</h3></a>
<p>The CSI <code>external-provisioner</code> (v1.0.1+) looks for the following keys in <code>StorageClass.parameters</code>:</p>
<ul>
<li><code>csi.storage.k8s.io/controller-publish-secret-name</code></li>
<li><code>csi.storage.k8s.io/controller-publish-secret-namespace</code></li>
</ul>
<p>The value of both parameters refers to the name and namespace of the <code>Secret</code> object in the Kubernetes API.</p>
<p>The value of both parameters may be a literal or a template containing the following variables that are automatically replaced by the <code>external-provisioner</code> at provision time:</p>
<ul>
<li><code>${pv.name}</code>
<ul>
<li>Automatically replaced with the name of the <code>PersistentVolume</code> object being provisioned.</li>
</ul>
</li>
<li><code>${pvc.namespace}</code>
<ul>
<li>Automatically replaced with the namespace of the <code>PersistentVolumeClaim</code> object being provisioned.</li>
</ul>
</li>
</ul>
<p>The value of <code>csi.storage.k8s.io/controller-publish-secret-namespace</code> also supports the following template variables which are automatically replaced by the <code>external-provisioner</code> at provision time:</p>
<ul>
<li><code>${pvc.name}</code>
<ul>
<li>Automatically replaced with the name of the <code>PersistentVolumeClaim</code> object being provisioned.</li>
</ul>
</li>
<li><code>${pvc.annotations['&lt;ANNOTATION_KEY&gt;']}</code> (e.g. <code>${pvc.annotations['example.com/key']}</code>)
<ul>
<li>Automatically replaced with the value of the specified annotation from the <code>PersistentVolumeClaim</code> object being provisioned.</li>
</ul>
</li>
</ul>
<p>If specified, once provisioning is successful, the CSI <code>external-provisioner</code> sets the <code>CSIPersistentVolumeSource.ControllerPublishSecretRef</code> field in the new <code>PersistentVolume</code> object to refer to this secret.</p>
<p>If specified, the CSI <code>external-attacher</code> attempts to fetch the secret referenced by the <code>CSIPersistentVolumeSource.ControllerPublishSecretRef</code> before an attach or detach operation.</p>
<p>If no such secret exists in the Kubernetes API, or the <code>external-attacher</code> is unable to fetch it, the attach or detach operation fails.</p>
<p>If the secret is retrieved successfully, the <code>external-attacher</code> passes it to the CSI driver in the <code>ControllerPublishVolumeRequest.secrets</code> or <code>ControllerUnpublishVolumeRequest.secrets</code> field.</p>
<a class="header" href="#node-stage-secret" id="node-stage-secret"><h3>Node Stage Secret</h3></a>
<p>The CSI <code>external-provisioner</code> (v1.0.1+) looks for the following keys in <code>StorageClass.parameters</code>:</p>
<ul>
<li><code>csi.storage.k8s.io/node-stage-secret-name</code></li>
<li><code>csi.storage.k8s.io/node-stage-secret-namespace</code></li>
</ul>
<p>The value of both parameters refers to the name and namespace of the <code>Secret</code> object in the Kubernetes API.</p>
<p>The value of both parameters may be a literal or a template containing the following variables that are automatically replaced by the <code>external-provisioner</code> at provision time:</p>
<ul>
<li><code>${pv.name}</code>
<ul>
<li>Automatically replaced with the name of the <code>PersistentVolume</code> object being provisioned.</li>
</ul>
</li>
<li><code>${pvc.namespace}</code>
<ul>
<li>Automatically replaced with the namespace of the <code>PersistentVolumeClaim</code> object being provisioned.</li>
</ul>
</li>
</ul>
<p>The value of <code>csi.storage.k8s.io/node-stage-secret-namespace</code> also supports the following template variables which are automatically replaced by the <code>external-provisioner</code> at provision time:</p>
<ul>
<li><code>${pvc.name}</code>
<ul>
<li>Automatically replaced with the name of the <code>PersistentVolumeClaim</code> object being provisioned.</li>
</ul>
</li>
<li><code>${pvc.annotations['&lt;ANNOTATION_KEY&gt;']}</code> (e.g. <code>${pvc.annotations['example.com/key']}</code>)
<ul>
<li>Automatically replaced with the value of the specified annotation from the <code>PersistentVolumeClaim</code> object being provisioned.</li>
</ul>
</li>
</ul>
<p>If specified, once provisioning is successful, the CSI <code>external-provisioner</code> sets the <code>CSIPersistentVolumeSource.NodeStageSecretRef</code> field in the new <code>PersistentVolume</code> object to refer to this secret.</p>
<p>If specified, the Kubernetes kubelet, attempts to fetch the secret referenced by the <code>CSIPersistentVolumeSource.NodeStageSecretRef</code> field before a mount device operation.</p>
<p>If no such secret exists in the Kubernetes API, or the kubelet is unable to fetch it, the mount device operation fails.</p>
<p>If the secret is retrieved successfully, the kubelet passes it to the CSI driver in the <code>NodeStageVolumeRequest.secrets</code> field.</p>
<a class="header" href="#node-publish-secret" id="node-publish-secret"><h3>Node Publish Secret</h3></a>
<p>The CSI <code>external-provisioner</code> (v1.0.1+) looks for the following keys in <code>StorageClass.parameters</code>:</p>
<ul>
<li><code>csi.storage.k8s.io/node-publish-secret-name</code></li>
<li><code>csi.storage.k8s.io/node-publish-secret-namespace</code></li>
</ul>
<p>The value of both parameters refers to the name and namespace of the <code>Secret</code> object in the Kubernetes API.</p>
<p>The value of both parameters may be a literal or a template containing the following variables that are automatically replaced by the <code>external-provisioner</code> at provision time:</p>
<ul>
<li><code>${pv.name}</code>
<ul>
<li>Automatically replaced with the name of the <code>PersistentVolume</code> object being provisioned.</li>
</ul>
</li>
<li><code>${pvc.namespace}</code>
<ul>
<li>Automatically replaced with the namespace of the <code>PersistentVolumeClaim</code> object being provisioned.</li>
</ul>
</li>
</ul>
<p>The value of <code>csi.storage.k8s.io/node-publish-secret-namespace</code> also supports the following template variables which are automatically replaced by the <code>external-provisioner</code> at provision time:</p>
<ul>
<li><code>${pvc.name}</code>
<ul>
<li>Automatically replaced with the name of the <code>PersistentVolumeClaim</code> object being provisioned.</li>
</ul>
</li>
<li><code>${pvc.annotations['&lt;ANNOTATION_KEY&gt;']}</code> (e.g. <code>${pvc.annotations['example.com/key']}</code>)
<ul>
<li>Automatically replaced with the value of the specified annotation from the <code>PersistentVolumeClaim</code> object being provisioned.</li>
</ul>
</li>
</ul>
<p>If specified, once provisioning is successful, the CSI <code>external-provisioner</code> sets the <code>CSIPersistentVolumeSource.NodePublishSecretRef</code> field in the new <code>PersistentVolume</code> object to refer to this secret.</p>
<p>If specified, the Kubernetes kubelet, attempts to fetch the secret referenced by the <code>CSIPersistentVolumeSource.NodePublishSecretRef</code> field before a mount operation.</p>
<p>If no such secret exists in the Kubernetes API, or the kubelet is unable to fetch it, the mount operation fails.</p>
<p>If the secret is retrieved successfully, the kubelet passes it to the CSI driver in the <code>NodePublishVolumeRequest.secrets</code> field.</p>
<p>For example, consider this <code>StorageClass</code>:</p>
<pre><code class="language-yaml">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: fast-storage
provisioner: csi-driver.team.example.com
parameters:
  type: pd-ssd
  csiNodePublishSecretName: ${pvc.annotations['team.example.com/key']}
  csiNodePublishSecretNamespace: ${pvc.namespace}
</code></pre>
<p>This StorageClass instructs the CSI provisioner to do the following:</p>
<ul>
<li>Create a <code>PersistentVolume</code> with:
<ul>
<li>a &quot;node publish secret&quot; in the same namespace as the <code>PersistentVolumeClaim</code> that triggered the provisioning, with a name specified as an annotation on the <code>PersistentVolumeClaim</code>. This could be used to give the creator of the <code>PersistentVolumeClaim</code> the ability to specify a secret containing a decryption key they have control over.</li>
</ul>
</li>
</ul>
<a class="header" href="#handling-sensitive-information" id="handling-sensitive-information"><h2>Handling Sensitive Information</h2></a>
<p>CSI Drivers that accept secrets SHOULD handle this data carefully. It may contain sensitive information and MUST be treated as such (e.g. not logged).</p>
<p>To make it easier to handle secret fields (e.g. strip them from CSI protos when logging), the CSI spec defines a decorator (<code>csi_secret</code>) on all fields containing sensitive information. Any fields decorated with <code>csi_secret</code> MUST be treated as if they contain sensitive information (e.g. not logged, etc.).</p>
<p>The Kubernetes CSI development team also provides a GO lang package called <code>protosanitizer</code> that CSI driver developers may be used to remove values for all fields in a gRPC messages decorated with <code>csi_secret</code>. The library can be found in <a href="https://github.com/kubernetes-csi/csi-lib-utils/tree/master/protosanitizer">kubernetes-csi/csi-lib-utils/protosanitizer</a>. The Kubernetes CSI <a href="sidecar-containers.html">Sidecar Containers</a> and sample drivers use this library to ensure no sensitive information is logged.</p>
<a class="header" href="#snapshot--restore-feature" id="snapshot--restore-feature"><h1>Snapshot &amp; Restore Feature</h1></a>
<p><strong>Status:</strong> Alpha</p>
<p>Many storage systems provide the ability to create a &quot;snapshot&quot; of a persistent volume. A snapshot represents a point-in-time copy of a volume. A snapshot can be used either to provision a new volume (pre-populated with the snapshot data) or to restore the existing volume to a previous state (represented by the snapshot).</p>
<p>Kubernetes CSI currently enables CSI Drivers to expose the following functionality via the Kubernetes API:</p>
<ol>
<li>Creation and deletion of volume snapshots via <a href="https://kubernetes.io/docs/concepts/storage/volume-snapshots/">Kubernetes native API</a>.</li>
<li>Creation of new volumes pre-populated with the data from a snapshot via Kubernetes <a href="https://kubernetes.io/docs/concepts/storage/dynamic-provisioning/">dynamic volume provisioning</a>.</li>
</ol>
<a class="header" href="#implementing-snapshot--restore-functionality" id="implementing-snapshot--restore-functionality"><h2>Implementing Snapshot &amp; Restore Functionality</h2></a>
<p>To implement the snapshot feature, a CSI driver MUST:</p>
<ul>
<li>Implement the <code>CREATE_DELETE_SNAPSHOT</code> and, optionally, the <code>LIST_SNAPSHOTS</code> controller capabilities</li>
<li>Implement <code>CreateSnapshot</code>, <code>DeleteSnapshot</code>, and, optionally, the <code>ListSnapshots</code>, controller RPCs.</li>
</ul>
<p>For details,  see the <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md">CSI spec</a>.</p>
<a class="header" href="#deploying-snapshot--restore-functionality" id="deploying-snapshot--restore-functionality"><h2>Deploying Snapshot &amp; Restore Functionality</h2></a>
<p>The Kubernetes CSI development team maintains the <a href="external-snapshotter.html">external-snapshotter</a> Kubernetes CSI <a href="sidecar-containers.html">Sidecar Containers</a>. This sidecar container implements the logic for watching the Kubernetes API for snapshot objects and issuing the appropriate CSI snapshot calls against a CSI endpoint. For more details, see <a href="external-snapshotter.html">external-snapshotter documentation</a>.</p>
<a class="header" href="#snapshot-apis" id="snapshot-apis"><h2>Snapshot APIs</h2></a>
<p>Similar to the API for managing <a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/">Kubernetes Persistent Volumes</a>, the Kubernetes Volume Snapshots introduce three new API objects for managing snapshots: <code>VolumeSnapshot</code>, <code>VolumeSnapshotContent</code>, and <code>VolumeSnapshotClass</code>. See <a href="https://kubernetes.io/docs/concepts/storage/volume-snapshots/">Kubernetes Snapshot documentation</a> for more details.</p>
<p>Unlike the core Kubernetes Persistent Volume objects, these Snapshot objects are defined as <a href="https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/#create-a-customresourcedefinition">Custom Resource Definitions</a> (CRDs). This is because the Kubernetes project is moving away from having resource types pre-defined in the API server. This allows the API server to be reused for projects other than Kubernetes, and consumers (like Kubernetes) simply install the resource types they require as CRDs. Because the Snapshot API types are not built in to Kubernetes, they must be installed prior to use.</p>
<p>The CRDs are <a href="https://github.com/kubernetes-csi/external-snapshotter/blob/master/cmd/csi-snapshotter/create_crd.go#L29">automatically deployed</a> by the CSI <a href="external-snapshotter.html">external-snapshotter</a> sidecar.</p>
<p>The schema definition for the custom resources (CRs) can be found here: https://github.com/kubernetes-csi/external-snapshotter/blob/master/pkg/apis/volumesnapshot/v1alpha1/types.go</p>
<p>In addition to these new CRD objects, a new, alpha <code>DataSource</code> field has been added to the <code>PersistentVolumeClaim</code> object. This new field enables dynamic provisioning of new volumes that are automatically pre-populated with data from an existing snapshot.</p>
<p>Since volume snapshot is an alpha feature in Kubernetes v1.12, you need to enable a new alpha feature gate called <code>VolumeSnapshotDataSource</code> in the Kubernetes API server binary.</p>
<pre><code>--feature-gates=VolumeSnapshotDataSource=true
</code></pre>
<a class="header" href="#test-snapshot-feature" id="test-snapshot-feature"><h2>Test Snapshot Feature</h2></a>
<p>Use the following <a href="https://github.com/kubernetes-csi/external-snapshotter/tree/master/examples/kubernetes">example yaml files</a> to test the snapshot feature.</p>
<p>Create a <em>StorageClass</em>:</p>
<pre><code>kubectl create -f storageclass.yaml
</code></pre>
<p>Create a <em>PVC</em>:</p>
<pre><code>kubectl create -f pvc.yaml
</code></pre>
<p>Create a <em>VolumeSnapshotClass</em>:</p>
<pre><code>kubectl create -f snapshotclass.yaml
</code></pre>
<p>Create a <em>VolumeSnapshot</em>:</p>
<pre><code>kubectl create -f snapshot.yaml
</code></pre>
<p>Create a <em>PVC</em> from a <em>VolumeSnapshot</em>:</p>
<pre><code>kuberctl create -f restore.yaml
</code></pre>
<a class="header" href="#persistentvolumeclaim-not-bound" id="persistentvolumeclaim-not-bound"><h3>PersistentVolumeClaim not Bound</h3></a>
<p>If a <code>PersistentVolumeClaim</code> is not bound, the attempt to create a volume snapshot from that <code>PersistentVolumeClaim</code> will fail. No retries will be attempted. An event will be logged to indicate that the <code>PersistentVolumeClaim</code> is not bound.</p>
<p>Note that this could happen if the <code>PersistentVolumeClaim</code> spec and the <code>VolumeSnapshot</code> spec are in the same YAML file. In this case, when the <code>VolumeSnapshot</code> object is created, the <code>PersistentVolumeClaim</code> object is created but volume creation is not complete and therefore the <code>PersistentVolumeClaim</code> is not yet bound. You must wait until the <code>PersistentVolumeClaim</code> is bound and then create the snapshot.</p>
<a class="header" href="#examples" id="examples"><h2>Examples</h2></a>
<p>The following CSI drivers implement the snapshot feature and maybe referred to for example implementations:</p>
<ul>
<li><a href="https://github.com/kubernetes-sigs/gcp-compute-persistent-disk-csi-driver">GCE PD CSI driver</a></li>
<li><a href="https://github.com/opensds/nbp/tree/master/csi/server">OpenSDS CSI driver</a></li>
<li><a href="https://github.com/ceph/ceph-csi/tree/master/pkg/rbd">Ceph RBD CSI driver</a></li>
<li><a href="https://github.com/gluster/gluster-csi-driver">GlusterFS CSI driver</a></li>
</ul>
<a class="header" href="#csi-topology-feature" id="csi-topology-feature"><h1>CSI Topology Feature</h1></a>
<a class="header" href="#status-2" id="status-2"><h2>Status</h2></a>
<ul>
<li>Kubernetes 1.12: Alpha</li>
<li>Kubernetes 1.14: Beta</li>
</ul>
<p>Some storage systems expose volumes that are not equally accessible by all nodes in a Kubernetes cluster. Instead volumes may be constrained to some subset of node(s) in the cluster. The cluster may be segmented into, for example, “racks” or “regions” and “zones” or some other grouping, and a given volume may be accessible only from one of those groups.</p>
<p>To enable orchestration systems, like Kubernetes, to work well with storage systems which expose volumes that are not equally accessible by all nodes, the <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md">CSI spec</a> enables:</p>
<ol>
<li>Ability for a CSI Driver to opaquely specify where a particular node exists (e.g. &quot;node A&quot; is in &quot;zone 1&quot;).</li>
<li>Ability for Kubernetes (users or components) to influence where a volume is provisioned (e.g. provision new volume in either &quot;zone 1&quot; or &quot;zone 2&quot;).</li>
<li>Ability for a CSI Driver to opaquely specify where a particular volume exists (e.g. &quot;volume X&quot; is accessible by all nodes in &quot;zone 1&quot; and &quot;zone 2&quot;).</li>
</ol>
<p>Kubernetes and the Kubernetes CSI <a href="sidecar-containers.html">Sidecar Containers</a> use these abilities to make intelligent scheduling and provisioning decisions (that Kubernetes can both influence and act on topology information for each volume),</p>
<a class="header" href="#implementing-topology" id="implementing-topology"><h2>Implementing Topology</h2></a>
<p>To support topology in a CSI driver, the following must be implemented:</p>
<ul>
<li>The <code>PluginCapability</code> must support <code>VOLUME_ACCESSIBILITY_CONTRAINTS</code>.</li>
<li>The plugin must fill in <code>accessible_topology</code> in <code>NodeGetInfoResponse</code>.
This information will be used to populate the Kubernetes <a href="csi-node-object.html">CSINode object</a> and add the topology labels to the Node object.</li>
<li>During <code>CreateVolume</code>, the topology information will get passed in through <code>CreateVolumeRequest.accessibility_requirements</code>.</li>
</ul>
<p>In the StorageClass object, both <code>volumeBindingMode</code> values of <code>Immediate</code> and
<code>WaitForFirstConsumer</code> are supported.</p>
<ul>
<li>If <code>Immediate</code> is set, then the
external-provisioner will pass in all available topologies in the cluster for
the driver.</li>
<li>If <code>WaitForFirstConsumer</code> is set, then the external-provisioner will wait for
the scheduler to pick a node. The topology of that selected node will then be
set as the first entry in <code>CreateVolumeRequest.accessibility_requirements.preferred</code>.
All remaining topologies are still included in the <code>requisite</code> and <code>preferred</code>
fields to support storage systems that span across multiple topologies.</li>
</ul>
<a class="header" href="#beta-usage" id="beta-usage"><h2>Beta Usage</h2></a>
<p>In order to support topology-aware dynamic provisioning mechanisms available in Kubernetes, the <em>external-provisioner</em> must have the Topology feature enabled:</p>
<pre><code>--feature-gates=Topology=true
</code></pre>
<p>In addition, in the <em>Kubernetes cluster</em> the <code>CSINodeInfo</code> feature must be enabled on both Kubernetes master and nodes (refer to the <a href="csi-node-object.html">CSINode Object</a> section for more info):</p>
<pre><code>--feature-gates=CSINodeInfo=true
</code></pre>
<p>In order to fully function properly, all Kubernetes master and nodes must be on at least
Kubernetes 1.14. If a selected node is on a lower version, topology is ignored and not
passed to the driver during <code>CreateVolume</code>.</p>
<a class="header" href="#alpha-usage" id="alpha-usage"><h2>Alpha Usage</h2></a>
<p>The Kubernetes 1.13 alpha feature requires external-provisioner v1.0.1, and the
1.12 alpha feature requires external-provisioner v0.4.1. Kubernetes master and
node version skew and upgrades are not supported.</p>
<p>The <code>Topology</code> feature gate must be enabled on the external-provisioner. The
<code>CSINodeInfo</code>, <code>VolumeScheduling</code>, and <code>KubeletPluginsWatcher</code> feature gates
must be enabled on both Kubernetes master and nodes.</p>
<a class="header" href="#storage-internal-topology" id="storage-internal-topology"><h2>Storage Internal Topology</h2></a>
<p>Note that a storage system may also have an &quot;internal topology&quot; different from (independent of) the topology of the cluster where workloads are scheduled. Meaning volumes exposed by the storage system are equally accessible by all nodes in the Kubernetes cluster, but the storage system has some internal topology that may influence, for example, the performance of a volume from a given node.</p>
<p>CSI does not currently expose a first class mechanism to influence such storage system internal topology on provisioning. Therefore, Kubernetes can not programmatically influence such topology. However, a CSI Driver may expose the ability to specify internal storage topology during volume provisioning using an opaque parameter in the <code>CreateVolume</code> CSI call (CSI enables CSI Drivers to expose an arbitrary set of configuration options during dynamic provisioning by allowing opaque parameters to be passed from cluster admins to the storage plugins) -- this would enable cluster admins to be able to control the storage system internal topology during provisioning.</p>
<a class="header" href="#raw-block-volume-feature" id="raw-block-volume-feature"><h1>Raw Block Volume Feature</h1></a>
<a class="header" href="#status-3" id="status-3"><h2>Status</h2></a>
<ul>
<li>Kubernetes 1.11 - 1.13: Alpha</li>
<li>Kubernetes 1.14: Beta</li>
</ul>
<p>This page documents how to implement raw block volume support to a CSI Driver.</p>
<p>A <em>block volume</em> is a volume that will appear as a block device inside the container.
A <em>mounted (file) volume</em> is volume that will be mounted using a specified file system and appear as a directory inside the container.</p>
<p>The <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md">CSI spec</a> supports both block and mounted (file) volumes.</p>
<p>While Kubernetes support of mounted (file) volumes is GA/stable, support for <a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#raw-block-volume-support">block volume in Kubernetes</a> is beta, and controlled by
two feature gates (which default to enabled).</p>
<pre><code>--feature-gates=BlockVolume=true,CSIBlockVolume=true...
</code></pre>
<a class="header" href="#implementing-raw-block-volume-support-in-your-csi-driver" id="implementing-raw-block-volume-support-in-your-csi-driver"><h2>Implementing Raw Block Volume Support in Your CSI Driver</h2></a>
<p>CSI doesn't provide a capability query for block volumes, so COs will simply pass through requests for
block volume creation to CSI plugins, and plugins are allowed to fail with the <code>InvalidArgument</code> GRPC
error code if they don't support block volumes. Kubernetes doesn't make any assumptions about which CSI
plugins support blocks and which don't, so users have to know if any given storage class is capable of
creating block volumes.</p>
<p>The difference between a request for a mounted (file) volume and a block volume is the <code>VolumeCapabilities</code>
field of the request. Note that this field is an array and the created volume must support ALL of the
capabilities requested, or else return an error. If the <code>AccessType</code> method of a <code>VolumeCapability</code>
<code>VolumeCapability_Block</code>, then the capability is requesting a raw block volume. Unlike mount volumes, block
volumes don't have any specific capabilities that need to be validated, although access modes still
apply.</p>
<p>Block volumes are much more likely to support multi-node flavors of <code>VolumeCapability_AccessMode_Mode</code>
than mount volumes, because there's no file system state stored on the node side that creates any technical
impediments to multi-attaching block volumes. While there may still be good reasons to prevent
multi-attaching block volumes, and there may be implementations that are not capable of supporting
multi-attach, you should think carefully about what makes sense for your driver.</p>
<p>CSI plugins that support both mount and block volumes must be sure to check the capabilities of all CSI RPC
requests and ensure that the capability of the request matches the capability of the volume, to avoid trying
to do file-system-related things to block volumes and block-related things to file system volumes. The
following RPCs specify capabilities that must be validated:</p>
<ul>
<li><code>CreateVolume()</code> (multiple capabilities)</li>
<li><code>ControllerPublishVolume()</code></li>
<li><code>ValidateVolumeCapabilities()</code> (multiple capabilities)</li>
<li><code>GetCapacity()</code> (see below)</li>
<li><code>NodeStageVolume()</code></li>
<li><code>NodePublishVolume()</code></li>
</ul>
<p>Also, CSI plugins that implement the optional <code>GetCapacity()</code> RPC should note that that RPC includes
capabilities too, and if the capacity for mount volumes is not the same as the capacity for block
volumes, that needs to be handled in the implementation of that RPC.</p>
<p>Q: Can CSI plugins support only block volumes and not mount volumes?
A: Yes! This is just the reverse case of supporting mount volumes only. Plugins may return <code>InvalidArgument</code>
for any creation request with an <code>AccessType</code> of <code>VolumeCapability_Mount</code>.</p>
<a class="header" href="#differences-between-block-and-mount-volumes" id="differences-between-block-and-mount-volumes"><h2>Differences Between Block and Mount Volumes</h2></a>
<p>The main difference between block volumes and mount volumes is the expected result of the <code>NodePublish()</code>.
For mount volumes, the CO expects the result to be a mounted directory, at <code>TargetPath</code>. For block volumes,
the CO expects there to be a device file at <code>TargetPath</code>. The device file can by a bind-mounted device from
the hosts <code>/dev</code> file system, or it can be a device node created at that location using <code>mknod()</code>.</p>
<p>It's desirable but not required to expose an unfiltered device node. For example, CSI plugins based on
technologies that implement SCSI protocols should expect that pods consuming the block volumes they create
may want to send SCSI commands to the device. This is something that should &quot;just work&quot; by default (subject
to container capabilities) so CSI plugins should avoid anything that would break this kind of use case. The
only hard requirement is that the device implements block reading/writing however.</p>
<p>For plugins with the <code>RPC_STAGE_UNSTAGE_VOLUME</code> capability, the CO doesn't care exactly what is placed at
the <code>StagingTargetPath</code>, but it's worth noting that some CSI RPCs are allowed to pass the plugin either
a staging path or a publish path, so it's important to think carefully about how <code>NodeStageVolume()</code> is
implemented, knowing that either path could get used by the CO to refer to the volume later on. This is
made more challenging because the CSI spec says that <code>StagingTargetPath</code> is always a directory even for
block volumes.</p>
<ul>
<li>TODO: detail how Kubernetes API raw block fields get mapped to CSI methods/fields.</li>
</ul>
<a class="header" href="#skip-kubernetes-attach-and-detach" id="skip-kubernetes-attach-and-detach"><h1>Skip Kubernetes Attach and Detach</h1></a>
<p><strong>Status:</strong> Beta</p>
<p>The &quot;Skip Kubernetes Attach and Detach&quot; feature was introduced as alpha in Kubernetes v1.12. It was promoted to beta in Kubernetes 1.13.</p>
<a class="header" href="#problem" id="problem"><h1>Problem</h1></a>
<p>Volume drivers, like NFS, for example, have no concept of an attach (<code>ControllerPublishVolume</code>). However, Kubernetes always executes <code>Attach</code> and <code>Detach</code> operations even if the CSI driver does not implement an attach operation (i.e. even if the CSI Driver does not implement a <code>ControllerPublishVolume</code> call).</p>
<p>This was problematic because it meant <em>all</em> CSI drivers had to handle Kubernetes attachment. CSI Drivers that did not implement the <code>PUBLISH_UNPUBLISH_VOLUME</code> controller capability could work around this by deploying an <a href="external-attacher.html">external-attacher</a> and the <code>external-attacher</code> would responds to Kubernetes attach operations and simply do a noop (because the CSI driver did not advertise the <code>PUBLISH_UNPUBLISH_VOLUME</code> controller capability).</p>
<p>Although the workaround works, it adds an unnecessary operation (round-trip) in the preparation of a volume for a container, and requires CSI Drivers to deploy an unnecessary sidecar container (<code>external-attacher</code>).</p>
<a class="header" href="#skip-attach-with-csi-driver-object" id="skip-attach-with-csi-driver-object"><h1>Skip Attach with CSI Driver Object</h1></a>
<p>The <a href="csi-driver-object.html">CSIDriver Object</a> enables CSI Drivers to specify how Kubernetes should interact with it.</p>
<p>Specifically the <code>attachRequired</code> field instructs Kubernetes to skip any attach operation altogether.</p>
<p>For example, the existence of the following object would cause Kubernetes to skip attach operations for all CSI Driver <code>testcsidriver.example.com</code> volumes.</p>
<pre><code>apiVersion: storage.k8s.io/v1beta1
kind: CSIDriver
metadata:
  name: testcsidriver.example.com
spec:
  attachRequired: false
</code></pre>
<p>The easiest way to use this feature is to deploy the <a href="cluster-driver-registrar.html">cluster-driver-registrar</a> sidecar container. Once the flags to this container are configured correctly, it will automatically create a <a href="csi-driver-object.html">CSIDriver Object</a> when it starts with the correct fields set.</p>
<a class="header" href="#alpha-functionality" id="alpha-functionality"><h2>Alpha Functionality</h2></a>
<p>In alpha, this feature was enabled via the <a href="csi-driver-object.html">CSIDriver Object</a> CRD.</p>
<pre><code>apiVersion: csi.storage.k8s.io/v1alpha1
kind: CSIDriver
metadata:
....
</code></pre>
<a class="header" href="#pod-info-on-mount" id="pod-info-on-mount"><h1>Pod Info on Mount</h1></a>
<p><strong>Status:</strong> Beta</p>
<p>The &quot;Pod Info on Mount&quot; feature was introduced as alpha in Kubernetes v1.12. It was promoted to beta in Kubernetes 1.13.</p>
<a class="header" href="#problem-1" id="problem-1"><h1>Problem</h1></a>
<p>CSI avoids encoding Kubernetes specific information in to the specification, since it aims to support multiple orchestration systems (beyond just Kubernetes).</p>
<p>This can be problematic because some CSI drivers require information about the workload (e.g. which pod is referencing this volume), and CSI does not provide this information natively to drivers.</p>
<a class="header" href="#pod-info-on-mount-with-csi-driver-object" id="pod-info-on-mount-with-csi-driver-object"><h1>Pod Info on Mount with CSI Driver Object</h1></a>
<p>The <a href="csi-driver-object.html">CSIDriver Object</a> enables CSI Drivers to specify how Kubernetes should interact with it.</p>
<p>Specifically the <code>podInfoOnMount</code> field instructs Kubernetes that the CSI driver requires additional pod information (like podName, podUID, etc.) during mount operations.</p>
<p>For example, the existence of the following object would cause Kubernetes to add pod information at mount time to the <code>NodePublishVolumeRequest.publish_context</code> map.</p>
<pre><code>apiVersion: storage.k8s.io/v1beta1
kind: CSIDriver
metadata:
  name: testcsidriver.example.com
spec:
  podInfoOnMount: true
</code></pre>
<p>If the <code>podInfoOnMount</code> field is set to <code>true</code>, during mount, Kubelet will add the following key/values to the <code>publish_context</code> field in the CSI <code>NodePublishVolumeRequest</code>:</p>
<ul>
<li><code>csi.storage.k8s.io/pod.name: {pod.Name}</code></li>
<li><code>csi.storage.k8s.io/pod.namespace: {pod.Namespace}</code></li>
<li><code>csi.storage.k8s.io/pod.uid: {pod.UID}</code></li>
</ul>
<p>The easiest way to use this feature is to deploy the <a href="cluster-driver-registrar.html">cluster-driver-registrar</a> sidecar container. Once the flags to this container are configured correctly, it will automatically create a <a href="csi-driver-object.html">CSIDriver Object</a> when it starts with the correct fields set.</p>
<a class="header" href="#alpha-functionality-1" id="alpha-functionality-1"><h2>Alpha Functionality</h2></a>
<p>In alpha, this feature was enabled by setting the <code>podInfoOnMountVersion</code> field in the <code>CSIDriver</code> Object CRD to to <code>v1</code>.</p>
<pre><code>apiVersion: csi.storage.k8s.io/v1alpha1
kind: CSIDriver
metadata:
  name: testcsidriver.example.com
spec:
  podInfoOnMountVersion: v1
</code></pre>
<a class="header" href="#ephemeral-local-volumes" id="ephemeral-local-volumes"><h1>Ephemeral Local Volumes</h1></a>
<blockquote>
<a class="header" href="#this-page-is-still-under-active-development" id="this-page-is-still-under-active-development"><h2><em>This page is still under active development.</em></h2></a>
</blockquote>
<p><strong>Status:</strong> Alpha</p>
<p>Kubernetes supports three types of volumes:</p>
<ol>
<li>Remote Persistent Volumes</li>
<li>Local Persistent Volumes</li>
<li>Local Ephemeral Volumes</li>
</ol>
<p>The initial focus of Kubernetes CSI was Remote Persistent Volumes. However, the goal is for CSI to support all three types.</p>
<p>This page documents how to create &quot;Local Ephemeral Volumes&quot; for Kubernetes using CSI.</p>
<a class="header" href="#what-is-a-local-ephemeral-volumes" id="what-is-a-local-ephemeral-volumes"><h1>What is a Local Ephemeral Volumes?</h1></a>
<p>A Local Ephemeral Volumes is a volume whose lifecycle is tied to the lifecycle of a single pod:</p>
<ul>
<li>The volume is &quot;provisioned&quot; (either empty or with some pre-populated data) when the pod is created.</li>
<li>The volume is deleted when the pod is terminated.</li>
</ul>
<p><a href="https://kubernetes.io/docs/concepts/storage/volumes/#secret">Kubernetes Secret Volumes</a> are a good example (non-CSI) of a local ephemeral volumes.</p>
<a class="header" href="#how-to-write-a-csi-driver-for-local-ephemeral-volumes" id="how-to-write-a-csi-driver-for-local-ephemeral-volumes"><h1>How to write a CSI Driver for Local Ephemeral Volumes</h1></a>
<p>The following features make it easier to develop CSI Drivers that expose local ephemeral volumes:</p>
<ul>
<li><a href="pod-info.html">Pod Info on Mount</a>
<ul>
<li>This feature provides the CSI driver pod information at mount time. Many ephemeral volumes write some files at mount time. Often the data they write depends on the the pod they are operating on.</li>
</ul>
</li>
<li><a href="skip-attach.html">Skip Attach</a>
<ul>
<li>This instructs Kubernetes to skip any attach operation (<code>ControllerPublishVolume</code>) altogether. Local ephemeral volume drivers generally do not have or need a cluster control plane component.</li>
</ul>
</li>
</ul>
<p>Features currently in development to improve Local Ephemeral Volume support:</p>
<ul>
<li>Inline Volume Support
<ul>
<li>Having to create a PV and a PVC for every ephemeral volume is onerous. Being able to specify a volume inside a pod definition (not currently possible for CSI drivers) will make that easier.</li>
</ul>
</li>
</ul>
<a class="header" href="#deploying-csi-driver-on-kubernetes" id="deploying-csi-driver-on-kubernetes"><h1>Deploying CSI Driver on Kubernetes</h1></a>
<blockquote>
<a class="header" href="#this-page-is-out-of-date-and-under-active-development" id="this-page-is-out-of-date-and-under-active-development"><h2><em>This page is out-of-date and under active development.</em></h2></a>
</blockquote>
<p>This page describes to CSI driver developers how to deploy their driver onto a Kubernetes cluster.</p>
<a class="header" href="#overview" id="overview"><h2>Overview</h2></a>
<p>There are three components plus the kubelet that enable CSI drivers to provide storage to Kubernetes. These components are sidecar containers which are responsible for communication with both Kubernetes and the CSI driver, making the appropriate CSI calls for their respectful Kubernetes events.</p>
<a class="header" href="#sidecar-containers" id="sidecar-containers"><h2>Sidecar Containers</h2></a>
<p><a href="https://docs.google.com/a/greatdanedata.com/drawings/d/1JExJ_98dt0NAsJ7iI0_9loeTn2rbLeEcpOMEvKrF-9w/edit?usp=sharing"><img src="images/sidecar-container.png" alt="sidecar-container" /></a></p>
<p>Sidecar containers manage Kubernetes events and make the appropriate calls to the CSI driver. These are the <em>external attacher</em>, <em>external provisioner</em>, <em>external snapshotter</em> and the <em>driver registrar</em>.</p>
<a class="header" href="#external-attacher" id="external-attacher"><h3>External Attacher</h3></a>
<p><a href="https://github.com/kubernetes-csi/external-attacher">external-attacher</a> is a sidecar container that watches Kubernetes <em>VolumeAttachment</em> objects and triggers CSI <em>ControllerPublish</em> and <em>ControllerUnpublish</em> operations against a driver endpoint. As of this writing, the external attacher does not support leader election and therefore there can be only one running per CSI driver.  For more information please read <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md#attaching-and-detaching"><em>Attaching and Detaching</em></a>.</p>
<p>Note, even though this is called the <em>external attacher</em>, its function is to call the CSI API calls <em>ControllerPublish</em> and <em>ControllerUnpublish</em>. These calls most likely will occur in a node which is <em>not</em> the one that will mount the volume. For this reason, many CSI drivers do not support these calls, instead doing the attach/detach and mount/unmount both in the CSI <em>NodePublish</em> and <em>NodeUnpublish</em> calls done by the kubelet at the node which is supposed to mount.</p>
<a class="header" href="#external-provisioner" id="external-provisioner"><h3>External Provisioner</h3></a>
<p><a href="https://github.com/kubernetes-csi/external-provisioner">external-provisioner</a> is a Sidecar container that watches Kubernetes <em>PersistentVolumeClaim</em> objects and triggers CSI <em>CreateVolume</em> and <em>DeleteVolume</em> operations against a driver endpoint. For more information please read <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md#provisioning-and-deleting"><em>Provisioning and Deleting</em></a>.</p>
<a class="header" href="#external-snapshotter" id="external-snapshotter"><h3>External Snapshotter</h3></a>
<p><a href="https://github.com/kubernetes-csi/external-snapshotter">external-snapshotter</a> is a Sidecar container that watches Kubernetes <em>VolumeSnapshot</em> objects and triggers CSI <em>CreateSnapshot</em> and <em>DeleteSnapshot</em> operations against a driver endpoint. For more information please read <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/csi-snapshot.md"><em>Snapshot Design Proposal</em></a>.</p>
<a class="header" href="#driver-registrar" id="driver-registrar"><h3>Driver Registrar</h3></a>
<p><a href="https://github.com/kubernetes-csi/driver-registrar">driver-registrar</a> is a sidecar container that registers the CSI driver with kubelet, and adds the drivers custom NodeId to a label on the Kubernetes Node API Object. It does this by communicating with the <em>Identity</em> service on the CSI driver and also calling the CSI <em>GetNodeId</em> operation. The driver registrar must have the Kubernetes name for the node set through the environment variable <code>KUBE_NODE_NAME</code> as follows:</p>
<pre><code class="language-yaml">        - name: csi-driver-registrar
          imagePullPolicy: Always
          image: quay.io/k8scsi/driver-registrar:v0.2.0
          args:
            - &quot;--v=5&quot;
            - &quot;--csi-address=$(ADDRESS)&quot;
          env:
            - name: ADDRESS
              value: /csi/csi.sock
            - name: KUBE_NODE_NAME
              valueFrom:
                fieldRef:
                  fieldPath: spec.nodeName
          volumeMounts:
            - name: socket-dir
              mountPath: /csi
</code></pre>
<a class="header" href="#kubelet" id="kubelet"><h3>Kubelet</h3></a>
<p><a href="https://docs.google.com/a/greatdanedata.com/drawings/d/1NXaVNDh3mSDhog7Q3Y9eELyEF24F8Z-Kk0ujR3pyOes/edit?usp=sharing"><img src="images/kubelet.png" alt="kubelet" /></a></p>
<p>The Kubernetes kubelet runs on every node and is responsible for making the CSI calls <em>NodePublish</em> and <em>NodeUnpublish</em>. These calls mount and unmount the storage volume from the storage system, making it available to the Pod to consume. As shown in the <em>external-attacher</em>, most CSI drivers choose to implement both their attach/detach and mount/unmount calls in the <em>NodePublish</em> and <em>NodeUnpublish</em> calls. They do this because the kubelet makes the request on the node which is to consume the volume.</p>
<a class="header" href="#mount-point" id="mount-point"><h3>Mount point</h3></a>
<p>The mount point used by the CSI driver must be set to <em>Bidirectional</em>. See the example below:</p>
<pre><code class="language-yaml">          volumeMounts:
            - name: socket-dir
              mountPath: /csi
            - name: mountpoint-dir
              mountPath: /var/lib/kubelet/pods
              mountPropagation: &quot;Bidirectional&quot;
      volumes:
        - name: socket-dir
          hostPath:
            path: /var/lib/kubelet/plugins/csi-hostpath
            type: DirectoryOrCreate
        - name: mountpoint-dir
          hostPath:
            path: /var/lib/kubelet/pods
            type: Directory
</code></pre>
<a class="header" href="#rbac-rules" id="rbac-rules"><h3>RBAC Rules</h3></a>
<p>Side car containers need the appropriate permissions to be able to access and manipulate Kubernetes objects. Here are the RBAC rules needed:</p>
<pre><code class="language-yaml">kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: csi-hostpath-role
rules:
  - apiGroups: [&quot;&quot;]
    resources: [&quot;persistentvolumes&quot;]
    verbs: [&quot;create&quot;, &quot;delete&quot;, &quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;update&quot;]
  - apiGroups: [&quot;&quot;]
    resources: [&quot;persistentvolumeclaims&quot;]
    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;update&quot;]
  - apiGroups: [&quot;&quot;]
    resources: [&quot;nodes&quot;]
    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;update&quot;]
  - apiGroups: [&quot;storage.k8s.io&quot;]
    resources: [&quot;storageclasses&quot;]
    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]
  - apiGroups: [&quot;storage.k8s.io&quot;]
    resources: [&quot;volumeattachments&quot;]
    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;update&quot;]
</code></pre>
<a class="header" href="#deploying" id="deploying"><h2>Deploying</h2></a>
<p>Deploying a CSI driver onto Kubernetes is highlighted in detail in <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md#recommended-mechanism-for-deploying-csi-drivers-on-kubernetes"><em>Recommended Mechanism for Deploying CSI Drivers on Kubernetes</em></a>.</p>
<a class="header" href="#enable-privileged-pods" id="enable-privileged-pods"><h2>Enable privileged Pods</h2></a>
<p>To use CSI drivers, your Kubernetes cluster must allow privileged pods (i.e. <code>--allow-privileged</code> flag must be set to <code>true</code> for both the API server and the kubelet). This is the default in some environments (e.g. GCE, GKE, <code>kubeadm</code>).</p>
<p>Ensure your API server are started with the privileged flag:</p>
<pre><code class="language-shell">$ ./kube-apiserver ...  --allow-privileged=true ...
</code></pre>
<pre><code class="language-shell">$ ./kubelet ...  --allow-privileged=true ...
</code></pre>
<blockquote>
<p>Note: Starting from Kubernetes 1.13.0, --allow-privileged is true for kubelet. It'll be deprecated in future kubernetes releases.</p>
</blockquote>
<a class="header" href="#enabling-mount-propagation" id="enabling-mount-propagation"><h2>Enabling mount propagation</h2></a>
<p>Another feature that CSI depends on is mount propagation.  It allows the sharing of volumes mounted by one container with other containers in the same pod, or even to other pods on the same node.  For mount propagation to work, the Docker daemon for the cluster must allow shared mounts. See the [mount propagation docs][mount-propagation-docs] to find out how to enable this feature for your cluster.  [This page][docker-shared-mount] explains how to check if shared mounts are enabled and how to configure Docker for shared mounts.</p>
<a class="header" href="#examples-1" id="examples-1"><h3>Examples</h3></a>
<ul>
<li>Simple deployment example using a single pod for all components: see the <a href="Example.html">hostpath example</a>.</li>
<li>Full deployment example using a <em>DaemonSet</em> for the node plugin and <em>StatefulSet</em> for the controller plugin: check the <a href="https://github.com/kubernetes-csi/drivers/tree/master/pkg/nfs/deploy/kubernetes">NFS driver deployment files</a>.</li>
</ul>
<a class="header" href="#more-information" id="more-information"><h2>More information</h2></a>
<p>For more information, please read <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md"><em>CSI Volume Plugins in Kubernetes Design Doc</em></a>.</p>
<a class="header" href="#example" id="example"><h1>Example</h1></a>
<p>The <a href="https://github.com/kubernetes-csi/csi-driver-host-path">Hostpath CSI driver</a> is a simple sample driver that provisions a directory on the host. It can be used as an example to get started writing a driver, however it is not meant for production use.
The <a href="https://github.com/kubernetes-csi/csi-driver-host-path#deployment">deployment example</a> shows how to deploy and use that driver in Kubernetes.</p>
<p>The example deployment uses the original RBAC rule files that are maintained together with sidecar apps and deploys into the default namespace. A real production should copy the RBAC files and customize them as explained in the comments of those files.</p>
<p>If you encounter any problems, please check the <a href="troubleshooting.html">Troubleshooting page</a>.</p>
<a class="header" href="#testing" id="testing"><h1>Testing</h1></a>
<p>This section describes how CSI developers can test their CSI drivers.</p>
<ul>
<li><a href="unit-testing.html">Unit Testing</a></li>
<li><a href="functional-testing.html">Functional Testing</a></li>
</ul>
<a class="header" href="#unit-testing" id="unit-testing"><h1>Unit Testing</h1></a>
<p>The <a href="https://github.com/kubernetes-csi/csi-test/tree/master/pkg/sanity">CSI <code>sanity</code></a> package from <a href="https://github.com/kubernetes-csi/csi-test">csi-test</a> can be used for unit testing your CSI driver.</p>
<p>It contains a set of basic tests that all CSI drivers should pass (for example, <code>NodePublishVolume should fail when no volume id is provided</code>, etc.).</p>
<p>This package can be used in two modes:</p>
<ul>
<li>Via a Golang test framework (<code>sanity</code> package is imported as a dependency)</li>
<li>Via a command line against your driver binary.</li>
</ul>
<p>Read the <a href="https://github.com/kubernetes-csi/csi-test/blob/master/pkg/sanity/README.md">documentation of the <code>sanity</code> package</a> for more details.</p>
<a class="header" href="#functional-testing" id="functional-testing"><h1>Functional Testing</h1></a>
<p>Some functional testing of your CSI driver can be done via the CLI mode of the <a href="https://github.com/kubernetes-csi/csi-test/tree/master/pkg/sanity">CSI <code>sanity</code></a> package.</p>
<p>Drivers should also be functionally &quot;end-to-end&quot; tested while deployed in a Kubernetes cluster. Currently how to do this and what tests to run is left up to driver authors. In the future, a project (currently in development) aims to enable use of a pre-built <code>kubernetes/e2e/e2e.test</code> binary containing a standard set of Kubernetes CSI end-to-end tests to be imported and run by third party CSI drivers. This documentation will be updated with more information once that is ready to use.</p>
<p>The CSI community is also looking in to establishing an official &quot;CSI Conformance Suite&quot; to recognize &quot;officially certified CSI drivers&quot;.  This documentation will be updated with more information once that process has been defined.</p>
<a class="header" href="#drivers" id="drivers"><h1>Drivers</h1></a>
<p>The following are a set of CSI driver which can be used with Kubernetes:</p>
<blockquote>
<p>NOTE: If you would like your driver to be added to this table, please open a pull request in <a href="https://github.com/kubernetes-csi/docs/pulls">this repo</a> updating this file.</p>
</blockquote>
<a class="header" href="#production-drivers" id="production-drivers"><h2>Production Drivers</h2></a>
<table><thead><tr><th>Name </th><th> Status </th><th> More Information</th></tr></thead><tbody>
<tr><td><a href="https://github.com/AliyunContainerService/csi-plugin">Alicloud Elastic Block Storage</a> </td><td> v1.0.0 </td><td>A Container Storage Interface (CSI) Storage Plug-in for Alicloud Elastic Block Storage</td></tr>
<tr><td><a href="https://github.com/AliyunContainerService/csi-plugin">Alicloud Elastic File System</a></td><td> v1.0.0 </td><td>A Container Storage Interface (CSI) Storage Plug-in for Alicloud Elastic File System</td></tr>
<tr><td><a href="https://github.com/AliyunContainerService/csi-plugin">Alicloud OSS</a></td><td> v1.0.0 </td><td>A Container Storage Interface (CSI) Storage Plug-in for Alicloud OSS</td></tr>
<tr><td><a href="https://github.com/kubernetes-sigs/aws-ebs-csi-driver">AWS Elastic Block Storage</a> </td><td> v0.3.0 </td><td> A Container Storage Interface (CSI) Driver for AWS Elastic Block Storage (EBS)</td></tr>
<tr><td><a href="https://github.com/aws/aws-efs-csi-driver">AWS Elastic File System</a> </td><td> v0.1.0 </td><td> A Container Storage Interface (CSI) Driver for AWS Elastic File System (EFS)</td></tr>
<tr><td><a href="https://github.com/aws/aws-fsx-csi-driver">AWS FSx for Lustre</a> </td><td> v0.1.0 </td><td> A Container Storage Interface (CSI) Driver for AWS FSx for Lustre (EBS)</td></tr>
<tr><td><a href="https://github.com/andyzhangx/azuredisk-csi-driver">Azure disk</a></td><td> v0.1.0 (alpha) </td><td>A Container Storage Interface (CSI) Storage Plug-in for Azure disk</td></tr>
<tr><td><a href="https://github.com/andyzhangx/azurefile-csi-driver">Azure file</a></td><td> v0.1.0 (alpha) </td><td>A Container Storage Interface (CSI) Storage Plug-in for Azure file</td></tr>
<tr><td><a href="https://github.com/ceph/ceph-csi">CephFS</a></td><td>v1.0.0</td><td>A Container Storage Interface (CSI) Storage Plug-in for CephFS</td></tr>
<tr><td><a href="https://github.com/kubernetes/cloud-provider-openstack/tree/master/pkg/csi/cinder">Cinder</a></td><td>v1.0.0</td><td>A Container Storage Interface (CSI) Storage Plug-in for Cinder</td></tr>
<tr><td><a href="https://github.com/Datera/kubernetes-driver">Datera</a></td><td>v1.0.0</td><td>A Container Storage Interface (CSI) Storage Plugin for Datera Data Services Platform (DSP)</td></tr>
<tr><td><a href="https://github.com/digitalocean/csi-digitalocean">DigitalOcean Block Storage</a> </td><td> v0.4.0 </td><td> A Container Storage Interface (CSI) Driver for DigitalOcean Block Storage</td></tr>
<tr><td><a href="https://github.com/DriveScale/k8s-plugins">DriveScale</a></td><td>v1.0.0</td><td>A Container Storage Interface (CSI) Storage Plug-in for DriveScale software composable infrastructure solution</td></tr>
<tr><td><a href="https://ember-csi.io">Ember CSI</a> </td><td> v0.2.0 (alpha) </td><td> Multi-vendor CSI plugin supporting over 80 storage drivers to provide block and mount storage to Container Orchestration systems.</td></tr>
<tr><td><a href="https://github.com/kubernetes-sigs/gcp-compute-persistent-disk-csi-driver">GCE Persistent Disk</a></td><td>Beta</td><td>A Container Storage Interface (CSI) Storage Plugin for Google Compute Engine Persistent Disk (GCE PD)</td></tr>
<tr><td><a href="https://github.com/kubernetes-sigs/gcp-filestore-csi-driver">Google Cloud Filestore</a></td><td>Alpha</td><td>A Container Storage Interface (CSI) Storage Plugin for Google Cloud Filestore</td></tr>
<tr><td><a href="https://github.com/gluster/gluster-csi-driver">GlusterFS</a> </td><td> v1.0.0 </td><td> A Container Storage Interface (CSI) Plugin for GlusterFS</td></tr>
<tr><td><a href="https://knowledge.hitachivantara.com/Documents/Adapters_and_Drivers/Storage_Adapters_and_Drivers/Containers">Hitachi Vantara</a> </td><td> v2.0 </td><td> A Container Storage Interface (CSI) Plugin for VSP series Storage</td></tr>
<tr><td><a href="https://github.com/linode/linode-blockstorage-csi-driver">Linode Block Storage</a> </td><td> v0.0.3 </td><td> A Container Storage Interface (CSI) Driver for Linode Block Storage</td></tr>
<tr><td><a href="https://github.com/LINBIT/linstor-csi">LINSTOR</a></td><td>v0.3.0</td><td>A Container Storage Interface (CSI) Storage Plugin for <a href="https://www.linbit.com/en/linstor/">LINSTOR</a></td></tr>
<tr><td><a href="https://github.com/mapr/mapr-csi">MapR</a> </td><td> v1.0.0 </td><td> A Container Storage Interface (CSI) Storage Plugin for MapR Data Platform</td></tr>
<tr><td><a href="https://github.com/moosefs/moosefs-csi">MooseFS</a></td><td>v0.0.1 (alpha)</td><td>A Container Storage Interface (CSI) Storage Plugin for <a href="https://moosefs.com/">MooseFS</a> clusters.</td></tr>
<tr><td><a href="https://github.com/NetApp/trident">NetApp</a> </td><td> v0.2.0 (alpha) </td><td> A Container Storage Interface (CSI) Storage Plug-in for NetApp's <a href="https://netapp-trident.readthedocs.io/">Trident</a> container storage orchestrator</td></tr>
<tr><td><a href="https://github.com/Nexenta/nexentastor-csi-driver">NexentaStor</a> </td><td> Beta </td><td> A Container Storage Interface (CSI) Driver for NexentaStor</td></tr>
<tr><td><a href="https://portal.nutanix.com/#/page/docs/details?targetId=CSI-Volume-Driver:CSI-Volume-Driver">Nutanix</a> </td><td> beta </td><td> A Container Storage Interface (CSI) Storage Driver for Nutanix</td></tr>
<tr><td><a href="https://www.opensds.io/">OpenSDS</a> </td><td> Beta </td><td> For more information, please visit <a href="https://github.com/opensds/nbp/releases">releases</a> and https://github.com/opensds/nbp/tree/master/csi</td></tr>
<tr><td><a href="https://portworx.com/">Portworx</a> </td><td> 0.3.0 </td><td> CSI implementation is available <a href="https://github.com/libopenstorage/openstorage/tree/master/csi">here</a> which can be used as an example also.</td></tr>
<tr><td><a href="https://github.com/yunify/qingcloud-csi">QingCloud CSI</a> </td><td> v0.2.1 </td><td> A Container Storage Interface (CSI) Plugin for QingCloud Block Storage</td></tr>
<tr><td><a href="https://github.com/yunify/qingstor-csi">QingStor CSI</a> </td><td> v0.3.0 </td><td> A Container Storage Interface (CSI) Plugin for NeonSAN storage system</td></tr>
<tr><td><a href="https://github.com/quobyte/quobyte-csi">Quobyte</a> </td><td> v0.2.0 </td><td> A Container Storage Interface (CSI) Plugin for Quobyte</td></tr>
<tr><td><a href="https://github.com/ceph/ceph-csi">RBD</a></td><td>v1.0.0</td><td>A Container Storage Interface (CSI) Storage RBD Plug-in for Ceph</td></tr>
<tr><td><a href="https://github.com/thecodeteam/csi-scaleio">ScaleIO</a></td><td>v0.1.0</td><td>A Container Storage Interface (CSI) Storage Plugin for DellEMC ScaleIO</td></tr>
<tr><td><a href="https://storageos.com/">StorageOS</a> </td><td> v1.0.0 </td><td> A Container Storage Interface (CSI) Plugin for StorageOS</td></tr>
<tr><td><a href="https://xsky-storage.github.io/xsky-csi-driver/">XSKY</a> </td><td> V1.1.2 </td><td> A Container Storage Interface (CSI) Driver for XSKY Distributed Block Storage (X-EBS)</td></tr>
<tr><td><a href="https://github.com/kubevault/csi-driver">Vault</a> </td><td> Alpha </td><td> A Container Storage Interface (CSI) Plugin for HashiCorp Vault</td></tr>
<tr><td><a href="https://github.com/thecodeteam/csi-vsphere">vSphere</a></td><td>v0.1.0</td><td>A Container Storage Interface (CSI) Storage Plug-in for VMware vSphere</td></tr>
<tr><td><a href="http://www.yanrongyun.com/">YanRongYun</a> </td><td> v1.0.0 </td><td> A Container Storage Interface (CSI) Driver for YanRong YRCloudFile Storage</td></tr>
</tbody></table>
<a class="header" href="#sample-drivers" id="sample-drivers"><h2>Sample Drivers</h2></a>
<table><thead><tr><th>Name </th><th> Status </th><th> More Information</th></tr></thead><tbody>
<tr><td><a href="https://github.com/kubernetes-csi/drivers/tree/master/pkg/flexadapter">Flexvolume</a> </td><td> Sample </td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/drivers/tree/master/pkg/hostpath">HostPath</a> </td><td> v0.2.0 </td><td> Only use for a single node tests. See the <a href="Example.html">Example</a> page for Kubernetes-specific instructions.</td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/csi-test/tree/master/mock/service">In-memory Sample Mock Driver</a> </td><td> v0.3.0 </td><td> The sample mock driver used for <a href="https://github.com/kubernetes-csi/csi-test/tree/master/cmd/csi-sanity">csi-sanity</a></td></tr>
<tr><td><a href="https://github.com/kubernetes-csi/drivers/tree/master/pkg/nfs">NFS</a> </td><td> Sample </td></tr>
<tr><td><a href="https://github.com/jparklab/synology-csi">Synology NAS</a> </td><td> v1.0.0 </td><td> An unofficial (and unsupported) Container Storage Interface Driver for Synology NAS.</td></tr>
<tr><td><a href="https://github.com/thecodeteam/csi-vfs">VFS Driver</a> </td><td> Released </td><td> A CSI plugin that provides a virtual file system.</td></tr>
</tbody></table>
<a class="header" href="#troubleshooting" id="troubleshooting"><h1>Troubleshooting</h1></a>
<a class="header" href="#known-issues" id="known-issues"><h1>Known Issues</h1></a>
<ul>
<li>[<a href="https://github.com/kubernetes/minikube/issues/3378">minikube-3378</a>]: Volume mount causes minikube VM to become corrupted</li>
</ul>
<a class="header" href="#common-errors" id="common-errors"><h1>Common Errors</h1></a>
<a class="header" href="#node-plugin-pod-does-not-start-with-runcontainererror-status" id="node-plugin-pod-does-not-start-with-runcontainererror-status"><h3>Node plugin pod does not start with <em>RunContainerError</em> status</h3></a>
<p><code>kubectl describe pod your-nodeplugin-pod</code> shows:</p>
<pre><code>failed to start container &quot;your-driver&quot;: Error response from daemon:
linux mounts: Path /var/lib/kubelet/pods is mounted on / but it is not a shared mount
</code></pre>
<p>Your Docker host is not configured to allow shared mounts. Take a look at <a href="https://docs.portworx.com/knowledgebase/shared-mount-propagation.html">this page</a> for instructions to enable them.</p>
<a class="header" href="#external-attacher-cant-find-volumeattachments" id="external-attacher-cant-find-volumeattachments"><h3>External attacher can't find <em>VolumeAttachments</em></h3></a>
<p>If you have a Kubernetes 1.9 cluster, not being able to list <em>VolumeAttachment</em>
and the following error are due to the lack of the
<code>storage.k8s.io/v1alpha1=true</code> runtime configuration:</p>
<pre><code>$ kubectl logs csi-pod external-attacher
...
I0306 16:34:50.976069       1 reflector.go:240] Listing and watching *v1alpha1.VolumeAttachment from github.com/kubernetes-csi/external-attacher/vendor/k8s.io/client-go/informers/factory.go:86

E0306 16:34:50.992034       1 reflector.go:205] github.com/kubernetes-csi/external-attacher/vendor/k8s.io/client-go/informers/factory.go:86: Failed to list *v1alpha1.VolumeAttachment: the server could not find the requested resource
...
</code></pre>
<p>Please see the <a href="Kubernetes-1.9.html">Kubernetes 1.9</a> page.</p>
<a class="header" href="#problems-with-the-external-components" id="problems-with-the-external-components"><h3>Problems with the external components</h3></a>
<p>The external components images are under active development. It can
happen that they become incompatible with each other. If the
issues above above have been ruled out, <a href="https://github.com/kubernetes/community/tree/master/sig-storage">contact the sig-storage
team</a> and/or
<a href="https://github.com/kubernetes/community/blob/master/contributors/devel/e2e-tests.md#local-clusters">run the e2e test</a>:</p>
<pre><code>go run hack/e2e.go -- --provider=local --test --test_args=&quot;--ginkgo.focus=Feature:CSI&quot;
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
